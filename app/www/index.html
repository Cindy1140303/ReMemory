<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Re Memoryï½œAIè§’è‰²ãƒ»èŠå¤©ãƒ»ç”Ÿå‘½åœ°åœ–</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Capacitor æ ¸å¿ƒå’Œæ’ä»¶ -->
  <script type="module" src="https://unpkg.com/@capacitor/core@latest/dist/capacitor.js"></script>
  <script type="module" src="https://unpkg.com/@capacitor/camera@latest/dist/plugin.js"></script>
  <script type="module" src="https://unpkg.com/@capacitor/filesystem@latest/dist/plugin.js"></script>
  <script type="module" src="https://unpkg.com/@capacitor/preferences@latest/dist/plugin.js"></script>

  <style>
  body{background:#eaeff4;font-family:"Inter","Microsoft JhengHei",system-ui;overflow:hidden}
  .screen{position:absolute;inset:0;display:flex;flex-direction:column}
    .hidden{display:none}
  /* å¼·åˆ¶æ‰‹æ©Ÿå°ºå¯¸ï¼ˆæ¡Œé¢ç‰ˆåªé¡¯ç¤ºæ‰‹æ©Ÿè¦–çª—ï¼‰ */
  .h-app{width:360px;height:640px;background:#fff;border-radius:1.5rem;overflow:hidden;box-shadow:0 25px 50px -12px rgba(0,0,0,.25);position:relative}
  /* å¯é¸çš„å¤–æ¡†æ¨£å¼ï¼Œè®“åœ¨æ¡Œé¢ä¸Šæ›´åƒæ‰‹æ©Ÿè£ç½® */
  .device-frame { padding: 18px; display:flex; align-items:center; justify-content:center; height:100vh; box-sizing:border-box }
  
  /* çœŸå¯¦æ‰‹æ©Ÿç’°å¢ƒä¸‹å¡«æ»¿æ•´å€‹è¢å¹• */
  @media (max-width: 480px) and (pointer: coarse) {
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
    }
    .device-frame { 
      padding: 0; 
      margin: 0;
      height: 100vh;
      width: 100vw;
    }
    .h-app { 
      width: 100vw; 
      height: 100vh; 
      border-radius: 0 !important; 
      box-shadow: none; 
      max-width: none;
      max-height: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    #main-header {
      border-radius: 0 !important;
      border-top-left-radius: 0 !important;
      border-top-right-radius: 0 !important;
    }
    /* ä¿æŒæŒ‰éˆ•åœ“è§’ */
    button {
      border-radius: 0.5rem !important;
    }
    .rounded-xl {
      border-radius: 0.75rem !important;
    }
    .card {
      border-radius: 1rem !important;
    }
  }
    #map{width:100%;height:30vh;border-radius:0.5rem}
    .timeline{display:flex;align-items:center;justify-content:center;gap:48px;padding:12px 0;border-top:3px solid #a6622e;background:#fff}
    .timeline-dot{width:20px;height:20px;border-radius:50%;background:#a6622e}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:16px;box-shadow:0 2px 8px rgba(0,0,0,.06);padding:8px;cursor:pointer;transition:transform .12s ease, box-shadow .12s ease}
    .card:hover{transform:translateY(-2px);box-shadow:0 6px 14px rgba(0,0,0,.12)}
    .card img {
      width: 100%;
      height: auto;            /* ä¸å›ºå®šé«˜åº¦ï¼Œä¿æŒåŸæ¯”ä¾‹ */
      image-rendering: crisp-edges;  /* ğŸ§¡è®“åƒç´ éŠ³åˆ© */
      image-rendering: -webkit-optimize-contrast;
      border-radius: 12px;
    }
    /* ğŸ”§ ä¿®æ­£åœ°åœ–å±¤ç´šï¼Œç¢ºä¿å½ˆçª—æµ®åœ¨æœ€ä¸Šå±¤ */
    #map {
      z-index: 10 !important;
    }
    #map-view button {
      position: relative;
      z-index: 400; /* âœ… è®“æŒ‰éˆ•æµ®åœ¨åœ°åœ–ä¸Š */
      pointer-events: auto;
    }

    #chat-view .flex.flex-col.items-center.gap-4.p-4.overflow-y-auto.flex-1.mt-\[56px\] {
      flex: 0 0 auto !important;
      min-height: 260px !important;
      align-items: center !important;
      justify-content: flex-start !important;
      overflow: visible !important;
    }

    .character-container {
      width: 180px !important;
      height: 180px !important;
      min-width: 180px !important;
      min-height: 180px !important;
      flex-shrink: 0 !important;
      flex-grow: 0 !important;
      display: flex !important;
      align-items: center;
      justify-content: center;
    }

    .character-container img {
      width: 100% !important;
      height: 100% !important;
      object-fit: cover !important;
      object-position: center top !important;
      border-radius: 50% !important;
    }

    #chat-box {
      flex-grow: 1 !important;
      min-height: 220px !important;
      overflow-y: auto !important;
    }


    /* === åº•éƒ¨æ™‚é–“è»¸ === */
  .timeline-bottom {
      position: relative;
      bottom: 40px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
  /* ä¿æŒåœ¨å°å¡ä¹‹ä¸Šä½†ä¸å‡Œé§•æ–¼ modal */
      z-index: 6000;
      align-items: flex-start; /* âœ… è®“åœ“é»é ä¸Šå°é½Šç·šæ¢ */
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.0); /* âœ… å®Œå…¨é€æ˜ */
      height: auto;        /* âœ… å–æ¶ˆå›ºå®šé«˜åº¦ï¼Œé¿å…æ“ å£“ */
      padding: 6px 40px;
      overflow-x: auto;              /* âœ… å…è¨±æ©«å‘æ»¾å‹• */
      scroll-behavior: smooth;       /* âœ… å¹³æ»‘æ»¾å‹• */
      scrollbar-width: none;         /* âœ… éš±è—å·è»¸ï¼ˆFirefoxï¼‰ */
    }
    .timeline-bottom::-webkit-scrollbar {
      display: none; /* âœ… éš±è—å·è»¸ï¼ˆChromeï¼‰ */
    }


    /* === ç¯€é»æ¨£å¼ === */
  .timeline-dot {
      flex: none;           /* âœ… ä¸è¢« flex æ‹‰ä¼¸ */
      /* è®“ z-index ç”Ÿæ•ˆä¸¦å¯æµ®åœ¨æ©«ç·šä¸Šæ–¹ */
      position: relative;
      width: 40px;          /* âœ… å›ºå®šå¯¬åº¦ */
      height: 40px;         /* âœ… å›ºå®šé«˜åº¦ */
      border-radius: 50%;   /* âœ… è®Šåœ“å½¢ */
      background: radial-gradient(circle at 30% 30%, #d9b37c, #8b5e34);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      cursor: pointer;
      transition: all 0.25s ease;
      display: inline-flex;       /* âœ… è®“æŒ‰éˆ•å…§éƒ¨ä¸è¢«æ’é–‹ */
      align-items: center;
      justify-content: center;
      padding: 0 0px 0 0px;
      margin: 0 10px 0 10px;
      line-height: 0;
      /* ç¢ºä¿åœ“é»åœ¨æ©«ç·šä¹‹ä¸Šï¼Œä½†ä½æ–¼ modal */
      z-index: 7000;
    }

    /* hover ç«‹é«”æµ®èµ·æ•ˆæœ */
    .timeline-dot:hover {
      transform: translateY(-3px) scale(1.1);
      background: radial-gradient(circle at 30% 30%, #e8c58f, #a56f3c);
      box-shadow: 0 6px 3px rgba(0, 0, 0, 0.35);
      border-radius: 20px;
    }

    /* active ç‹€æ…‹ */
    .timeline-dot.active {
      transform: scale(1.3);
      background: radial-gradient(circle at 30% 30%, #ffde9b, #b36b2c);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      border-radius: 20px;
    }
    /* === å’–å•¡è‰²æ©«ç·š === */
    .timeline-bottom::before {
      content: "";
      position: absolute; /* âœ… å½å…ƒç´ å¿…é ˆçµ•å°å®šä½ */
      top: 50%;                      /* âœ… å°é½Šç¯€é»ä¸­é–“ */
            /* âœ… ç·šåœ¨åœ“é»ä¸‹æ–¹ */
      left: 0;
      right: 0;
      height: 5px;
      width: var(--line-width, 100%);       /* âœ… è·Ÿå…§å®¹ä¸€æ¨£é•· */
      background: #a6622e;     /* â˜• å’–å•¡è‰²ä¸»é¡Œ */
      border-radius: 20px;
      opacity: 0.7;
      /* æŠŠæ©«ç·šæ”¾åˆ°è¼ƒä½å±¤ï¼Œä¸¦ä¸æ””æˆªåœ“é»äº’å‹• */
      z-index: 0;
      pointer-events: none;
      margin: 0 5px 0 5px;
    }
      /* === Leaflet marker hover æ•ˆæœ === */
    .leaflet-marker-icon {
      border-radius: 12px; /* âœ… åœ“è§’ï¼ˆå¯ä¾åœ–å½¢æ¯”ä¾‹èª¿æ•´ï¼‰ */
      overflow: hidden;    /* âœ… é˜²æ­¢é™°å½±å¤–æº¢ */
      transition: transform 0.25s ease, filter 0.25s ease, box-shadow 0.25s ease;
      transform-origin: center bottom;
    }

    .leaflet-marker-icon:hover {
      transform: scale(1.2); /* æ”¾å¤§ä¸€é» */
      filter: brightness(1.15); /* æäº® */
      box-shadow: 0 0 12px rgba(255, 190, 120, 0.8); /* å…‰æšˆæ•ˆæœ */
      z-index: 100 !important; /* ç¢ºä¿æµ®åœ¨æœ€ä¸Šå±¤ */
    }
    #editModal {
      animation: fadeIn 0.3s ease;
      /* ç¢ºä¿ç·¨è¼¯ modal æ°¸é åœ¨æœ€ä¸Šå±¤ï¼ˆé«˜æ–¼æ™‚é–“è»¸èˆ‡ç¯€é»ï¼‰ */
      z-index: 200000 !important;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }

    #editModal textarea {
      font-size: 15px;
      line-height: 1.5;
    }
    /* === ç”Ÿå‘½åœ°åœ–ä¸‹æ–¹çš„å°å¡å€å¡Š === */
    /* === å›ºå®šå°ºå¯¸ + éŸ¿æ‡‰å¼å®‰å…¨ç¯„åœçš„å°å¡ === */
    .photo-card {
      display: flex;
      flex-direction: row;       /* âœ… æ˜ç¢ºæŒ‡å®šæ©«å‘æ’åˆ— */
      align-items: center;
      justify-content: flex-start;
      background: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      gap: 12px;
      width: 90%;
      max-width: min(340px, 95vw);  /* âœ… æœ€å¤§ä¸è¶…éè¢å¹•å¯¬åº¦ */
      height: clamp(90px, 22vw, 100px);  /* âœ… æ ¹æ“šè¢å¹•è‡ªå‹•ç¸®æ”¾ */
      max-height: 100px;            /* âœ… æœ€å¤§é«˜åº¦é™åˆ¶ */
      margin: 0 auto;
      overflow: hidden;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .photo-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
    }

    /* å·¦å´åœ–ç‰‡ */
    .photo-card img {
      width: clamp(50px, 24vw, 60px);   /* âœ… åœ¨å°è¢å¹•ä¸‹è‡ªå‹•ç¸®å° */
      height: clamp(50px, 24vw, 60px);
      max-height: 60px;
      border-radius: 10px;
      object-fit: contain;          /* âœ… ç­‰æ¯”ä¾‹ç¸®å°é¡¯ç¤ºå®Œæ•´ */
      object-position: left;
      flex-shrink: 0;
      background: #ffff;
      border: 1px solid #d1d1d1;
    }

    /* å³å´æ–‡å­—å€å¡Š */
    .photo-card .info {
      display: flex;
      flex-direction: column;
      justify-content: center;   /* âœ… å‚ç›´ç½®ä¸­ */
      text-align: left;          /* âœ… æ–‡å­—é å·¦ */
      flex: 1;
      overflow: hidden;
    }

    .photo-card .info .title {
      font-weight: bold;
      color: #7a4a22;
      margin-bottom: 4px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      font-size: clamp(13px, 3.5vw, 15px); /* âœ… éŸ¿æ‡‰å¼å­—é«” */
    }

    .photo-card .info .date {
      font-size: 12px;
      color: #666;
      margin-bottom: 2px;
    }

    .photo-card .info div:last-child {
      font-size: 14px;
      color: #444;
      line-height: 1.4;
      max-height: 3.5em;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* === éŸ¿æ‡‰å¼ï¼ˆæ‰‹æ©Ÿè¢å¹• < 400pxï¼‰ === */
    @media (max-width: 400px) {
      .photo-card {
        height: 90px;
        max-width: 300px;
        gap: 8px;
        padding: 8px 10px;
      }
      .photo-card img {
        width: 70px;
        height: 70px;
      }
      .photo-card .info .title {
        font-size: 13px;
      }
      .photo-card .info div:last-child {
        font-size: 12px;
      }
    }
    #photo-card-container {
      position: relative;
      margin-top: -50px;   /* â¬†ï¸ è®“å°å¡å¾€ä¸Šé è¿‘åœ°åœ–ï¼Œä¾ä½ è¦çš„è·é›¢å¯èª¿æ•´ */
      z-index: 10;       /* âœ… æµ®åœ¨åœ°åœ–ä¸Šå±¤ */
      pointer-events: auto;
      transition: margin-top 0.3s ease;
    }

    /* å°å¡æœ¬é«”æ¨£å¼ */
    #photo-card-container .card {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 16px;
      box-shadow: 0 2px 10px #ffde9b;
      padding: 10px;
      text-align: center;
      width: 90%;
      margin: 0 auto;
      position: relative;
      z-index: 5001;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    /* hover æ•ˆæœï¼ˆå¾®æµ®èµ·ï¼‰ */
    #photo-card-container .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 18px #ffde9b;
    }


    /* å°å¡ä¸Šæµ®é¡¯ç¤º */
    .card-popup {
      animation: popup 0.4s ease forwards;
    }

    @keyframes popup {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    /* === ç¯€é»ç™¼å…‰å‹•ç•« === */
    .timeline-dot.active {
      transform: scale(1.3);
      background: radial-gradient(circle at 30% 30%, #ffde9b, #b36b2c);
      box-shadow: 
        0 0 3px rgba(255, 200, 100, 0.9);   /* ç™¼äº®æ ¸å¿ƒ */
      border-radius: 100%; /* âœ… ç¢ºä¿ä»æ˜¯åœ“å½¢ */
      transition: all 0.25s ease;
    }

    /* === åˆªé™¤æç¤ºå°è¦–çª— === */
    #deleteConfirm {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 500;
    }
    #deleteConfirm .box {
      background: #fff;
      border-radius: 1rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
      width: 90%;                 /* âœ… æ”¹ç‚ºç™¾åˆ†æ¯”ï¼Œé©é…è¢å¹• */
      max-width: 320px;           /* âœ… æœ€å¤§å¯¬åº¦é™åˆ¶ï¼Œé¿å…å¤ªå¯¬ */
      padding: 16px;
      text-align: center;
      animation: fadeIn 0.3s ease;
      box-sizing: border-box;      /* âœ… ç¢ºä¿ padding ä¸é€ æˆè¶…å¯¬ */
      word-wrap: break-word;       /* âœ… é•·å­—ä¸æ’å‡ºè¢å¹• */
    }

    /* ğŸ”¹ åœ¨æ¥µå°è¢å¹•ï¼ˆä¾‹å¦‚ iPhone SEï¼‰è‡ªå‹•ç¸®å°å­—é«”èˆ‡é–“è· */
    @media (max-width: 400px) {
      #deleteConfirm .box {
        padding: 14px;
        max-width: 90%;
      }
      #deleteConfirm .box p {
        font-size: 14px;
      }
      #deleteConfirm button {
        font-size: 14px;
        padding: 6px 12px;
      }
    }

    #deleteConfirm button {
      margin: 8px;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 600;
    }
    #deleteConfirm .confirm {
      background: #e57373;
      color: #fff;
    }
    #deleteConfirm .cancel {
      background: #ddd;
      color: #444;
    }

    .spinner{width:64px;height:64px;border-radius:50%;border:6px solid #e7e1db;border-top-color:#8b5e34;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .is-recording{animation:pulse 1s infinite;border:3px solid #ef4444}
    @keyframes pulse{0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,.7)}70%{box-shadow:0 0 0 10px rgba(239,68,68,0)}}
    /* hero-textï¼šç½®ä¸­ä¸”é è¿‘ headerï¼Œä¸‹æ–¹ç•™ç™½èˆ‡å­—é«”å¾®èª¿ä»¥åŒ¹é… UI æˆªåœ– */
    #char-empty .hero-text {
      position: absolute;
      left: 1rem;
      right: 1rem;
      top: 30rem; /* å¯å†å¾®èª¿ï¼šæ•¸å­—è¶Šå°è¶Šé ä¸Š */
      text-align: center;
      margin: 0;
      color: #7a4a22;
      font-size: 1.15rem;
      line-height: 1.6;
      font-weight: 700;
      padding: 0.4rem 0;
      pointer-events: none; /* é¿å…è“‹åˆ°ä¸‹æ–¹æŒ‰éˆ•çš„é»æ“Š */
    }
    @media (max-width: 420px) {
      #char-empty .hero-text {
        top: 2.8rem;
        font-size: 1.05rem;
      }
    }
    /* è«è˜­è¿ªç¶ è‰²æ¼¸å±¤ï¼ˆä½é£½å’Œã€ç°åŒ–ã€æŸ”å’Œï¼‰ */
    .btn-map-gradient {
      /* Morandi-inspired muted greens */
      background:#4A7056;
      color: #fdfdfd; /* ç¨å¾®åæš–çš„æ·ºè‰²æ–‡å­—ï¼Œèˆ‡è«è˜­è¿ªè‰²ç³»å”èª¿ */
      padding: 0.5rem 0.75rem;
      border-radius: 0.75rem;
      transition: transform .12s ease, box-shadow .12s ease, filter .12s ease;
      /* æ›´æŸ”å’Œçš„é™°å½±ï¼Œå¸¶ä¸€é»ç°èª¿ */
      box-shadow: 0 2px 6px rgba(60, 72, 64, 0.08);
      border: 1px solid rgba(120,130,118,0.08);
    }
    .btn-map-gradient:hover {
      transform: translateY(-1px);
      /* hover è¼•å¾®åŠ æ·±é¡è‰²è€Œä¸æ˜¯è®Šäº®ï¼Œç¬¦åˆè«è˜­è¿ªæ²‰ç©©ç‰¹æ€§ */
      filter: brightness(0.96);
      box-shadow: 0 6px 10px rgba(60,72,64,0.10);
    }
  </style>
</head>

<body class="flex items-center justify-center h-screen">
  <div class="device-frame">
    <div class="h-app">
    <!-- Headerï¼šå…¨é å…±ç”¨ -->
    <header id="main-header" 
      class="flex items-center justify-between bg-[#4a6fa5] text-white py-3 px-3 
            absolute top-0 left-0 right-0 shadow-md"
      style="z-index:8000 !important; border-radius: 0 !important;">
      <!-- è¿”å›æŒ‰éˆ• -->
      <button id="backBtn" onclick="handleBack()" class="text-sm opacity-90">â† è¿”å›</button>

      <!-- æ¨™é¡Œ -->
  <h1 id="pageTitle" class="text-lg font-semibold text-right px-12 flex-grow text-white select-none">AIè§’è‰²é¸æ“‡</h1>

      <!-- ä¸‰é»é¸å–® (åƒ…èŠå¤©ç•«é¢é¡¯ç¤º) -->
      <div id="chatMenu" class="relative">
        <button onclick="toggleDropdown('chat-dropdown')" 
          class="text-xl opacity-80 hover:bg-[#39587e] rounded-full px-2 mr-8 transition">â‹®</button>

        <!-- ä¸‹æ‹‰é¸å–® -->
        <div id="chat-dropdown" 
          class="absolute right-0 mt-3 w-28 bg-white rounded-lg shadow-xl py-1 z-20 hidden">
          <button onclick="showModal('åŠŸèƒ½æœªå¯¦ä½œï¼šèªè¨€')" 
            class="flex items-center px-4 py-2 text-sm text-gray-700 w-full text-left hover:bg-gray-100">ğŸŒ èªè¨€</button>
          <button onclick="openShareModal()" 
            class="flex items-center px-4 py-2 text-sm text-gray-700 w-full text-left hover:bg-gray-100">ğŸ”— åˆ†äº«</button>
          <button onclick="showModal('åŠŸèƒ½æœªå¯¦ä½œï¼šè¨­å®š')" 
            class="flex items-center px-4 py-2 text-sm text-gray-700 w-full text-left hover:bg-gray-100">âš™ï¸ è¨­å®š</button>
        </div>
      </div>

      <!-- é—œé–‰æŒ‰éˆ• -->
      <button class="text-lg opacity-80 ml-2" onclick="handleClose()">âœ–</button>
    </header>

  <!-- å…¨åŸŸ toastï¼ˆé¡¯ç¤ºåœ¨æ‰‹æ©Ÿæ¡†å…§ï¼‰ -->
  <div id="toast-container" class="fixed top-4 left-1/2 transform -translate-x-1/2 z-4000 hidden" style="width:88%"></div>

  <!-- ğŸŒŸ åˆ†äº«è¦–çª—ï¼ˆæ”¾åœ¨ body ä¸­ï¼Œç¢ºä¿èƒ½è¢«ä»»ä½•é é¢å‘¼å«ï¼‰ -->
  <div id="shareModal" 
    class="fixed inset-0 bg-black/40 flex items-center justify-center hidden transition" style="z-index:200100;">
    <div class="bg-white rounded-2xl w-11/12 max-w-sm p-6 shadow-2xl text-center relative mx-4">
      <h2 class="text-lg font-bold text-gray-800 mb-4">åˆ†äº«é€™å€‹é é¢</h2>
      
      <div class="flex flex-col gap-3">
        <button onclick="shareToFacebook()" 
          class="flex items-center justify-center gap-2 bg-[#1877F2] text-white font-semibold py-3 px-4 rounded-xl hover:bg-[#145BD1] transition">
          <img src="https://www.svgrepo.com/show/452196/facebook-1.svg" class="w-5 h-5" alt=""> Facebook
        </button>
        <button onclick="shareToLine()" 
          class="flex items-center justify-center gap-2 bg-[#06C755] text-white font-semibold py-3 px-4 rounded-xl hover:bg-[#05B04D] transition">
          <img src="https://www.line.me/static/img/icon-line_1.png" class="w-5 h-5" alt=""> LINE
        </button>
        <button onclick="copyLink()" 
          class="flex items-center justify-center gap-2 bg-gray-200 text-gray-800 font-semibold py-3 px-4 rounded-xl hover:bg-gray-300 transition">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 17l4 4 4-4m0-10l-4-4-4 4m4 14V3"/></svg>
          è¤‡è£½é€£çµ
        </button>
      </div>

      <!-- é—œé–‰æŒ‰éˆ• -->
      <button onclick="closeShareModal()" 
        class="absolute top-2 right-3 text-gray-500 hover:text-gray-800 text-lg font-bold">âœ•</button>
    </div>
  </div>



    <!-- A. åˆå§‹ç•«é¢ -->
    <section id="char-empty" class="screen">
      <div class="px-4 py-5 text-center flex-1 mt-[56px]"> <!-- é ç•™ header é«˜åº¦ -->
        <p class="text-2xl font-bold text-[#7a4a22] leading-relaxed mt-8">
          ç›®å‰ç„¡è§’è‰²<br/>å¯ä»¥åˆ©ç”¨æŒ‰éˆ•ç”Ÿæˆè§’è‰²ï½
        </p>
        <div class="mt-8">
          <textarea id="charPrompt" rows="3"
            class="w-full rounded-2xl border border-gray-300 bg-gray-100 text-gray-600 text-center p-4"
            placeholder="éŒ„éŸ³æ–‡å­—é¡¯ç¤ºå€ï½œæ­¤å€æ–‡å­—å¯ç›´æ¥ä¿®æ”¹"></textarea>
        </div>
        <div class="mt-8 flex items-center justify-center gap-10">
          <button id="recordBtn" class="px-8 py-2 rounded-xl bg-[#c08955] text-white shadow">ğŸ¤  éŒ„éŸ³</button>
          <button id="charSend0" class="px-8 py-2 rounded-xl bg-[#c08955] text-white shadow">â–¶  é€å‡º</button>
        </div>
        <div class="mt-5">
          <button id="charAuto" class="w-full py-3 rounded-xl bg-[#e7c8a3] text-[#6d492b] font-bold shadow">
            âœ¨ è‡ª å‹• ç”Ÿ æˆ
          </button>
        </div>
      </div>
    </section>

    <!-- B. è¼‰å…¥ä¸­ -->
    <section id="char-loading" class="screen hidden">
      <div class="flex flex-col items-center justify-center flex-1 gap-4 mt-[56px]">
        <div class="spinner"></div>
        <div class="text-[#7a4a22] font-semibold text-lg">è¼‰å…¥ä¸­ï¼ŒAI æ­£åœ¨ç¹ªè£½è§’è‰²ä¸­...</div>
      </div>
    </section>

    <!-- C. ä¹å®®æ ¼ -->
    <section id="char-list" class="screen hidden">
      <div class="p-4 text-center flex-1 overflow-y-auto mt-[56px]">
        <p class="text-xl font-bold text-[#7a4a22] leading-relaxed mb-3">
          ğŸ‘‹ é¸æ“‡ä½ çš„AIå¤¥ä¼´è§’è‰²ï½
        </p>
        <div id="cardGrid" class="grid grid-cols-3 gap-3"></div>
        
        <!-- è‡ªå®šç¾©è§’è‰²ä¸Šå‚³æŒ‰éˆ• -->
        <div class="mt-4 pt-4 border-t border-gray-200">
          <button id="btnUploadCustomChar" 
            class="w-full py-3 px-6 bg-gradient-to-r from-purple-400 to-pink-400 text-white font-bold rounded-xl shadow-lg hover:from-purple-500 hover:to-pink-500 transition">
            ğŸ“· ä¸Šå‚³è‡ªå®šç¾©è§’è‰²
          </button>
          <p class="text-xs text-gray-500 mt-2">å¾æ‰‹æ©Ÿç›¸ç°¿é¸æ“‡åœ–ç‰‡ä½œç‚ºä½ çš„ AI è§’è‰²</p>
        </div>
      </div>
    </section>

    <!-- D. èŠå¤© -->
    <section id="chat-view" class="screen hidden">
      <!-- èŠå¤©å…§å®¹å€ -->
      <div class="flex flex-col items-center gap-4 p-4 overflow-y-auto flex-1 mt-[56px]">
        <div class="character-container">
          <img id="chat-avatar" src="https://placehold.co/144x144/f9d853/4a6fa5?text=AI" alt="AIé ­åƒ" />
        </div>
        <div id="chat-box" class="flex flex-col gap-3 text-center text-gray-800 text-lg font-semibold leading-relaxed p-4">
          <div class="text-gray-500 text-sm">ğŸ™ é»æ“Šä¸‹æ–¹éº¥å…‹é¢¨é–‹å§‹å°è©±</div>
        </div>
      </div>

      <div class="mt-auto border-t border-gray-200 bg-white py-4 flex flex-col items-center">
        <!-- è¼¸å…¥æ¬„ï¼ˆé ä¸Šï¼‰ -->
        <textarea id="chatInput" rows="2"
          class="w-11/12 rounded-xl border border-gray-300 bg-gray-50 text-gray-700 p-3 text-sm mb-3"
          placeholder="éŒ„éŸ³æˆ–è¼¸å…¥æƒ³èªªçš„è©±..."></textarea>

        <!-- éº¥å…‹é¢¨èˆ‡é€å‡ºæŒ‰éˆ•ï¼ˆç½®ä¸­ä¸¦æ’ï¼‰ -->
        <div class="flex items-center gap-10 justify-center mb-5">
          <button id="recordBtnChat" class="px-4 py-2 flex items-center justify-center rounded-xl bg-[#d9b37c] text-white shadow">ğŸ¤éŒ„éŸ³</button>
          <button id="chatSend" class="px-4 py-2 rounded-xl bg-[#c08955] text-white shadow">â–¶ é€å‡º</button>
        </div>

        <!-- åˆ°ç”Ÿå‘½åœ°åœ–ï¼ˆåº•éƒ¨ç½®ä¸­ï¼‰ -->
        <div class="w-full flex items-center justify-center">
          <button id="toMapBtn" onclick="goToMap()" class="mb-5 px-10 py-2 btn-map-gradient">åˆ°ç”Ÿå‘½åœ°åœ–</button>
        </div>
      </div>

    </section>

    <!-- E. åœ°åœ– -->
    <section id="map-view" class="screen hidden">
      <div class="p-2 mt-[56px]">
        <div id="map"></div>
        <div class="mt-2 flex gap-2 justify-center">
          <button class="flex-1 bg-green-200 py-2 rounded opacity-80 hover:opacity-100">â—€</button>
          <button onclick="openAudioManager()" class="flex-1 bg-purple-200 py-2 rounded opacity-80 hover:opacity-100 text-sm">ğŸµ éŒ„éŸ³</button>
          <button class="flex-1 bg-green-200 py-2 rounded opacity-80 hover:opacity-100">â–¶</button>
        </div>
      </div>
      <div id="photo-card-container" class="px-3 flex-1 flex items-center justify-center text-gray-600 text-sm">
        é»æ“Šåœ°åœ–ä¸Šçš„ç”Ÿå‘½æ¨¹æ¨™è¨˜ï¼ŒæŸ¥çœ‹å›æ†¶ç…§ç‰‡ã€‚
      </div>
      <!-- ğŸŒŸ é ‚éƒ¨æ™‚é–“è»¸ -->
      <div id="timeline" class="timeline-bottom"></div>

    </section>
  <!-- ğŸŒŸ å°å¡ç·¨è¼¯ç•«é¢ -->
  <!-- æ”¹æˆ absoluteï¼Œè®“å®šä½èˆ‡å¯¬åº¦ç›¸å°æ–¼ .h-appï¼ˆå¯¬åº¦ 360px çš„æ‰‹æ©Ÿæ¡†ï¼‰ -->
  <div id="editModal" class="absolute inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 hidden">
  <div class="bg-white w-[78%] max-w-xs rounded-2xl shadow-2xl p-3 relative flex flex-col box-border">
        <h2 class="text-lg font-bold text-center text-[#7a4a22] mb-3">âœï¸ ç·¨è¼¯å›æ†¶å°å¡</h2>

        <textarea id="editTextArea" 
          class="w-full flex-1 border border-gray-300 rounded-xl p-3 text-gray-800 mb-3 resize-none"
          rows="8" placeholder="é€™è£¡é¡¯ç¤ºå®Œæ•´éŒ„éŸ³æ–‡å­—..."></textarea>

    <!-- ç…§ç‰‡é è¦½èˆ‡ä¸Šå‚³ -->
    <div class="flex flex-col items-center mb-3">
      <img id="editPreview" class="rounded-xl max-h-40 object-cover mb-2 hidden"/>
      <input type="file" id="editUpload" accept="image/*" class="text-sm"/>
      <div id="editUploadStatus" class="text-sm text-green-600 mt-2 hidden"></div>
    </div>

    <!-- æŒ‰éˆ•åˆ— -->
    <div class="flex justify-between mt-3">
      <button id="btnSaveEdit" class="bg-amber-400 text-[#5b3a17] px-4 py-2 rounded-lg font-bold">ğŸ’¾ å„²å­˜</button>
      <button id="btnCancelEdit" class="bg-red-300 text-white px-4 py-2 rounded-lg">å–æ¶ˆ</button>
    </div>
    </div>
  </div>
</div>
  <!-- ğŸŒŸ åˆªé™¤ç¢ºèªè¦–çª— -->
  <div id="deleteConfirm">
    <div class="box">
      <p class="text-lg font-bold text-[#7a4a22] mb-3">ğŸ—‘ ç¢ºå®šè¦åˆªé™¤æ­¤å›æ†¶å—ï¼Ÿ</p>
      <p class="text-sm text-gray-600 mb-4">åˆªé™¤å¾Œå°‡ç„¡æ³•å¾©åŸã€‚</p>
      <div>
        <button class="cancel" onclick="closeDeleteConfirm()">å–æ¶ˆ</button>
        <button class="confirm" onclick="confirmDelete()">åˆªé™¤</button>
      </div>
    </div>

      <!-- ğŸŒŸ ä»˜è²»ç¤ºæ„è¦–çª—ï¼ˆè²éŸ³ç”Ÿæˆåœ–ç‰‡éœ€ä»˜è²»ï¼‰ -->
      <div id="payModal" class="absolute inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-60 hidden">
        <div class="bg-white w-[86%] max-w-xs rounded-xl shadow-2xl p-4 relative flex flex-col box-border text-center">
          <h3 class="text-lg font-bold text-[#7a4a22] mb-2">ğŸ”’ éœ€è¦ä»˜è²»å•Ÿç”¨</h3>
          <p class="text-sm text-gray-600 mb-4">ä½¿ç”¨ã€Œè²éŸ³ç”¢ç”Ÿåœ–ç‰‡ã€åŠŸèƒ½éœ€ä»˜è²»è§£é–ã€‚ç¤ºæ„åƒ¹æ ¼ï¼šNT$30 / æ¬¡ã€‚</p>
          <div id="payPreview" class="text-sm text-gray-800 p-2 mb-4 bg-gray-50 rounded" style="min-height:48px;white-space:pre-wrap;text-align:left;"></div>
          <div class="flex gap-3 justify-center">
            <button id="btnConfirmPay" class="px-4 py-2 bg-[#e7c8a3] rounded-xl shadow">ä»˜è²»å•Ÿç”¨ (NT$30)</button>
            <button id="btnCancelPay" class="px-4 py-2 bg-gray-200 rounded-xl shadow">å–æ¶ˆ</button>
          </div>
        </div>
      </div>
  </div>

</div>
 

<script>    
// === å¤šé‡ API ç«¯é»è¨­å®š ===
const API_ENDPOINTS = {
  // æœ¬åœ°é–‹ç™¼ (MSSQL)
  local: "http://127.0.0.1:8010",
  
  // Vercel éƒ¨ç½² (MongoDB) - å¾…éƒ¨ç½²
  vercel: "https://re-memory-eight.vercel.app/api/save_memory",
  
  // ç›´æ¥ä½¿ç”¨ Hugging Face APIï¼ˆæš«æ™‚æ–¹æ¡ˆï¼‰
  huggingface: "https://api-inference.huggingface.co",
  
  // ç•¶å‰ä½¿ç”¨çš„ç«¯é» - æš«æ™‚ä½¿ç”¨æœ¬åœ°æ¨¡å¼ä½†æ”¯æ´å›é€€
  current: "local" // è‡ªå‹•å›é€€åˆ° HF API
};

const BACKEND_URL = API_ENDPOINTS[API_ENDPOINTS.current];
const HF_IMAGE_URL = `${BACKEND_URL}/generate-gpt`;    // ğŸ¨ ç”Ÿåœ–ç«¯é»
const HF_PHOTO_URL = `${BACKEND_URL}/api/photo/upload`; // ğŸ–¼ ç…§ç‰‡ä¸Šå‚³
// ===== Hugging Face API è¨­å®š =====
const HF_ASR_URL = "https://api-inference.huggingface.co/models/openai/whisper-large-v3";
const HF_CHAT_URL =  `${BACKEND_URL}/api/chat`;

// === ç¶²è·¯ç‹€æ…‹ç®¡ç† ===
const NetworkManager = {
  isOnline: () => navigator.onLine,
  
  // æª¢æ¸¬å¾Œç«¯é€£ç·šç‹€æ…‹ï¼ˆæ”¯æ´å¤šå€‹ç«¯é»ï¼‰
  async checkBackendConnection() {
    if (!this.isOnline()) return false;
    
    // å˜—è©¦ä¸åŒçš„ç«¯é»
    const endpointsToTry = [
      { name: 'current', url: BACKEND_URL },
      { name: 'vercel', url: API_ENDPOINTS.vercel },
      { name: 'local', url: API_ENDPOINTS.local }
    ];
    
    for (const endpoint of endpointsToTry) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000);
        
        const response = await fetch(`${endpoint.url}/api/health`, { 
          method: 'GET',
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          console.log(`âœ… å¾Œç«¯é€£ç·šæˆåŠŸ: ${endpoint.name} (${endpoint.url})`);
          
          // å¦‚æœä¸æ˜¯ç•¶å‰ä½¿ç”¨çš„ç«¯é»ï¼Œæ›´æ–°é…ç½®
          if (endpoint.url !== BACKEND_URL) {
            console.log(`ğŸ”„ åˆ‡æ›åˆ°å¯ç”¨ç«¯é»: ${endpoint.name}`);
            // å‹•æ…‹æ›´æ–°ç«¯é»ï¼ˆå¯é¸ï¼‰
          }
          
          return { success: true, endpoint: endpoint.name, url: endpoint.url };
        }
      } catch (error) {
        console.log(`âŒ ${endpoint.name} ç«¯é»é€£ç·šå¤±æ•—:`, error.message);
        continue;
      }
    }
    
    console.log('âŒ æ‰€æœ‰å¾Œç«¯ç«¯é»éƒ½ç„¡æ³•é€£ç·š');
    return { success: false, error: 'æ‰€æœ‰å¾Œç«¯æœå‹™éƒ½ç„¡æ³•é€£ç·š' };
  },
  
  // ç¶²è·¯ç‹€æ…‹ç›£è½
  setupNetworkListeners() {
    window.addEventListener('online', () => {
      console.log('ğŸŒ ç¶²è·¯é€£ç·šæ¢å¾©');
      showToast('ğŸŒ ç¶²è·¯é€£ç·šæ¢å¾©ï¼Œæº–å‚™åŒæ­¥è³‡æ–™', { type: 'success' });
      this.syncPendingData();
    });
    
    window.addEventListener('offline', () => {
      console.log('âŒ ç¶²è·¯é€£ç·šä¸­æ–·');
      showToast('âŒ ç¶²è·¯ä¸­æ–·ï¼Œå°‡æš«å­˜åˆ°æœ¬åœ°', { type: 'info' });
    });
  },
  
  // åŒæ­¥å¾…è™•ç†è³‡æ–™
  async syncPendingData() {
    if (!this.isOnline()) return;
    
    try {
      const pendingData = await LocalStorage.getPendingSync();
      console.log('ğŸ”„ ç™¼ç¾å¾…åŒæ­¥è³‡æ–™:', pendingData.length, 'ç­†');
      
      for (const data of pendingData) {
        try {
          await this.syncToBackend(data);
          await LocalStorage.markAsSynced(data.id);
          console.log('âœ… æˆåŠŸåŒæ­¥:', data.id);
        } catch (syncError) {
          console.error('âŒ åŒæ­¥å¤±æ•—:', data.id, syncError);
        }
      }
      
      if (pendingData.length > 0) {
        showToast(`âœ… æˆåŠŸåŒæ­¥ ${pendingData.length} ç­†è³‡æ–™`, { type: 'success' });
      }
    } catch (error) {
      console.error('åŒæ­¥éç¨‹å‡ºéŒ¯:', error);
    }
  },
  
  // åŒæ­¥è³‡æ–™åˆ°å¾Œç«¯
  async syncToBackend(data) {
    const response = await fetch(`${BACKEND_URL}/api/memories`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${await response.text()}`);
    }
    
    return await response.json();
  }
};

// === æœ¬åœ°å„²å­˜ç®¡ç† (for APK) ===
const LocalStorage = {
  // æª¢æŸ¥æ˜¯å¦åœ¨ Capacitor ç’°å¢ƒä¸­
  isCapacitor: () => {
    // ç°¡åŒ–æª¢æ¸¬é‚è¼¯ï¼Œç›´æ¥æª¢æŸ¥æ˜¯å¦åœ¨æ‰‹æ©Ÿç’°å¢ƒ
    return window.Capacitor || 
           (window.screen.width <= 768 && 'ontouchstart' in window) ||
           navigator.userAgent.includes('Mobile');
  },
  
  // å„²å­˜å›æ†¶è¨˜éŒ„
  async saveMemory(memoryData) {
    try {
      console.log('å˜—è©¦å„²å­˜è¨˜æ†¶:', memoryData);
      console.log('æ˜¯å¦ç‚º Capacitor ç’°å¢ƒ:', this.isCapacitor());
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        
        // ç”Ÿæˆå”¯ä¸€ ID
        const id = Date.now().toString();
        memoryData.id = id;
        memoryData.created_at = new Date().toISOString();
        
        // ç²å–ç¾æœ‰å›æ†¶åˆ—è¡¨
        const { value } = await Preferences.get({ key: 'memories' });
        const memories = value ? JSON.parse(value) : [];
        
        // æ·»åŠ æ–°å›æ†¶
        memories.push(memoryData);
        
        // å„²å­˜å›æœ¬åœ°
        await Preferences.set({
          key: 'memories',
          value: JSON.stringify(memories)
        });
        
        console.log('æˆåŠŸå„²å­˜åˆ° Capacitor Preferences');
        return { success: true, id };
      } else {
        // å›é€€åˆ° localStorage
        console.log('ä½¿ç”¨ localStorage å„²å­˜');
        const memories = JSON.parse(localStorage.getItem('memories') || '[]');
        const id = Date.now().toString();
        memoryData.id = id;
        memoryData.created_at = new Date().toISOString();
        memories.push(memoryData);
        localStorage.setItem('memories', JSON.stringify(memories));
        console.log('æˆåŠŸå„²å­˜åˆ° localStorage');
        return { success: true, id };
      }
    } catch (error) {
      console.error('å„²å­˜å›æ†¶å¤±æ•—:', error);
      return { success: false, error: error.message };
    }
  },
  
  // è¼‰å…¥æ‰€æœ‰å›æ†¶è¨˜éŒ„
  async loadMemories() {
    try {
      if (this.isCapacitor()) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'memories' });
        return value ? JSON.parse(value) : [];
      } else {
        return JSON.parse(localStorage.getItem('memories') || '[]');
      }
    } catch (error) {
      console.error('è¼‰å…¥å›æ†¶å¤±æ•—:', error);
      return [];
    }
  },
  
  // å„²å­˜ç…§ç‰‡åˆ°æœ¬åœ°æª”æ¡ˆç³»çµ±
  async savePhoto(photoBlob, filename) {
    try {
      if (this.isCapacitor()) {
        const { Filesystem } = window.Capacitor.Plugins;
        
        // å°‡ Blob è½‰æ›ç‚º base64
        const base64Data = await this.blobToBase64(photoBlob);
        
        // å„²å­˜åˆ° APP å…§éƒ¨ç›®éŒ„
        const savedFile = await Filesystem.writeFile({
          path: filename,
          data: base64Data,
          directory: 'data'
        });
        
        return savedFile.uri;
      } else {
        // æ¡Œé¢ç‰ˆæš«æ™‚è¿”å› Object URL
        return URL.createObjectURL(photoBlob);
      }
    } catch (error) {
      console.error('å„²å­˜ç…§ç‰‡å¤±æ•—:', error);
      return null;
    }
  },
  
  // Blob è½‰ base64 è¼”åŠ©å‡½æ•¸
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  },
  
  // æ¨¡æ“¬ AI èŠå¤©å›æ‡‰ (é›¢ç·šç‰ˆ)
  async getOfflineAIReply(text) {
    // ç°¡å–®çš„å›æ‡‰æ¨¡å¼åŒ¹é…
    const responses = {
      greeting: ["ä½ å¥½ï¼å¾ˆé«˜èˆˆå’Œä½ èŠå¤©ï¼", "å—¨ï¼ä»Šå¤©éå¾—æ€éº¼æ¨£ï¼Ÿ", "å“ˆå›‰ï¼æœ‰ä»€éº¼æƒ³èŠçš„å—ï¼Ÿ"],
      mood: ["è½èµ·ä¾†ä½ çš„å¿ƒæƒ…ä¸éŒ¯å‘¢ï¼", "æˆ‘èƒ½æ„Ÿå—åˆ°ä½ çš„æƒ…æ„Ÿï¼Œæƒ³å¤šèªªä¸€äº›å—ï¼Ÿ", "è¬è¬ä½ å’Œæˆ‘åˆ†äº«ä½ çš„æ„Ÿå—ï¼"],
      memory: ["é€™æ˜¯å¾ˆçè²´çš„å›æ†¶å‘¢ï¼", "è½èµ·ä¾†æ˜¯å€‹å¾ˆç‰¹åˆ¥çš„æ™‚åˆ»ï¼", "è¬è¬ä½ åˆ†äº«é€™å€‹ç¾å¥½çš„è¨˜æ†¶ï¼"],
      question: ["é€™æ˜¯å€‹å¾ˆæœ‰è¶£çš„å•é¡Œï¼", "è®“æˆ‘æƒ³æƒ³...", "ä½ è¦ºå¾—å‘¢ï¼Ÿæˆ‘å¾ˆæƒ³è½è½ä½ çš„æƒ³æ³•ï¼"],
      default: ["æˆ‘åœ¨ä»”ç´°è½ä½ èªªè©±ï¼", "ç¹¼çºŒå‘Šè¨´æˆ‘å§ï¼", "å—¯å—¯ï¼Œç„¶å¾Œå‘¢ï¼Ÿ", "æˆ‘æ˜ç™½ä½ çš„æ„æ€ï¼", "é€™å¾ˆæœ‰æ„æ€ï¼"]
    };
    
    // ç°¡å–®çš„é—œéµå­—åŒ¹é…
    const lowerText = text.toLowerCase();
    
    let responseType = 'default';
    if (lowerText.includes('ä½ å¥½') || lowerText.includes('å—¨') || lowerText.includes('å“ˆå›‰')) {
      responseType = 'greeting';
    } else if (lowerText.includes('å¿ƒæƒ…') || lowerText.includes('æ„Ÿè¦º') || lowerText.includes('é–‹å¿ƒ') || lowerText.includes('é›£é')) {
      responseType = 'mood';
    } else if (lowerText.includes('è¨˜å¾—') || lowerText.includes('ä»¥å‰') || lowerText.includes('é‚£æ™‚')) {
      responseType = 'memory';
    } else if (lowerText.includes('ï¼Ÿ') || lowerText.includes('?') || lowerText.includes('ç‚ºä»€éº¼') || lowerText.includes('æ€éº¼')) {
      responseType = 'question';
    }
    
    const responseList = responses[responseType];
    const randomResponse = responseList[Math.floor(Math.random() * responseList.length)];
    
    return {
      response: randomResponse,
      timestamp: new Date().toISOString()
    };
  },
  
  // === åŒæ­¥ç›¸é—œæ–¹æ³• ===
  
  // å„²å­˜å¾…åŒæ­¥è³‡æ–™
  async savePendingSync(data) {
    try {
      data.pendingSync = true;
      data.syncAttempts = 0;
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingSync' });
        const pending = value ? JSON.parse(value) : [];
        pending.push(data);
        await Preferences.set({ key: 'pendingSync', value: JSON.stringify(pending) });
      } else {
        const pending = JSON.parse(localStorage.getItem('pendingSync') || '[]');
        pending.push(data);
        localStorage.setItem('pendingSync', JSON.stringify(pending));
      }
      
      console.log('ğŸ“¤ è³‡æ–™æ¨™è¨˜ç‚ºå¾…åŒæ­¥:', data.id);
    } catch (error) {
      console.error('å„²å­˜å¾…åŒæ­¥è³‡æ–™å¤±æ•—:', error);
    }
  },
  
  // ç²å–å¾…åŒæ­¥è³‡æ–™
  async getPendingSync() {
    try {
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingSync' });
        return value ? JSON.parse(value) : [];
      } else {
        return JSON.parse(localStorage.getItem('pendingSync') || '[]');
      }
    } catch (error) {
      console.error('è¼‰å…¥å¾…åŒæ­¥è³‡æ–™å¤±æ•—:', error);
      return [];
    }
  },
  
  // æ¨™è¨˜è³‡æ–™ç‚ºå·²åŒæ­¥
  async markAsSynced(dataId) {
    try {
      const pending = await this.getPendingSync();
      const filtered = pending.filter(item => item.id !== dataId);
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        await Preferences.set({ key: 'pendingSync', value: JSON.stringify(filtered) });
      } else {
        localStorage.setItem('pendingSync', JSON.stringify(filtered));
      }
      
      console.log('âœ… è³‡æ–™æ¨™è¨˜ç‚ºå·²åŒæ­¥:', dataId);
    } catch (error) {
      console.error('æ¨™è¨˜åŒæ­¥ç‹€æ…‹å¤±æ•—:', error);
    }
  },
  
  // å„²å­˜éŸ³é »åˆ°æœ¬åœ°ï¼ˆå¾…ä¸Šå‚³ï¼‰
  async saveAudioForUpload(audioBlob, metadata) {
    try {
      const id = Date.now().toString();
      const audioData = {
        id: id,
        blob: await this.blobToBase64(audioBlob),
        metadata: metadata,
        type: 'audio',
        created_at: new Date().toISOString(),
        pendingUpload: true
      };
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingAudio' });
        const pending = value ? JSON.parse(value) : [];
        pending.push(audioData);
        await Preferences.set({ key: 'pendingAudio', value: JSON.stringify(pending) });
      } else {
        const pending = JSON.parse(localStorage.getItem('pendingAudio') || '[]');
        pending.push(audioData);
        localStorage.setItem('pendingAudio', JSON.stringify(pending));
      }
      
      console.log('ğŸ¤ éŸ³é »å·²æš«å­˜ï¼Œç­‰å¾…ä¸Šå‚³:', id);
      return { success: true, id: id };
    } catch (error) {
      console.error('å„²å­˜éŸ³é »å¤±æ•—:', error);
      return { success: false, error: error.message };
    }
  },
  
  // ç²å–å¾…ä¸Šå‚³éŸ³é »
  async getPendingAudio() {
    try {
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingAudio' });
        return value ? JSON.parse(value) : [];
      } else {
        return JSON.parse(localStorage.getItem('pendingAudio') || '[]');
      }
    } catch (error) {
      console.error('è¼‰å…¥å¾…ä¸Šå‚³éŸ³é »å¤±æ•—:', error);
      return [];
    }
  },
  
  // ç§»é™¤å·²è™•ç†çš„éŸ³é »
  async removeProcessedAudio(audioId) {
    try {
      const pending = await this.getPendingAudio();
      const filtered = pending.filter(item => item.id !== audioId);
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        await Preferences.set({ key: 'pendingAudio', value: JSON.stringify(filtered) });
      } else {
        localStorage.setItem('pendingAudio', JSON.stringify(filtered));
      }
      
      console.log('ğŸ—‘ï¸ å·²è™•ç†éŸ³é »å·²ç§»é™¤:', audioId);
    } catch (error) {
      console.error('ç§»é™¤éŸ³é »å¤±æ•—:', error);
    }
  }
};

// === IndexedDB éŸ³é »å„²å­˜ç®¡ç† ===
const AudioDB = {
  dbName: 'LifeMapAudioDB',
  version: 1,
  
  // æª¢æŸ¥ IndexedDB æ”¯æ´
  checkSupport() {
    const supported = !!window.indexedDB;
    console.log('ğŸ” IndexedDB æ”¯æ´ç‹€æ…‹:', supported);
    console.log('ğŸ” ç€è¦½å™¨è³‡è¨Š:', navigator.userAgent);
    
    if (!supported) {
      showToast('âŒ æ­¤ç€è¦½å™¨ä¸æ”¯æ´ IndexedDB', { type: 'error', duration: 5000 });
      return false;
    }
    return true;
  },
  
  // åˆå§‹åŒ– IndexedDB
  async init() {
    console.log('ğŸµ å˜—è©¦åˆå§‹åŒ– IndexedDB...');
    
    if (!this.checkSupport()) {
      throw new Error('IndexedDB ä¸æ”¯æ´');
    }
    
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = (event) => {
        console.error('âŒ IndexedDB åˆå§‹åŒ–å¤±æ•—:', event.target.error);
        showToast('âŒ éŸ³é »è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—', { type: 'error', duration: 5000 });
        reject(request.error);
      };
      
      request.onsuccess = (event) => {
        console.log('âœ… IndexedDB é€£ç·šæˆåŠŸ');
        resolve(request.result);
      };
      
      request.onupgradeneeded = (event) => {
        console.log('ğŸ”„ å‡ç´š IndexedDB çµæ§‹...');
        const db = event.target.result;
        
        try {
          // å‰µå»ºéŒ„éŸ³å„²å­˜è¡¨
          if (!db.objectStoreNames.contains('recordings')) {
            const store = db.createObjectStore('recordings', { 
              keyPath: 'id', 
              autoIncrement: true 
            });
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('type', 'type', { unique: false });
            console.log('âœ… éŒ„éŸ³è³‡æ–™è¡¨å·²å»ºç«‹');
          }
          
          console.log('âœ… IndexedDB éŸ³é »è³‡æ–™åº«å‡ç´šå®Œæˆ');
          showToast('âœ… éŸ³é »è³‡æ–™åº«å·²æº–å‚™å°±ç·’', { type: 'success', duration: 2000 });
        } catch (upgradeError) {
          console.error('âŒ è³‡æ–™åº«å‡ç´šå¤±æ•—:', upgradeError);
          showToast('âŒ è³‡æ–™åº«å‡ç´šå¤±æ•—', { type: 'error', duration: 5000 });
        }
      };
    });
  },
  
  // å„²å­˜éŒ„éŸ³åˆ° IndexedDB
  async saveRecording(audioBlob, metadata = {}) {
    console.log('ğŸ¤ é–‹å§‹å„²å­˜éŒ„éŸ³åˆ° IndexedDB...');
    console.log('ğŸ“Š éŸ³é » Blob è³‡è¨Š:', {
      size: audioBlob.size,
      type: audioBlob.type,
      isBlob: audioBlob instanceof Blob
    });
    
    try {
      const db = await this.init();
      console.log('âœ… è³‡æ–™åº«é€£ç·šæˆåŠŸ');
      
      const transaction = db.transaction(['recordings'], 'readwrite');
      const store = transaction.objectStore('recordings');
      
      const recordingData = {
        timestamp: Date.now(),
        date: new Date().toISOString(),
        audio: audioBlob, // ç›´æ¥å„²å­˜ Blob
        type: audioBlob.type || 'audio/webm',
        size: audioBlob.size,
        duration: metadata.duration || null,
        transcription: metadata.transcription || null,
        location: metadata.location || null,
        latitude: metadata.latitude || null,
        longitude: metadata.longitude || null,
        place_name: metadata.place_name || null,
        memory_id: metadata.memory_id || null,
        source: metadata.source || 'unknown',
        synced: false
      };
      
      console.log('ğŸ“ æº–å‚™å„²å­˜çš„è³‡æ–™:', {
        ...recordingData,
        audio: `[Blob ${audioBlob.size} bytes]`
      });
      
      const request = store.add(recordingData);
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          const recordId = request.result;
          console.log('âœ… éŒ„éŸ³å·²å„²å­˜åˆ° IndexedDB, ID:', recordId);
          showToast(`âœ… éŒ„éŸ³å·²å„²å­˜ (ID: ${recordId})`, { type: 'success', duration: 2000 });
          
          // ğŸ—ºï¸ å¦‚æœæœ‰åœ°ç†ä½ç½®ï¼ŒåŠ åˆ°åœ°åœ–ä¸Š
          if (metadata.latitude && metadata.longitude) {
            addAudioMarkerToMap(recordId, metadata.latitude, metadata.longitude, metadata.place_name);
          }
          
          resolve({ success: true, id: recordId, data: recordingData });
        };
        
        request.onerror = (event) => {
          console.error('âŒ IndexedDB å„²å­˜è«‹æ±‚å¤±æ•—:', event.target.error);
          showToast('âŒ éŒ„éŸ³å„²å­˜å¤±æ•—', { type: 'error', duration: 3000 });
          reject(request.error);
        };
      });
      
    } catch (error) {
      console.error('âŒ IndexedDB å„²å­˜éç¨‹å¤±æ•—:', error);
      showToast(`âŒ å„²å­˜å¤±æ•—: ${error.message}`, { type: 'error', duration: 5000 });
      return { success: false, error: error.message };
    }
  },
  
  // è¼‰å…¥æ‰€æœ‰éŒ„éŸ³
  async loadAllRecordings() {
    try {
      const db = await this.init();
      const transaction = db.transaction(['recordings'], 'readonly');
      const store = transaction.objectStore('recordings');
      const request = store.getAll();
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          console.log('ğŸµ è¼‰å…¥', request.result.length, 'å€‹éŒ„éŸ³');
          resolve(request.result);
        };
        request.onerror = () => reject(request.error);
      });
      
    } catch (error) {
      console.error('è¼‰å…¥éŒ„éŸ³å¤±æ•—:', error);
      return [];
    }
  },
  
  // æ’­æ”¾éŒ„éŸ³
  async playRecording(recordingId) {
    try {
      const db = await this.init();
      const transaction = db.transaction(['recordings'], 'readonly');
      const store = transaction.objectStore('recordings');
      const request = store.get(recordingId);
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          if (request.result) {
            const audioBlob = request.result.audio;
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            audio.onended = () => URL.revokeObjectURL(audioUrl);
            audio.play().then(() => {
              console.log('ğŸ”Š æ’­æ”¾éŒ„éŸ³ ID:', recordingId);
              resolve(audio);
            }).catch(reject);
            
          } else {
            reject(new Error('éŒ„éŸ³ä¸å­˜åœ¨'));
          }
        };
        request.onerror = () => reject(request.error);
      });
      
    } catch (error) {
      console.error('æ’­æ”¾éŒ„éŸ³å¤±æ•—:', error);
      throw error;
    }
  },
  
  // åˆªé™¤éŒ„éŸ³
  async deleteRecording(recordingId) {
    try {
      const db = await this.init();
      const transaction = db.transaction(['recordings'], 'readwrite');
      const store = transaction.objectStore('recordings');
      const request = store.delete(recordingId);
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          console.log('ğŸ—‘ï¸ éŒ„éŸ³å·²åˆªé™¤ ID:', recordingId);
          resolve(true);
        };
        request.onerror = () => reject(request.error);
      });
      
    } catch (error) {
      console.error('åˆªé™¤éŒ„éŸ³å¤±æ•—:', error);
      return false;
    }
  },
  
  // ç²å–å„²å­˜çµ±è¨ˆ
  async getStorageStats() {
    try {
      const recordings = await this.loadAllRecordings();
      const totalSize = recordings.reduce((sum, r) => sum + (r.size || 0), 0);
      const totalCount = recordings.length;
      
      return {
        count: totalCount,
        totalSize: totalSize,
        totalSizeMB: (totalSize / 1024 / 1024).toFixed(2),
        unsyncedCount: recordings.filter(r => !r.synced).length
      };
      
    } catch (error) {
      console.error('ç²å–çµ±è¨ˆå¤±æ•—:', error);
      return { count: 0, totalSize: 0, totalSizeMB: '0', unsyncedCount: 0 };
    }
  }
};

// === è™•ç†å¾…ä¸Šå‚³éŸ³é » ===
async function processPendingAudio() {
  try {
    const pendingAudio = await LocalStorage.getPendingAudio();
    console.log('ğŸµ ç™¼ç¾å¾…è™•ç†éŸ³é »:', pendingAudio.length, 'å€‹');
    
    for (const audioData of pendingAudio) {
      try {
        console.log('ğŸ¤ è™•ç†éŸ³é »:', audioData.id);
        
        // å°‡ base64 è½‰å› Blob
        const audioBlob = await base64ToBlob(audioData.blob, 'audio/wav');
        
        // ä¸Šå‚³åˆ°å¾Œç«¯è™•ç†
        const formData = new FormData();
        formData.append("audio", audioBlob, "recording.wav");
        formData.append("metadata", JSON.stringify(audioData.metadata));
        
        const response = await fetch(`${BACKEND_URL}/api/transcribe`, {
          method: "POST",
          body: formData,
        });

        if (response.ok) {
          const result = await response.json();
          console.log('âœ… éŸ³é »è™•ç†æˆåŠŸ:', result);
          
          // å¦‚æœæœ‰è½‰éŒ„çµæœï¼Œå‰µå»ºè¨˜æ†¶
          if (result.text && result.text.trim()) {
            const memoryData = {
              text: result.text.trim(),
              type: 'audio',
              created_at: audioData.created_at,
              source: 'delayed_processing'
            };
            
            await NetworkManager.syncToBackend(memoryData);
            await LocalStorage.saveMemory(memoryData);
            
            showToast(`ğŸ¤ éŸ³é »å·²è™•ç†ï¼š${result.text.substring(0, 20)}...`, { 
              type: 'success', 
              duration: 3000 
            });
          }
          
          // ç§»é™¤å·²è™•ç†çš„éŸ³é »
          await LocalStorage.removeProcessedAudio(audioData.id);
          
        } else {
          console.error('éŸ³é »è™•ç†å¤±æ•—:', response.status);
        }
        
      } catch (processError) {
        console.error('è™•ç†éŸ³é »æ™‚å‡ºéŒ¯:', audioData.id, processError);
      }
    }
    
  } catch (error) {
    console.error('è™•ç†å¾…ä¸Šå‚³éŸ³é »æ™‚å‡ºéŒ¯:', error);
  }
}

// Base64 è½‰ Blob è¼”åŠ©å‡½æ•¸
function base64ToBlob(base64, mimeType) {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  
  const byteArray = new Uint8Array(byteNumbers);
  return new Blob([byteArray], { type: mimeType });
}

// === åœ°åœ– ===
// ä½¿ç”¨ä¿è­·å¼åˆå§‹åŒ–ï¼Œé¿å…åœ¨é–‹ç™¼æˆ–ç†±é‡è¼‰æœŸé–“é‡è¤‡å»ºç«‹ Leaflet åœ°åœ–
let map;
if (window.__lifeMap && window.__lifeMap instanceof L.Map) {
  console.log('é‡ç”¨å·²å­˜åœ¨çš„ Leaflet map instance');
  map = window.__lifeMap;
} else {
  map = L.map('map', { attributionControl: false }).setView([23.9739, 120.9820], 8);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
  // æš«å­˜æ–¼ window ä»¥ä¾¿æœªä¾†é‡ç”¨ï¼ˆä¾‹å¦‚ç†±é‡è¼‰æˆ–è…³æœ¬è¢«å¤šæ¬¡åŸ·è¡Œï¼‰
  window.__lifeMap = map;
}

// ğŸŒŸ è‡ªè¨‚ marker åœ–ç¤ºï¼ˆå¿…é ˆæ”¾åœ¨æœ€å‰é¢ï¼ï¼‰
const customIcon = L.icon({
  iconUrl: "assets/marker.png",
  iconSize: [30, 30],
  iconAnchor: [22, 44],
  popupAnchor: [0, -40]
});


// === é é¢åˆ‡æ› ===
const views = {
  empty: document.getElementById('char-empty'),
  loading: document.getElementById('char-loading'),
  list: document.getElementById('char-list'),
  chat: document.getElementById('chat-view'),
  map: document.getElementById('map-view')
};
const pageTitle = document.getElementById('pageTitle');
const chatMenu = document.getElementById('chatMenu');

let currentView = "empty";

// åˆ‡æ›ç•«é¢ä¸¦æ›´æ–°æ¨™é¡Œ + ä¸‰é»é¸å–®é¡¯ç¤ºç‹€æ…‹
function switchView(name) {
  currentView = name;
  for (const key in views) {
    views[key].classList.add("hidden");
  }
  views[name].classList.remove("hidden");

  // å‹•æ…‹æ›´æ–°æ¨™é¡Œï¼ˆä¿ç•™ chatMenu åœ¨æ‰€æœ‰é é¢å¯è¦‹ï¼‰
  switch (name) {
    case "empty":
    case "loading":
    case "list":
      pageTitle.textContent = "AIè§’è‰²é¸æ“‡";
      break;
    case "chat":
      pageTitle.textContent = "èŠå¤©å¹³å°";
      break;
    case "map":
      pageTitle.textContent = "ç”Ÿå‘½åœ°åœ–";
      break;
  }

  // åœ°åœ–é‡ç¹ª
  if (name === "map") {
    setTimeout(() => map.invalidateSize(), 200);
    loadMemories();      // âœ… æ¯æ¬¡åˆ‡æ›åœ°åœ–æ™‚è¼‰å…¥å›æ†¶
    renderTimeline();    // âœ… åŒæ­¥ç”Ÿæˆåº•éƒ¨ç¯€é»
  }

  // ç¢ºä¿ä¸‰é»é¸å–®ï¼ˆ#chatMenuï¼‰åœ¨æ‰€æœ‰é é¢éƒ½å¯è¦‹
  try { if (chatMenu) chatMenu.classList.remove('hidden'); } catch (e) {}
}

// è¿”å›é‚è¼¯
function handleBack() {
  if (currentView === "map") {
    switchView("chat");
  } else if (currentView === "chat") {
    // å›åˆ°è§’è‰²åˆ—è¡¨é ï¼ˆè€Œä¸æ˜¯ characterï¼‰
    switchView("list");
  } else if (currentView === "list" || currentView === "loading") {
    switchView("empty");
  } else {
    showToast('ç›®å‰å·²åœ¨æœ€å‰é ', { duration: 1800 });
  }
}

  // === ä¸‰é»é¸å–®é¡¯ç¤º / éš±è— ===
function toggleDropdown(id) {
  const dropdown = document.getElementById(id);
  // å…ˆé—œæ‰å…¶ä»– dropdownï¼ˆé¿å…é‡ç–Šï¼‰
  document.querySelectorAll('.dropdown, [id$="-dropdown"]').forEach(el => {
    if (el !== dropdown) el.classList.add('hidden');
  });
  // åˆ‡æ›ç•¶å‰ dropdown é¡¯ç¤º
  dropdown.classList.toggle('hidden');
}
// é–‹é—œåˆ†äº«è¦–çª— - å¼·ç¡¬åŒ–ç‰ˆæœ¬
function openShareModal() {
  try {
    console.log('openShareModal: attempting to show share modal');
    const el = document.getElementById("shareModal");
    if (!el) {
      console.error('openShareModal: shareModal element not found in DOM');
      return;
    }

    // å¼·åˆ¶ç§»å‹•åˆ° body æœ€å¾Œï¼ˆç¢ºä¿ä¸è¢«å…¶ä»–å®¹å™¨é™åˆ¶ï¼‰
    if (el.parentElement !== document.body) {
      document.body.appendChild(el);
      console.log('openShareModal: moved shareModal to document.body');
    }

    // å¼·ç¡¬è¨­å®šæ‰€æœ‰å¿…è¦å±¬æ€§
    el.classList.remove("hidden");
    el.style.display = 'flex';
    el.style.position = 'fixed';
    el.style.top = '0';
    el.style.left = '0';
    el.style.width = '100%';
    el.style.height = '100%';
    el.style.zIndex = '2147483647'; // æœ€é«˜ z-index
    el.style.pointerEvents = 'auto';
    el.style.opacity = '1';
    el.style.visibility = 'visible';
    el.style.background = 'rgba(0, 0, 0, 0.4)';
    el.style.alignItems = 'center';
    el.style.justifyContent = 'center';

    // ç¢ºä¿å…§éƒ¨ modal å…§å®¹åœ¨æ‰‹æ©Ÿä¸Šå¯è¦‹
    const modalContent = el.querySelector('div');
    if (modalContent) {
      modalContent.style.maxWidth = '90vw';
      modalContent.style.maxHeight = '90vh';
      modalContent.style.overflow = 'auto';
      modalContent.style.margin = '0 16px';
    }

    // æš«æ™‚ç¦ç”¨å…¶ä»–é«˜å±¤ç´šå…ƒç´ çš„äº’å‹•ï¼ˆé˜²æ­¢è¢«é®æ“‹ï¼‰
    const highZElements = document.querySelectorAll('[style*="z-index"]');
    highZElements.forEach(elem => {
      if (elem !== el && elem.style.zIndex && parseInt(elem.style.zIndex) > 10000) {
        elem.setAttribute('data-temp-pointer-events', elem.style.pointerEvents || 'auto');
        elem.style.pointerEvents = 'none';
      }
    });

    console.log('openShareModal: modal should now be visible with highest z-index and responsive design');
  } catch (e) { 
    console.error('openShareModal failed', e); 
  }
}

function closeShareModal() {
  try {
    const el = document.getElementById("shareModal");
    if (!el) return;
    
    el.classList.add("hidden");
    el.style.display = 'none';
    
    // æ¢å¾©å…¶ä»–å…ƒç´ çš„ pointer-events
    const tempElements = document.querySelectorAll('[data-temp-pointer-events]');
    tempElements.forEach(elem => {
      elem.style.pointerEvents = elem.getAttribute('data-temp-pointer-events');
      elem.removeAttribute('data-temp-pointer-events');
    });
    
    console.log('closeShareModal: modal hidden and restored other elements');
  } catch (e) { 
    console.error('closeShareModal failed', e); 
  }
}

// åˆ†äº«åŠŸèƒ½
function shareToFacebook() {
  const url = encodeURIComponent(window.location.href);
  const fbURL = `https://www.facebook.com/sharer/sharer.php?u=${url}`;
  window.open(fbURL, "_blank", "width=600,height=500");
}

function shareToLine() {
  const url = encodeURIComponent(window.location.href);
  const text = encodeURIComponent("å’Œæˆ‘ä¸€èµ·é«”é©—é€™å€‹ AI äº’å‹•å§ï¼");
  const lineURL = `https://social-plugins.line.me/lineit/share?url=${url}&text=${text}`;
  window.open(lineURL, "_blank", "width=600,height=500");
}

function copyLink() {
  const url = window.location.href;
  navigator.clipboard.writeText(url).then(() => {
    showToast('âœ”ï¸ å·²è¤‡è£½é€£çµåˆ°å‰ªè²¼ç°¿ï¼', { type: 'success' });
  }).catch(err => {
    showToast('âŒ è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½ã€‚', { type: 'error' });
    console.error(err);
  });
}

// é€šç”¨çš„ç°¡å–®æç¤º modalï¼ˆå ä½ï¼‰
function showModal(message) {
  // è‹¥æœªå®šç¾©è©³ç´° modalï¼Œä½¿ç”¨ alert ä½œç‚ºå›é€€
  try {
    // è‹¥æœªä¾†è¦åšæ›´æ¼‚äº®çš„ modalï¼Œå¯åœ¨æ‰‹æ©Ÿæ¡†å…§é¡¯ç¤º toast
    showToast(message, { duration: 2500 });
  } catch (e) {
    console.log('showModal:', message);
  }
}


// è‹¥é»æ“Šå¤–éƒ¨å€åŸŸï¼Œå‰‡è‡ªå‹•é—œé–‰ä¸‹æ‹‰é¸å–®
window.addEventListener('click', function (e) {
  const menuBtn = e.target.closest('button[onclick^="toggleDropdown"]');
  const dropdown = e.target.closest('.dropdown, [id$="-dropdown"]');
  if (!menuBtn && !dropdown) {
    document.querySelectorAll('.dropdown, [id$="-dropdown"]').forEach(el => el.classList.add('hidden'));
  }
});

// ======= Toast (åœ¨æ‰‹æ©Ÿæ¡†å…§é¡¯ç¤ºéé˜»å¡æç¤º) =======
function showToast(message, opts = {}) {
  const container = document.getElementById('toast-container');
  if (!container) return;
  const id = `toast-${Date.now()}`;
  const type = opts.type || 'info';
  const duration = opts.duration || 3000;

  const el = document.createElement('div');
  el.id = id;
  el.className = 'px-4 py-2 rounded-lg text-sm shadow-md mb-2 text-white';
  el.style.transition = 'opacity 200ms ease, transform 200ms ease';
  el.style.opacity = '0';
  el.style.transform = 'translateY(-6px)';

  if (type === 'success') el.style.background = '#16a34a';
  else if (type === 'error') el.style.background = '#dc2626';
  else el.style.background = '#374151';

  el.innerText = message;
  container.appendChild(el);
  container.classList.remove('hidden');

  // animate in
  requestAnimationFrame(() => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });

  setTimeout(() => {
    // animate out
    el.style.opacity = '0'; el.style.transform = 'translateY(-6px)';
    setTimeout(() => { try { container.removeChild(el); } catch (e) {} }, 250);
  }, duration);
}


  // é—œé–‰æŒ‰éˆ•
  function handleClose() {
    if (confirm("ç¢ºå®šè¦é—œé–‰å—ï¼Ÿ")) window.close();
  }

    // === æ¨¡æ“¬è§’è‰²ç”Ÿæˆ ===
    const charAuto=document.getElementById('charAuto');
    const cardGrid=document.getElementById('cardGrid');
    charAuto.onclick=()=>{switchView('loading');setTimeout(()=>{renderCharacterCards();switchView('list');},2000);};

    const demoCharacters=[
      {name:"é˜¿é’",img:"assets/char1.png"},
      {name:"é˜¿ç¦",img:"assets/char2.png"},
      {name:"å°å…‰",img:"assets/char3.png"},
      {name:"å°ç¶ ",img:"assets/char4.png"},
      {name:"å…ƒæ°£å›",img:"assets/char5.png"},
      {name:"æš–æš–",img:"assets/char6.png"},
      {name:"é˜¿å“²",img:"assets/char7.png"},
      {name:"å°å¤",img:"assets/char8.png"},
      {name:"é˜¿å‹‡",img:"assets/char9.png"}
    ];

    function renderCharacterCards(){
      cardGrid.innerHTML='';
      demoCharacters.forEach(c=>{
        const el=document.createElement('div');
        el.className='card';
        el.innerHTML=`<img src="${c.img}" alt="${c.name}">
                      <div class="pt-1 text-center font-bold text-sm">${c.name}</div>`;
        el.onclick=()=>selectCharacter(c);
        cardGrid.appendChild(el);
      });
    }
  function selectCharacter(c) {
    const chatAvatar = document.getElementById("chat-avatar");
    const chatBox = document.getElementById("chat-box");

    // æ›´æ–°é ­åƒèˆ‡å°è©±æ–‡å­—
    chatAvatar.src = c.img;
    chatBox.innerHTML = `
      <div class="text-gray-800 font-semibold text-lg">
        å—¨ï¼æˆ‘æ˜¯ ${c.name} ï½ ä¸€èµ·èŠèŠå§ï¼
      </div>
    `;

    // åˆ‡æ›åˆ°èŠå¤©é 
    switchView("chat");
  }

  // === è‡ªå®šç¾©è§’è‰²ä¸Šå‚³åŠŸèƒ½ ===
  const btnUploadCustomChar = document.getElementById('btnUploadCustomChar');
  
  // å„²å­˜è‡ªå®šç¾©è§’è‰²åˆ°æœ¬åœ°
  async function saveCustomCharacter(imagePath, characterName) {
    try {
      if (window.Capacitor && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        
        // ç²å–ç¾æœ‰è‡ªå®šç¾©è§’è‰²åˆ—è¡¨
        const { value } = await Preferences.get({ key: 'customCharacters' });
        const customChars = value ? JSON.parse(value) : [];
        
        // æ·»åŠ æ–°è§’è‰²
        const newChar = {
          name: characterName,
          img: imagePath,
          isCustom: true
        };
        customChars.push(newChar);
        
        // å„²å­˜å›æœ¬åœ°
        await Preferences.set({
          key: 'customCharacters',
          value: JSON.stringify(customChars)
        });
        
        return newChar;
      }
    } catch (error) {
      console.error('å„²å­˜è‡ªå®šç¾©è§’è‰²å¤±æ•—:', error);
    }
    return null;
  }
  
  // è¼‰å…¥è‡ªå®šç¾©è§’è‰²
  async function loadCustomCharacters() {
    try {
      if (window.Capacitor && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'customCharacters' });
        return value ? JSON.parse(value) : [];
      }
    } catch (error) {
      console.error('è¼‰å…¥è‡ªå®šç¾©è§’è‰²å¤±æ•—:', error);
    }
    return [];
  }
  
  // ä¸Šå‚³è‡ªå®šç¾©è§’è‰²
  async function handleCustomCharacterUpload() {
    try {
      if (!window.Capacitor || !window.Capacitor.Plugins.Camera) {
        alert('æ­¤åŠŸèƒ½éœ€è¦åœ¨æ‰‹æ©Ÿ APP ä¸­ä½¿ç”¨');
        return;
      }
      
      const { Camera } = window.Capacitor.Plugins;
      const { Filesystem } = window.Capacitor.Plugins;
      
      // é¡¯ç¤ºé¸æ“‡ä¾†æºçš„å°è©±æ¡†
      const source = await new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:10000;display:flex;align-items:center;justify-content:center;';
        modal.innerHTML = `
          <div style="background:white;padding:20px;border-radius:10px;text-align:center;max-width:300px;margin:20px;">
            <h3 style="margin-bottom:20px;color:#333;">é¸æ“‡åœ–ç‰‡ä¾†æº</h3>
            <button id="cameraBtn" style="width:100%;padding:12px;margin:5px 0;background:#007AFF;color:white;border:none;border-radius:8px;font-size:16px;">ğŸ“· æ‹ç…§</button>
            <button id="galleryBtn" style="width:100%;padding:12px;margin:5px 0;background:#34C759;color:white;border:none;border-radius:8px;font-size:16px;">ğŸ–¼ï¸ ç›¸ç°¿</button>
            <button id="cancelBtn" style="width:100%;padding:12px;margin:5px 0;background:#FF3B30;color:white;border:none;border-radius:8px;font-size:16px;">âŒ å–æ¶ˆ</button>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        modal.querySelector('#cameraBtn').onclick = () => {
          document.body.removeChild(modal);
          resolve('camera');
        };
        modal.querySelector('#galleryBtn').onclick = () => {
          document.body.removeChild(modal);
          resolve('gallery');
        };
        modal.querySelector('#cancelBtn').onclick = () => {
          document.body.removeChild(modal);
          resolve(null);
        };
      });
      
      if (!source) return;
      
      // æ‹ç…§æˆ–å¾ç›¸ç°¿é¸æ“‡
      const image = await Camera.getPhoto({
        quality: 80,
        allowEditing: true,
        resultType: 'uri',
        source: source === 'camera' ? 'camera' : 'photos'
      });
      
      // è©¢å•è§’è‰²åç¨±
      const characterName = prompt('è«‹è¼¸å…¥è§’è‰²åç¨±:', 'æˆ‘çš„è§’è‰²') || 'æˆ‘çš„è§’è‰²';
      
      // å„²å­˜åœ–ç‰‡åˆ° APP å…§éƒ¨ç›®éŒ„
      const fileName = `custom_char_${Date.now()}.jpg`;
      const savedFile = await Filesystem.copy({
        from: image.webPath,
        to: fileName,
        directory: 'data'
      });
      
      // å„²å­˜è§’è‰²è³‡è¨Š
      const customChar = await saveCustomCharacter(savedFile.uri, characterName);
      
      if (customChar) {
        // é‡æ–°æ¸²æŸ“è§’è‰²å¡ç‰‡ï¼ˆåŒ…å«è‡ªå®šç¾©è§’è‰²ï¼‰
        await renderAllCharacterCards();
        alert(`æˆåŠŸæ·»åŠ è‡ªå®šç¾©è§’è‰²: ${characterName}`);
      }
      
    } catch (error) {
      console.error('ä¸Šå‚³è‡ªå®šç¾©è§’è‰²å¤±æ•—:', error);
      alert('ä¸Šå‚³å¤±æ•—ï¼Œè«‹é‡è©¦');
    }
  }
  
  // ä¿®æ”¹è§’è‰²å¡ç‰‡æ¸²æŸ“å‡½æ•¸ï¼ŒåŒ…å«è‡ªå®šç¾©è§’è‰²
  async function renderAllCharacterCards() {
    cardGrid.innerHTML = '';
    
    // æ¸²æŸ“é è¨­è§’è‰²
    demoCharacters.forEach(c => {
      const el = document.createElement('div');
      el.className = 'card';
      el.innerHTML = `<img src="${c.img}" alt="${c.name}">
                      <div class="pt-1 text-center font-bold text-sm">${c.name}</div>`;
      el.onclick = () => selectCharacter(c);
      cardGrid.appendChild(el);
    });
    
    // æ¸²æŸ“è‡ªå®šç¾©è§’è‰²
    const customChars = await loadCustomCharacters();
    customChars.forEach(c => {
      const el = document.createElement('div');
      el.className = 'card relative';
      el.innerHTML = `<img src="${c.img}" alt="${c.name}">
                      <div class="pt-1 text-center font-bold text-sm">${c.name}</div>
                      <div class="absolute top-1 right-1 bg-purple-500 text-white text-xs px-1 rounded">è‡ªå®šç¾©</div>`;
      el.onclick = () => selectCharacter(c);
      cardGrid.appendChild(el);
    });
  }
  
  // ç¶å®šä¸Šå‚³æŒ‰éˆ•äº‹ä»¶
  if (btnUploadCustomChar) {
    btnUploadCustomChar.onclick = handleCustomCharacterUpload;
  }
  
  // ä¿®æ”¹åŸæœ¬çš„ renderCharacterCards å‡½æ•¸
  function renderCharacterCards() {
    renderAllCharacterCards();
  }



// === éŒ„éŸ³åŠŸèƒ½ï¼šçµæœå¡«å…¥è¼¸å…¥æ¡† ===

const recordBtn = document.getElementById("recordBtn");
const charPrompt = document.getElementById("charPrompt");

let mediaRecorder, audioChunks = [], isRecording = false;

// éŒ„éŸ³èª¿è©¦åŠŸèƒ½
function logRecordingEnvironment() {
  console.log('ğŸ” éŒ„éŸ³ç’°å¢ƒæª¢æ¸¬:');
  console.log('- User Agent:', navigator.userAgent);
  console.log('- Platform:', navigator.platform);
  console.log('- MediaDevices æ”¯æ´:', !!navigator.mediaDevices);
  console.log('- getUserMedia æ”¯æ´:', !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia));
  console.log('- MediaRecorder æ”¯æ´:', typeof MediaRecorder !== 'undefined');
  console.log('- æ˜¯å¦ç‚º HTTPS:', location.protocol === 'https:');
  console.log('- æ˜¯å¦ç‚º localhost:', location.hostname === 'localhost' || location.hostname === '127.0.0.1');
  console.log('- ç•¶å‰ URL:', location.href);
  console.log('- ç€è¦½å™¨èªè¨€:', navigator.language);
  console.log('- æ˜¯å¦ç‚ºç§»å‹•è¨­å‚™:', /Mobi|Android/i.test(navigator.userAgent));
  
  // æª¢æŸ¥æ˜¯å¦åœ¨ Capacitor ç’°å¢ƒä¸­
  console.log('- Capacitor ç’°å¢ƒ:', typeof window.Capacitor !== 'undefined');
  if (typeof window.Capacitor !== 'undefined') {
    console.log('- Capacitor å¹³å°:', window.Capacitor.getPlatform());
    console.log('- Capacitor æ˜¯å¦ç‚ºåŸç”Ÿ:', window.Capacitor.isNativePlatform());
  }
  
  if (typeof MediaRecorder !== 'undefined') {
    console.log('- æ”¯æ´çš„éŸ³é »æ ¼å¼:', {
      webm: MediaRecorder.isTypeSupported('audio/webm'),
      'webm;codecs=opus': MediaRecorder.isTypeSupported('audio/webm;codecs=opus'),
      mp4: MediaRecorder.isTypeSupported('audio/mp4'),
      'mp4;codecs=mp4a.40.2': MediaRecorder.isTypeSupported('audio/mp4;codecs=mp4a.40.2'),
      ogg: MediaRecorder.isTypeSupported('audio/ogg'),
      wav: MediaRecorder.isTypeSupported('audio/wav')
    });
  }
  
  // æª¢æŸ¥åª’é«”è¨­å‚™ç‹€æ…‹
  if (navigator.mediaDevices) {
    navigator.mediaDevices.enumerateDevices()
      .then(devices => {
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        console.log('- å¯ç”¨éŸ³é »è¼¸å…¥è¨­å‚™æ•¸é‡:', audioInputs.length);
        audioInputs.forEach((device, index) => {
          console.log(`  è¨­å‚™ ${index + 1}:`, {
            deviceId: device.deviceId,
            label: device.label || 'æœªçŸ¥è¨­å‚™',
            groupId: device.groupId
          });
        });
      })
      .catch(err => {
        console.log('- ç„¡æ³•æšèˆ‰åª’é«”è¨­å‚™:', err.message);
      });
  }
}

// éŒ„éŸ³è¨ºæ–·åŠŸèƒ½
async function runRecordingDiagnostic() {
  console.log('ğŸ¥ é–‹å§‹éŒ„éŸ³ç³»çµ±è¨ºæ–·...');
  
  const results = {
    environment: 'unknown',
    microphone: 'unknown',
    recorder: 'unknown',
    database: 'unknown',
    permissions: 'unknown'
  };
  
  try {
    // 1. ç’°å¢ƒæª¢æ¸¬
    logRecordingEnvironment();
    results.environment = 'ok';
    
    // 2. éº¥å…‹é¢¨æ¬Šé™æª¢æ¸¬
    console.log('ğŸ¤ æª¢æ¸¬éº¥å…‹é¢¨æ¬Šé™...');
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      console.log('âœ… éº¥å…‹é¢¨æ¬Šé™ç²å¾—æˆåŠŸ');
      results.microphone = 'ok';
      results.permissions = 'granted';
      
      // 3. MediaRecorder æª¢æ¸¬
      console.log('ğŸ›ï¸ æª¢æ¸¬ MediaRecorder...');
      if (typeof MediaRecorder !== 'undefined') {
        const recorder = new MediaRecorder(stream);
        console.log('âœ… MediaRecorder å»ºç«‹æˆåŠŸ, ç‹€æ…‹:', recorder.state);
        results.recorder = 'ok';
        
        // æ¸¬è©¦éŒ„éŸ³
        let testChunks = [];
        recorder.ondataavailable = e => testChunks.push(e.data);
        recorder.onstop = () => {
          const testBlob = new Blob(testChunks, { type: 'audio/webm' });
          console.log('ğŸ§ª æ¸¬è©¦éŒ„éŸ³å®Œæˆ, å¤§å°:', testBlob.size, 'bytes');
          
          if (testBlob.size > 0) {
            console.log('âœ… éŒ„éŸ³åŠŸèƒ½æ­£å¸¸');
          } else {
            console.log('âŒ éŒ„éŸ³æ²’æœ‰æ•¸æ“š');
          }
        };
        
        recorder.start();
        setTimeout(() => {
          recorder.stop();
        }, 1000);
        
      } else {
        console.log('âŒ MediaRecorder ä¸æ”¯æ´');
        results.recorder = 'not_supported';
      }
      
      // é‡‹æ”¾æ¸¬è©¦æµ
      stream.getTracks().forEach(track => track.stop());
      
    } catch (micError) {
      console.log('âŒ éº¥å…‹é¢¨æ¬Šé™å¤±æ•—:', micError);
      results.microphone = 'failed';
      results.permissions = micError.name || 'denied';
    }
    
    // 4. IndexedDB æª¢æ¸¬
    console.log('ğŸ’¾ æª¢æ¸¬ IndexedDB...');
    try {
      await AudioDB.init();
      console.log('âœ… IndexedDB é€£ç·šæˆåŠŸ');
      results.database = 'ok';
    } catch (dbError) {
      console.log('âŒ IndexedDB é€£ç·šå¤±æ•—:', dbError);
      results.database = 'failed';
    }
    
  } catch (error) {
    console.error('âŒ è¨ºæ–·éç¨‹ç™¼ç”ŸéŒ¯èª¤:', error);
  }
  
  console.log('ğŸ¥ è¨ºæ–·çµæœ:', results);
  
  // é¡¯ç¤ºè¨ºæ–·çµæœ
  const statusText = `
    ğŸ” éŒ„éŸ³ç³»çµ±è¨ºæ–·å ±å‘Š:
    - ç’°å¢ƒ: ${results.environment}
    - éº¥å…‹é¢¨: ${results.microphone}
    - éŒ„éŸ³å™¨: ${results.recorder}
    - è³‡æ–™åº«: ${results.database}
    - æ¬Šé™: ${results.permissions}
  `;
  
  showToast(statusText, { type: 'info', duration: 8000 });
  
  return results;
}

recordBtn.onclick = async () => {
  if (!isRecording) {
    console.log('ğŸ¤ é–‹å§‹éŒ„éŸ³æµç¨‹...');
    logRecordingEnvironment();
    
    try {
      console.log('ğŸ“± è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...');
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });
      
      console.log('âœ… éº¥å…‹é¢¨æ¬Šé™å·²ç²å¾—, éŸ³è»Œæ•¸é‡:', stream.getAudioTracks().length);
      console.log('ğŸµ éŸ³è»Œè³‡è¨Š:', stream.getAudioTracks().map(track => ({
        label: track.label,
        enabled: track.enabled,
        muted: track.muted,
        readyState: track.readyState,
        settings: track.getSettings()
      })));
      
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      console.log('ğŸ¤ MediaRecorder å·²å»ºç«‹, ç‹€æ…‹:', mediaRecorder.state);

      mediaRecorder.ondataavailable = (e) => {
        console.log('ğŸ“Š æ”¶åˆ°éŸ³é »æ•¸æ“š:', e.data.size, 'bytes');
        audioChunks.push(e.data);
      };
      
      mediaRecorder.onstop = async () => {
        console.log('ğŸ›‘ éŒ„éŸ³åœæ­¢, ç¸½æ•¸æ“šå¡Š:', audioChunks.length);
        console.log('ğŸ“Š æ•¸æ“šå¡Šå¤§å°:', audioChunks.map(chunk => chunk.size));
        
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        console.log('ğŸµ éŸ³é » Blob å·²å»ºç«‹:', audioBlob.size, 'bytes');
        
        charPrompt.value = "ï¼ˆèªéŸ³è¾¨è­˜ä¸­...ï¼‰";

        // ğŸ“ å˜—è©¦ç²å–ç•¶å‰ä½ç½®
        let locationData = {};
        try {
          console.log('ğŸ“ å˜—è©¦ç²å–åœ°ç†ä½ç½®...');
          const position = await getCurrentLocation();
          locationData = {
            latitude: position.latitude,
            longitude: position.longitude,
            accuracy: position.accuracy,
            place_name: `å°è©±ä½ç½® (${position.latitude.toFixed(6)}, ${position.longitude.toFixed(6)})`
          };
          console.log('âœ… ç²å¾—åœ°ç†ä½ç½®:', locationData);
        } catch (locationError) {
          console.warn('âš ï¸ ç„¡æ³•ç²å–åœ°ç†ä½ç½®:', locationError.message);
          locationData = {
            latitude: null,
            longitude: null,
            place_name: 'æœªçŸ¥ä½ç½®'
          };
        }

        // ğŸ¤ å„²å­˜éŒ„éŸ³åˆ° IndexedDB å’Œé›²ç«¯
        try {
          console.log('ğŸ’¾ é–‹å§‹å„²å­˜éŒ„éŸ³åˆ° IndexedDB...');
          const saveResult = await AudioDB.saveRecording(audioBlob, {
            source: 'character_page',
            timestamp: Date.now(),
            duration: audioBlob.size > 0 ? 'recorded' : 'empty',
            ...locationData
          });
          console.log('âœ… éŒ„éŸ³å·²å„²å­˜åˆ° IndexedDB:', saveResult);
          
          // ğŸŒ åŒæ­¥åˆ°é›²ç«¯ MongoDBï¼ˆå¦‚æœåœ¨ç·šï¼‰
          try {
            if (NetworkManager.isOnline()) {
              console.log('â˜ï¸ å˜—è©¦åŒæ­¥éŒ„éŸ³åˆ°é›²ç«¯...');
              await syncAudioToCloud(audioBlob, {
                ...locationData,
                source: 'character_page',
                transcription: result && result.trim() ? result : null
              });
            }
          } catch (cloudError) {
            console.warn('âš ï¸ é›²ç«¯åŒæ­¥å¤±æ•—ï¼ŒéŒ„éŸ³å·²ä¿å­˜åœ¨æœ¬åœ°:', cloudError.message);
          }
          
        } catch (dbError) {
          console.error('âŒ IndexedDB å„²å­˜å¤±æ•—:', dbError);
          showToast(`âŒ éŒ„éŸ³å„²å­˜å¤±æ•—: ${dbError.message}`, { type: 'error', duration: 5000 });
        }

        try {
          console.log('ğŸ”¤ é–‹å§‹èªéŸ³è¾¨è­˜...');
          const result = await transcribeAudio(audioBlob);
          console.log('ğŸ“ è¾¨è­˜çµæœ:', result);
          // é¡¯ç¤ºè¾¨è­˜çµæœæ–¼è¼¸å…¥æ¡†
          charPrompt.value = result && result.trim() ? result : "è«‹æ”¹ç”¨æ–‡å­—è¼¸å…¥";
        } catch (error) {
          console.error('âŒ èªéŸ³è¾¨è­˜éŒ¯èª¤:', error);
          charPrompt.value = "èªéŸ³è¾¨è­˜å¤±æ•—ï¼Œè«‹æ”¹ç”¨æ–‡å­—è¼¸å…¥";
          showToast(`âŒ èªéŸ³è¾¨è­˜å¤±æ•—: ${error.message}`, { type: 'error', duration: 3000 });
        }
        
        // é‡‹æ”¾åª’é«”æµ
        console.log('ğŸ”’ é‡‹æ”¾åª’é«”æµ...');
        const tracks = stream.getTracks();
        tracks.forEach(track => {
          console.log('ğŸ›‘ åœæ­¢éŸ³è»Œ:', track.label);
          track.stop();
        });
      };

      mediaRecorder.onerror = (event) => {
        console.error('âŒ MediaRecorder éŒ¯èª¤:', event.error);
        showToast(`âŒ éŒ„éŸ³å™¨éŒ¯èª¤: ${event.error}`, { type: 'error', duration: 5000 });
      };

      mediaRecorder.start();
      console.log('ğŸŸ¢ é–‹å§‹éŒ„éŸ³, MediaRecorder ç‹€æ…‹:', mediaRecorder.state);
      recordBtn.classList.add("is-recording");
      recordBtn.textContent = "ğŸŸ¥ åœæ­¢";
      isRecording = true;
      
      showToast('ğŸ¤ é–‹å§‹éŒ„éŸ³...', { type: 'info', duration: 1000 });
      
    } catch (err) {
      console.error('âŒ éº¥å…‹é¢¨å­˜å–éŒ¯èª¤:', err);
      
      let errorMessage = 'âŒ ç„¡æ³•å•Ÿç”¨éº¥å…‹é¢¨';
      let detailedError = '';
      
      console.log('ğŸ” éŒ¯èª¤è©³æƒ…:', {
        name: err.name,
        message: err.message,
        stack: err.stack
      });

      if (err.name === 'NotFoundError') {
        errorMessage = 'âŒ æ‰¾ä¸åˆ°éº¥å…‹é¢¨è¨­å‚™';
        detailedError = 'è«‹ç¢ºèªæ‚¨çš„é›»è…¦æˆ–æ‰‹æ©Ÿå·²é€£æ¥ä¸”å•Ÿç”¨éº¥å…‹é¢¨ã€‚';
      } else if (err.name === 'NotAllowedError') {
        errorMessage = 'âŒ éº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•ï¼Œè«‹åœ¨ç€è¦½å™¨è¨­å®šä¸­å…è¨±';
        detailedError = 'æ‚¨éœ€è¦å…è¨±ç¶²ç«™å­˜å–éº¥å…‹é¢¨æ‰èƒ½ä½¿ç”¨éŒ„éŸ³åŠŸèƒ½ã€‚';
      } else if (err.name === 'NotSupportedError') {
        errorMessage = 'âŒ ç€è¦½å™¨ä¸æ”¯æ´éŒ„éŸ³åŠŸèƒ½';
        detailedError = 'æ‚¨çš„ç€è¦½å™¨ç‰ˆæœ¬éèˆŠæˆ–ä¸æ”¯æ´æ­¤åŠŸèƒ½ã€‚';
      } else if (err.name === 'NotReadableError') {
        errorMessage = 'âŒ éº¥å…‹é¢¨è¢«å…¶ä»–æ‡‰ç”¨ç¨‹å¼ä½”ç”¨';
        detailedError = 'è«‹é—œé–‰å…¶ä»–å¯èƒ½æ­£åœ¨ä½¿ç”¨éº¥å…‹é¢¨çš„æ‡‰ç”¨ç¨‹å¼å¾Œå†è©¦ã€‚';
      } else {
        detailedError = err.message || 'æœªçŸ¥éŒ¯èª¤';
      }
      
      // é¡¯ç¤ºæ›´è©³ç´°çš„éŒ¯èª¤è¨Šæ¯
      showToast(`${errorMessage} (${detailedError})`, { type: 'error', duration: 6000 });
    }
  } else {
    mediaRecorder.stop();
    recordBtn.classList.remove("is-recording");
    recordBtn.textContent = "ğŸ¤  éŒ„éŸ³";
    isRecording = false;
  }
};
// === å…±ç”¨éŒ„éŸ³åŠŸèƒ½ ===
function setupRecorder(buttonId, targetTextareaId) {
  const btn = document.getElementById(buttonId);
  const target = document.getElementById(targetTextareaId);
  let mediaRecorder, audioChunks = [], isRecording = false;

  btn.onclick = async () => {
    if (!isRecording) {
      console.log('ğŸ¤ [å…±ç”¨éŒ„éŸ³] é–‹å§‹éŒ„éŸ³æµç¨‹...', buttonId);
      logRecordingEnvironment();
      
      try {
        console.log('ğŸ“± [å…±ç”¨éŒ„éŸ³] è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...');
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        console.log('âœ… [å…±ç”¨éŒ„éŸ³] éº¥å…‹é¢¨æ¬Šé™å·²ç²å¾—, éŸ³è»Œæ•¸é‡:', stream.getAudioTracks().length);
        console.log('ğŸµ [å…±ç”¨éŒ„éŸ³] éŸ³è»Œè³‡è¨Š:', stream.getAudioTracks().map(track => ({
          label: track.label,
          enabled: track.enabled,
          muted: track.muted,
          readyState: track.readyState,
          settings: track.getSettings()
        })));
        
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        console.log('ğŸ¤ [å…±ç”¨éŒ„éŸ³] MediaRecorder å·²å»ºç«‹, ç‹€æ…‹:', mediaRecorder.state);

        mediaRecorder.ondataavailable = (e) => {
          console.log('ğŸ“Š [å…±ç”¨éŒ„éŸ³] æ”¶åˆ°éŸ³é »æ•¸æ“š:', e.data.size, 'bytes');
          audioChunks.push(e.data);
        };
        mediaRecorder.onstop = async () => {
          console.log('ğŸ›‘ [å…±ç”¨éŒ„éŸ³] éŒ„éŸ³åœæ­¢, ç¸½æ•¸æ“šå¡Š:', audioChunks.length);
          console.log('ğŸ“Š [å…±ç”¨éŒ„éŸ³] æ•¸æ“šå¡Šå¤§å°:', audioChunks.map(chunk => chunk.size));
          
          target.value = "ï¼ˆèªéŸ³è¾¨è­˜ä¸­...ï¼‰";
          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
          console.log('ğŸµ [å…±ç”¨éŒ„éŸ³] éŸ³é » Blob å·²å»ºç«‹:', audioBlob.size, 'bytes');
          
          // ğŸ“ å˜—è©¦ç²å–ç•¶å‰ä½ç½®
          let locationData = {};
          try {
            console.log('ğŸ“ [å…±ç”¨éŒ„éŸ³] å˜—è©¦ç²å–åœ°ç†ä½ç½®...');
            const position = await getCurrentLocation();
            locationData = {
              latitude: position.latitude,
              longitude: position.longitude,
              accuracy: position.accuracy,
              place_name: `ä½ç½® (${position.latitude.toFixed(6)}, ${position.longitude.toFixed(6)})`
            };
            console.log('âœ… [å…±ç”¨éŒ„éŸ³] ç²å¾—åœ°ç†ä½ç½®:', locationData);
          } catch (locationError) {
            console.warn('âš ï¸ [å…±ç”¨éŒ„éŸ³] ç„¡æ³•ç²å–åœ°ç†ä½ç½®:', locationError.message);
            locationData = {
              latitude: null,
              longitude: null,
              place_name: 'æœªçŸ¥ä½ç½®'
            };
          }
          
          // ğŸ¤ å„²å­˜éŒ„éŸ³åˆ° IndexedDB å’Œé›²ç«¯
          try {
            console.log('ğŸ’¾ [å…±ç”¨éŒ„éŸ³] é–‹å§‹å„²å­˜éŒ„éŸ³åˆ° IndexedDB...');
            const saveResult = await AudioDB.saveRecording(audioBlob, {
              source: targetTextareaId,
              timestamp: Date.now(),
              duration: audioBlob.size > 0 ? 'recorded' : 'empty',
              ...locationData
            });
            console.log('âœ… [å…±ç”¨éŒ„éŸ³] éŒ„éŸ³å·²å„²å­˜åˆ° IndexedDB:', saveResult);
            
            // ğŸŒ åŒæ­¥åˆ°é›²ç«¯ MongoDBï¼ˆå¦‚æœåœ¨ç·šï¼‰
            try {
              if (NetworkManager.isOnline()) {
                console.log('â˜ï¸ [å…±ç”¨éŒ„éŸ³] å˜—è©¦åŒæ­¥éŒ„éŸ³åˆ°é›²ç«¯...');
                await syncAudioToCloud(audioBlob, {
                  ...locationData,
                  source: targetTextareaId,
                  transcription: text && text.trim() ? text : null
                });
              }
            } catch (cloudError) {
              console.warn('âš ï¸ [å…±ç”¨éŒ„éŸ³] é›²ç«¯åŒæ­¥å¤±æ•—ï¼ŒéŒ„éŸ³å·²ä¿å­˜åœ¨æœ¬åœ°:', cloudError.message);
            }
            
          } catch (dbError) {
            console.error('âŒ [å…±ç”¨éŒ„éŸ³] IndexedDB å„²å­˜å¤±æ•—:', dbError);
            showToast(`âŒ éŒ„éŸ³å„²å­˜å¤±æ•—: ${dbError.message}`, { type: 'error', duration: 5000 });
          }
          
          try {
            console.log('ğŸ”¤ [å…±ç”¨éŒ„éŸ³] é–‹å§‹èªéŸ³è¾¨è­˜...');
            const text = await transcribeAudio(audioBlob);
            console.log('ğŸ“ [å…±ç”¨éŒ„éŸ³] è¾¨è­˜çµæœ:', text);
            target.value = text && text.trim() ? text : "è«‹æ”¹ç”¨æ–‡å­—è¼¸å…¥";
          } catch (error) {
            console.error('âŒ [å…±ç”¨éŒ„éŸ³] èªéŸ³è¾¨è­˜éŒ¯èª¤:', error);
            target.value = "èªéŸ³è¾¨è­˜å¤±æ•—ï¼Œè«‹æ”¹ç”¨æ–‡å­—è¼¸å…¥";
            showToast(`âŒ èªéŸ³è¾¨è­˜å¤±æ•—: ${error.message}`, { type: 'error', duration: 3000 });
          }
          
          // é‡‹æ”¾åª’é«”æµ
          console.log('ğŸ”’ [å…±ç”¨éŒ„éŸ³] é‡‹æ”¾åª’é«”æµ...');
          const tracks = stream.getTracks();
          tracks.forEach(track => {
            console.log('ğŸ›‘ [å…±ç”¨éŒ„éŸ³] åœæ­¢éŸ³è»Œ:', track.label);
            track.stop();
          });
        };

        mediaRecorder.onerror = (event) => {
          console.error('âŒ [å…±ç”¨éŒ„éŸ³] MediaRecorder éŒ¯èª¤:', event.error);
          showToast(`âŒ éŒ„éŸ³å™¨éŒ¯èª¤: ${event.error}`, { type: 'error', duration: 5000 });
        };

        mediaRecorder.start();
        console.log('ğŸŸ¢ [å…±ç”¨éŒ„éŸ³] é–‹å§‹éŒ„éŸ³, MediaRecorder ç‹€æ…‹:', mediaRecorder.state);
        btn.classList.add("is-recording");
        btn.textContent = "ğŸŸ¥ åœæ­¢";
        isRecording = true;
        
        showToast('ğŸ¤ é–‹å§‹éŒ„éŸ³...', { type: 'info', duration: 1000 });
      } catch (err) {
        console.error('âŒ [å…±ç”¨éŒ„éŸ³] éº¥å…‹é¢¨å­˜å–éŒ¯èª¤:', err);
        
        let errorMessage = 'âŒ ç„¡æ³•å•Ÿç”¨éº¥å…‹é¢¨';
        
        if (err.name === 'NotAllowedError') {
          errorMessage = 'âŒ éº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•ï¼Œè«‹åœ¨ç€è¦½å™¨è¨­å®šä¸­å…è¨±';
        } else if (err.name === 'NotFoundError') {
          errorMessage = 'âŒ æ‰¾ä¸åˆ°éº¥å…‹é¢¨è¨­å‚™ï¼Œè«‹æª¢æŸ¥æ˜¯å¦å·²é€£æ¥ã€‚';
        } else if (err.name === 'NotSupportedError') {
          errorMessage = 'âŒ ç€è¦½å™¨ä¸æ”¯æ´éŒ„éŸ³åŠŸèƒ½';
        } else if (err.name === 'NotReadableError') {
          errorMessage = 'âŒ éº¥å…‹é¢¨è¢«å…¶ä»–æ‡‰ç”¨ç¨‹å¼ä½”ç”¨';
        }
        
        console.log('ğŸ” [å…±ç”¨éŒ„éŸ³] éŒ¯èª¤è©³æƒ…:', {
          name: err.name,
          message: err.message,
          stack: err.stack,
          buttonId: buttonId,
          targetId: targetTextareaId
        });
        
        showToast(errorMessage, { type: 'error', duration: 6000 });
        target.value = "éº¥å…‹é¢¨ç„¡æ³•ä½¿ç”¨ï¼Œè«‹æ‰‹å‹•è¼¸å…¥";
      }
    } else {
      mediaRecorder.stop();
      btn.classList.remove("is-recording");
      btn.textContent = "ğŸ¤  éŒ„éŸ³";
      isRecording = false;
    }
  };
}


function appendMessage(sender, text) {
  const chatBox = document.getElementById("chat-box");
  const msg = document.createElement("div");
  msg.className = sender === "user" ? "text-right text-blue-700" : "text-left text-brown-700";
  msg.textContent = sender === "user" ? `ğŸ§‘â€ğŸ’¬ ${text}` : `ğŸ¤– å°å…‰ï¼š${text}`;
  chatBox.appendChild(msg);
  chatBox.scrollTop = chatBox.scrollHeight;
}

// ğŸ§ èªéŸ³ â†’ æ–‡å­—ï¼ˆåœ–è¡¨æ¶æ§‹ï¼šçµ±ä¸€ä¸Šå‚³å¾Œç«¯è™•ç†ï¼‰
async function transcribeAudio(audioBlob) {
  try {
    console.log("ğŸ™ï¸ é–‹å§‹èªéŸ³è½‰æ–‡å­—ï¼ŒéŸ³é »å¤§å°:", audioBlob.size, "å­—ç¯€");
    
    // æª¢æŸ¥éŸ³é »å¤§å°
    if (audioBlob.size < 1000) {
      console.warn("éŸ³é »æ–‡ä»¶å¤ªå°ï¼Œå¯èƒ½éŒ„éŸ³å¤±æ•—");
      return "éŒ„éŸ³æ™‚é–“å¤ªçŸ­ï¼Œè«‹é‡æ–°éŒ„éŸ³";
    }

    // æª¢æŸ¥ç¶²è·¯ç‹€æ…‹
    const isOnline = NetworkManager.isOnline();
    
    if (isOnline) {
      // ç·šä¸Šæ¨¡å¼ï¼šå„ªå…ˆé †åº 1) å¾Œç«¯ Whisper 2) Hugging Face Whisper 3) åŸç”Ÿè­˜åˆ¥
      console.log("ğŸŒ ç·šä¸Šæ¨¡å¼ï¼šå˜—è©¦èªéŸ³è­˜åˆ¥");
      
      // æ–¹æ³•1: å˜—è©¦å¾Œç«¯ Whisper
      const backendAvailable = await NetworkManager.checkBackendConnection();
      if (backendAvailable.success) {
        try {
          console.log("ï¿½ ä½¿ç”¨å¾Œç«¯ Whisper API");
          const formData = new FormData();
          formData.append("audio", audioBlob, "recording.wav");
          
          const response = await fetch(`${BACKEND_URL}/api/transcribe`, {
            method: "POST",
            body: formData,
          });

          if (response.ok) {
            const result = await response.json();
            console.log("âœ… å¾Œç«¯ Whisper çµæœï¼š", result);
            
            if (result.text && result.text.trim()) {
              showToast('âœ… èªéŸ³è­˜åˆ¥æˆåŠŸ (å¾Œç«¯)', { type: 'success', duration: 2000 });
              return result.text.trim();
            }
          }
        } catch (backendError) {
          console.warn("å¾Œç«¯ Whisper å¤±æ•—ï¼Œå˜—è©¦å…¶å®ƒæ–¹æ³•:", backendError);
        }
      }
      
      // æ–¹æ³•2: ä½¿ç”¨ Hugging Face Whisper APIï¼ˆæ‰‹æ©Ÿç‰ˆå„ªåŒ–ï¼‰
      try {
        console.log("ğŸ¤— ä½¿ç”¨ Hugging Face Whisper API");
        const hfResult = await transcribeWithHuggingFaceMobile(audioBlob);
        if (hfResult && hfResult.trim()) {
          showToast('âœ… èªéŸ³è­˜åˆ¥æˆåŠŸ (Whisper)', { type: 'success', duration: 2000 });
          return hfResult.trim();
        }
      } catch (hfError) {
        console.warn("Hugging Face Whisper å¤±æ•—:", hfError);
        showToast('âš ï¸ Whisper API å¤±æ•—ï¼Œå˜—è©¦åŸç”Ÿè­˜åˆ¥', { type: 'warning', duration: 2000 });
      }
      
      // æ–¹æ³•3: ä½¿ç”¨åŸç”ŸèªéŸ³è­˜åˆ¥
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        try {
          console.log("ğŸ¤ ä½¿ç”¨åŸç”ŸèªéŸ³è­˜åˆ¥");
          const nativeResult = await useNativeSpeechRecognition();
          if (nativeResult && nativeResult.trim()) {
            showToast('âœ… èªéŸ³è­˜åˆ¥æˆåŠŸ (åŸç”Ÿ)', { type: 'success', duration: 2000 });
            return nativeResult.trim();
          }
        } catch (nativeError) {
          console.warn("åŸç”ŸèªéŸ³è­˜åˆ¥å¤±æ•—:", nativeError);
        }
      }
      
      // æ‰€æœ‰æ–¹æ³•éƒ½å¤±æ•—
      showToast('âš ï¸ èªéŸ³è­˜åˆ¥å¤±æ•—ï¼ŒéŸ³é »å·²æš«å­˜', { type: 'warning' });
      await LocalStorage.saveAudioForUpload(audioBlob, {
        timestamp: new Date().toISOString(),
        purpose: 'transcription'
      });
      return "èªéŸ³å·²æš«å­˜ï¼Œè«‹æ‰‹å‹•è¼¸å…¥å…§å®¹";
      
    } else {
      // é›¢ç·šæ¨¡å¼ï¼šæš«å­˜éŸ³é »
      console.log("ğŸ“± é›¢ç·šæ¨¡å¼ï¼šæš«å­˜éŸ³é »ç­‰å¾…åŒæ­¥");
      
      await LocalStorage.saveAudioForUpload(audioBlob, {
        timestamp: new Date().toISOString(),
        purpose: 'transcription'
      });
      
      showToast('ğŸ’¾ éŸ³é »å·²æš«å­˜ï¼Œå°‡åœ¨é€£ç·šå¾Œè™•ç†', { type: 'info', duration: 3000 });
      
      // å˜—è©¦ä½¿ç”¨åŸç”ŸèªéŸ³è­˜åˆ¥ä½œç‚ºæš«æ™‚æ–¹æ¡ˆï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        try {
          console.log("ğŸ”„ å˜—è©¦åŸç”ŸèªéŸ³è­˜åˆ¥ä½œç‚ºæš«æ™‚æ–¹æ¡ˆ");
          const nativeResult = await useNativeSpeechRecognition();
          console.log("åŸç”ŸèªéŸ³è­˜åˆ¥æš«æ™‚çµæœ:", nativeResult);
          return nativeResult + " (é›¢ç·šæš«å­˜)";
        } catch (nativeError) {
          console.warn("åŸç”ŸèªéŸ³è­˜åˆ¥ä¹Ÿå¤±æ•—:", nativeError);
        }
      }
      
      return "éŸ³é »å·²æš«å­˜ï¼Œè«‹æ‰‹å‹•è¼¸å…¥å…§å®¹æˆ–ç­‰å¾…ç¶²è·¯æ¢å¾©";
    }

  } catch (e) {
    console.error("èªéŸ³è½‰æ–‡å­—éŒ¯èª¤:", e);
    showToast('ğŸ’¡ èªéŸ³è½‰æ–‡å­—å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¼¸å…¥', { type: 'info', duration: 3000 });
    return "è«‹æ‰‹å‹•è¼¸å…¥æ‚¨å‰›æ‰èªªçš„å…§å®¹";
  }
}

// åŸç”ŸèªéŸ³è­˜åˆ¥åŠŸèƒ½ï¼ˆæ‰‹æ©Ÿç‰ˆå°ˆç”¨ï¼‰
async function useNativeSpeechRecognition() {
  return new Promise((resolve, reject) => {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    
    if (!SpeechRecognition) {
      reject(new Error("ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è­˜åˆ¥"));
      return;
    }
    
    const recognition = new SpeechRecognition();
    
    // è¨­å®šèªéŸ³è­˜åˆ¥åƒæ•¸
    recognition.lang = 'zh-TW'; // ç¹é«”ä¸­æ–‡
    recognition.continuous = false; // å–®æ¬¡è­˜åˆ¥
    recognition.interimResults = false; // ä¸è¦ä¸­é–“çµæœ
    recognition.maxAlternatives = 1; // åªè¦æœ€ä½³çµæœ
    
    let timeout;
    
    recognition.onstart = () => {
      console.log("åŸç”ŸèªéŸ³è­˜åˆ¥é–‹å§‹...");
      showToast('ğŸ¤ è«‹é–‹å§‹èªªè©±', { type: 'info', duration: 2000 });
      
      // è¨­å®šè¶…æ™‚
      timeout = setTimeout(() => {
        recognition.stop();
        reject(new Error("èªéŸ³è­˜åˆ¥è¶…æ™‚"));
      }, 8000); // 8ç§’è¶…æ™‚
    };
    
    recognition.onresult = (event) => {
      clearTimeout(timeout);
      const result = event.results[0][0].transcript;
      console.log("åŸç”ŸèªéŸ³è­˜åˆ¥çµæœ:", result);
      showToast('âœ… è­˜åˆ¥æˆåŠŸï¼', { type: 'success', duration: 1000 });
      resolve(result);
    };
    
    recognition.onerror = (event) => {
      clearTimeout(timeout);
      console.error("åŸç”ŸèªéŸ³è­˜åˆ¥éŒ¯èª¤:", event.error);
      
      let errorMsg = "èªéŸ³è­˜åˆ¥å¤±æ•—";
      switch(event.error) {
        case 'no-speech':
          errorMsg = "æ²’æœ‰æª¢æ¸¬åˆ°èªéŸ³ï¼Œè«‹é‡æ–°éŒ„éŸ³";
          break;
        case 'audio-capture':
          errorMsg = "ç„¡æ³•å­˜å–éº¥å…‹é¢¨";
          break;
        case 'not-allowed':
          errorMsg = "éº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•";
          break;
        case 'network':
          errorMsg = "ç¶²è·¯é€£ç·šå•é¡Œ";
          break;
      }
      
      reject(new Error(errorMsg));
    };
    
    recognition.onend = () => {
      clearTimeout(timeout);
      console.log("åŸç”ŸèªéŸ³è­˜åˆ¥çµæŸ");
    };
    
    // é–‹å§‹è­˜åˆ¥
    try {
      recognition.start();
    } catch (startError) {
      clearTimeout(timeout);
      reject(new Error("ç„¡æ³•å•Ÿå‹•èªéŸ³è­˜åˆ¥: " + startError.message));
    }
  });
}

// === åœ°ç†ä½ç½®å’ŒéŒ„éŸ³åœ°åœ–åŠŸèƒ½ ===

// ç²å–ç•¶å‰åœ°ç†ä½ç½®
async function getCurrentLocation() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('æ­¤è£ç½®ä¸æ”¯æ´åœ°ç†ä½ç½®'));
      return;
    }
    
    const options = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 60000
    };
    
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log('ğŸ“ ç²å¾—åœ°ç†ä½ç½®:', position.coords);
        resolve({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy
        });
      },
      (error) => {
        console.warn('âŒ åœ°ç†ä½ç½®ç²å–å¤±æ•—:', error);
        let errorMsg = 'ç„¡æ³•ç²å–ä½ç½®';
        switch(error.code) {
          case error.PERMISSION_DENIED:
            errorMsg = 'ä½ç½®æ¬Šé™è¢«æ‹’çµ•';
            break;
          case error.POSITION_UNAVAILABLE:
            errorMsg = 'ä½ç½®è³‡è¨Šç„¡æ³•ä½¿ç”¨';
            break;
          case error.TIMEOUT:
            errorMsg = 'ä½ç½®è«‹æ±‚è¶…æ™‚';
            break;
        }
        reject(new Error(errorMsg));
      },
      options
    );
  });
}

// å°‡éŒ„éŸ³æ¨™è¨˜æ·»åŠ åˆ°åœ°åœ–
function addAudioMarkerToMap(recordingId, lat, lng, placeName = null) {
  try {
    // å‰µå»ºéŸ³é »åœ–æ¨™
    const audioIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa(`
        <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
          <circle cx="20" cy="20" r="18" fill="#ff6b6b" stroke="#fff" stroke-width="2"/>
          <path d="M15 12h10v16h-10z" fill="#fff"/>
          <circle cx="20" cy="30" r="3" fill="#fff"/>
        </svg>
      `),
      iconSize: [40, 40],
      iconAnchor: [20, 40],
      popupAnchor: [0, -40]
    });
    
    const marker = L.marker([lat, lng], { icon: audioIcon }).addTo(map);
    
    // å‰µå»º popup å…§å®¹
    const popupContent = `
      <div class="audio-popup" style="min-width: 200px;">
        <h3 style="margin: 0 0 10px 0; color: #333;">ğŸ¤ éŒ„éŸ³è¨˜æ†¶</h3>
        ${placeName ? `<p style="margin: 5px 0; color: #666;">ğŸ“ ${placeName}</p>` : ''}
        <div style="margin-top: 10px;">
          <button onclick="playRecordingFromMap('${recordingId}')" 
                  style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 5px;">
            â–¶ï¸ æ’­æ”¾
          </button>
          <button onclick="deleteRecordingFromMap('${recordingId}', this)" 
                  style="background: #f44336; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
            ğŸ—‘ï¸ åˆªé™¤
          </button>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888;">
          éŒ„éŸ³ ID: ${recordingId}
        </div>
      </div>
    `;
    
    marker.bindPopup(popupContent);
    
    // å„²å­˜æ¨™è¨˜åƒè€ƒï¼Œæ–¹ä¾¿ä¹‹å¾Œç®¡ç†
    if (!window.audioMarkers) window.audioMarkers = new Map();
    window.audioMarkers.set(recordingId, marker);
    
    console.log('ğŸ—ºï¸ éŒ„éŸ³æ¨™è¨˜å·²æ·»åŠ åˆ°åœ°åœ–:', recordingId, lat, lng);
    
  } catch (error) {
    console.error('âŒ æ·»åŠ éŒ„éŸ³æ¨™è¨˜å¤±æ•—:', error);
  }
}

// å¾åœ°åœ–æ’­æ”¾éŒ„éŸ³
async function playRecordingFromMap(recordingId) {
  try {
    const result = await AudioDB.playRecording(parseInt(recordingId));
    if (result.success) {
      showToast('ğŸµ é–‹å§‹æ’­æ”¾éŒ„éŸ³', { type: 'success', duration: 2000 });
    } else {
      showToast('âŒ æ’­æ”¾å¤±æ•—', { type: 'error', duration: 3000 });
    }
  } catch (error) {
    console.error('æ’­æ”¾éŒ„éŸ³å¤±æ•—:', error);
    showToast('âŒ æ’­æ”¾éŒ¯èª¤: ' + error.message, { type: 'error', duration: 3000 });
  }
}

// å¾åœ°åœ–åˆªé™¤éŒ„éŸ³
async function deleteRecordingFromMap(recordingId, buttonElement) {
  if (confirm('ç¢ºå®šè¦åˆªé™¤é€™å€‹éŒ„éŸ³å—ï¼Ÿ')) {
    try {
      const result = await AudioDB.deleteRecording(parseInt(recordingId));
      if (result.success) {
        // ç§»é™¤åœ°åœ–æ¨™è¨˜
        if (window.audioMarkers && window.audioMarkers.has(recordingId)) {
          const marker = window.audioMarkers.get(recordingId);
          map.removeLayer(marker);
          window.audioMarkers.delete(recordingId);
        }
        
        // é—œé–‰ popup
        map.closePopup();
        
        showToast('âœ… éŒ„éŸ³å·²åˆªé™¤', { type: 'success', duration: 2000 });
      } else {
        showToast('âŒ åˆªé™¤å¤±æ•—', { type: 'error', duration: 3000 });
      }
    } catch (error) {
      console.error('åˆªé™¤éŒ„éŸ³å¤±æ•—:', error);
      showToast('âŒ åˆªé™¤éŒ¯èª¤: ' + error.message, { type: 'error', duration: 3000 });
    }
  }
}

// è¼‰å…¥æ‰€æœ‰éŒ„éŸ³æ¨™è¨˜åˆ°åœ°åœ–
async function loadAudioMarkersToMap() {
  try {
    const recordings = await AudioDB.getAllRecordings();
    recordings.forEach(recording => {
      if (recording.latitude && recording.longitude) {
        addAudioMarkerToMap(recording.id, recording.latitude, recording.longitude, recording.place_name);
      }
    });
    console.log('ğŸ—ºï¸ å·²è¼‰å…¥', recordings.filter(r => r.latitude && r.longitude).length, 'å€‹éŒ„éŸ³æ¨™è¨˜');
  } catch (error) {
    console.error('è¼‰å…¥éŒ„éŸ³æ¨™è¨˜å¤±æ•—:', error);
  }
}

// åŒæ­¥éŒ„éŸ³åˆ°é›²ç«¯ MongoDB
async function syncAudioToCloud(audioBlob, metadata) {
  try {
    // å°‡éŸ³é »è½‰æ›ç‚º Base64
    const audioBase64 = await blobToBase64(audioBlob);
    
    const payload = {
      audio_data: audioBase64,
      transcription: metadata.transcription,
      location: metadata.location,
      latitude: metadata.latitude,
      longitude: metadata.longitude, 
      place_name: metadata.place_name,
      memory_id: metadata.memory_id,
      source: metadata.source || 'mobile_app',
      duration: metadata.duration,
      audio_type: audioBlob.type || 'audio/webm'
    };
    
    const response = await fetch(`${BACKEND_URL}/api/audio`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    
    if (response.ok) {
      const result = await response.json();
      console.log('âœ… éŒ„éŸ³å·²åŒæ­¥åˆ°é›²ç«¯:', result);
      return result;
    } else {
      throw new Error(`é›²ç«¯åŒæ­¥å¤±æ•—: ${response.status}`);
    }
    
  } catch (error) {
    console.error('âŒ é›²ç«¯åŒæ­¥éŒ¯èª¤:', error);
    throw error;
  }
}

// Blob è½‰ Base64 è¼”åŠ©å‡½æ•¸
function blobToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result.split(',')[1]; // ç§»é™¤ data:audio/webm;base64, å‰ç¶´
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// === èŠå¤©é€å‡ºåŠŸèƒ½ï¼ˆæ”¯æ´ç·šä¸Šå’Œé›¢ç·šæ¨¡å¼ï¼‰===
document.getElementById("chatSend").onclick = async () => {
  const inputBox = document.getElementById("chatInput");
  const text = inputBox.value.trim();
  
  // ä½¿ç”¨çµ±ä¸€çš„èŠå¤©é€å‡ºå‡½æ•¸
  await performChatSend(text);
  
  // æ¸…ç©ºè¼¸å…¥æ¡†
  inputBox.value = "";
};

// === çµ±ä¸€çš„èŠå¤©é€å‡ºå‡½æ•¸ ===
async function performChatSend(text) {
  if (!text || !text.trim()) {
    showToast('è«‹å…ˆè¼¸å…¥æˆ–éŒ„éŸ³å…§å®¹ï¼', { type: 'error' });
    return;
  }

  try {
    let saveResult;
    
    // ç²å–ç•¶å‰ä½ç½®ï¼ˆå¦‚æœå¯èƒ½çš„è©±ï¼‰
    let currentPosition = null;
    try {
      if (navigator.geolocation) {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            timeout: 5000,
            enableHighAccuracy: false
          });
        });
        currentPosition = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };
        console.log("ç²å–åˆ°ä½ç½®:", currentPosition);
      }
    } catch (geoError) {
      console.log("ç„¡æ³•ç²å–ä½ç½®:", geoError);
    }

    // åœ–è¡¨æ¶æ§‹ï¼šæ‰‹æ©Ÿå’Œæ¡Œé¢éƒ½å„ªå…ˆå˜—è©¦å¾Œç«¯ï¼Œå¤±æ•—æ™‚æœ¬åœ°å„²å­˜
    const memoryData = {
      text: text,
      type: 'text',
      lat: currentPosition?.lat || null,
      lng: currentPosition?.lng || null,
      place: currentPosition ? "ç•¶å‰ä½ç½®" : null,
      created_at: new Date().toISOString()
    };
    
    // æª¢æŸ¥ç¶²è·¯å’Œå¾Œç«¯é€£ç·šç‹€æ…‹
    const isOnline = NetworkManager.isOnline();
    const backendAvailable = isOnline ? await NetworkManager.checkBackendConnection() : false;
    
    if (backendAvailable) {
      // ç·šä¸Šæ¨¡å¼ï¼šå„ªå…ˆä½¿ç”¨å¾Œç«¯ (ç¬¦åˆåœ–è¡¨æ¶æ§‹)
      try {
        console.log("ğŸŒ å˜—è©¦å„²å­˜åˆ°å¾Œç«¯");
        const res = await fetch(`${BACKEND_URL}/api/memories`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(memoryData)
        });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${await res.text()}`);
        }

        saveResult = await res.json();
        console.log("âœ… å¾Œç«¯å„²å­˜æˆåŠŸï¼š", saveResult);
        showToast('â˜ï¸ è¨˜æ†¶å·²åŒæ­¥åˆ°é›²ç«¯', { type: 'success', duration: 2000 });
        
      } catch (backendError) {
        console.warn("å¾Œç«¯å„²å­˜å¤±æ•—ï¼Œæ”¹ç”¨æœ¬åœ°å„²å­˜:", backendError);
        
        // å„²å­˜åˆ°æœ¬åœ°ä¸¦æ¨™è¨˜å¾…åŒæ­¥
        saveResult = await LocalStorage.saveMemory(memoryData);
        await LocalStorage.savePendingSync(memoryData);
        
        console.log("ğŸ“± æœ¬åœ°å„²å­˜ï¼ˆå¾…åŒæ­¥ï¼‰ï¼š", saveResult);
        showToast('ğŸ’¾ æš«å­˜æœ¬åœ°ï¼Œç¨å¾ŒåŒæ­¥', { type: 'warning', duration: 2000 });
      }
    } else {
      // é›¢ç·šæ¨¡å¼ï¼šæœ¬åœ°å„²å­˜ä¸¦æ¨™è¨˜å¾…åŒæ­¥
      console.log("ğŸ“± é›¢ç·šæ¨¡å¼ï¼šæœ¬åœ°å„²å­˜");
      
      saveResult = await LocalStorage.saveMemory(memoryData);
      await LocalStorage.savePendingSync(memoryData);
      
      console.log("ï¿½ é›¢ç·šå„²å­˜ï¼ˆå¾…åŒæ­¥ï¼‰ï¼š", saveResult);
      showToast('ğŸ“´ é›¢ç·šæ¨¡å¼ï¼Œè³‡æ–™å·²æš«å­˜', { type: 'info', duration: 2000 });
    }

    if (saveResult && saveResult.success) {
      // âœ… æ›´æ–°å°è©±æ¡†
      appendMessage("user", text);
      
      // ç²å– AI å›æ‡‰
      const aiReply = await getAIReply(text);
      appendMessage("ai", aiReply);
      
      // é¡¯ç¤ºå„²å­˜æˆåŠŸè¨Šæ¯
      showToast('âœ… è¨˜æ†¶å·²å„²å­˜åˆ°ç”Ÿå‘½åœ°åœ–ï¼', { type: 'success' });

      // ç«‹å³é‡æ–°è¼‰å…¥å›æ†¶ä¸¦æ›´æ–°æ™‚é–“è»¸ï¼Œç¢ºä¿æ–°ç¯€é»ç«‹å³é¡¯ç¤º
      try {
        await loadMemories();
        await renderTimeline();
      } catch (e) {
        console.warn('performChatSend: failed to refresh timeline after creating memory', e);
      }
    } else {
      console.error('å„²å­˜å¤±æ•—:', saveResult);
      showToast('âŒ å„²å­˜å¤±æ•—ï¼Œè«‹é‡è©¦', { type: 'error' });
      throw new Error('å„²å­˜è¨˜æ†¶å¤±æ•—');
    }

  } catch (err) {
    console.error("å„²å­˜å¤±æ•—ï¼š", err);
    showToast('âŒ ç„¡æ³•å„²å­˜ï¼Œè«‹ç¨å¾Œå†è©¦', { type: 'error' });
  }
}

// ğŸ’¬ AI å›è¦†ï¼ˆæ”¯æ´ç·šä¸Šå’Œé›¢ç·šæ¨¡å¼ï¼‰
async function getAIReply(text) {
  try {
    // æ‰‹æ©Ÿç’°å¢ƒå„ªå…ˆä½¿ç”¨æœ¬åœ°å„²å­˜ï¼Œæ¡Œé¢ç‰ˆä½¿ç”¨å¾Œç«¯
    const isMobile = window.screen.width <= 768 || 'ontouchstart' in window || /Mobi|Android/i.test(navigator.userAgent);
    
    if (isMobile) {
      // æ‰‹æ©Ÿç‰ˆä½¿ç”¨é›¢ç·š AI å›æ‡‰
      const result = await LocalStorage.getOfflineAIReply(text);
      console.log("ğŸ§­ æ‰‹æ©Ÿç‰ˆï¼šä½¿ç”¨é›¢ç·š AI å›æ‡‰");
      return result.response;
    } else {
      // æ¡Œé¢ç‰ˆå˜—è©¦ç·šä¸Šæ¨¡å¼
      const response = await fetch(HF_CHAT_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text })
      });
      const data = await response.json();
      console.log("ğŸ–¥ï¸ æ¡Œé¢ç‰ˆï¼šä½¿ç”¨ç·šä¸Š AI å›æ‡‰");
      return data[0]?.generated_text || "æˆ‘è½ä¸å¤ªæ‡‚ï¼Œå†èªªä¸€æ¬¡å—ï¼Ÿ";
    }
  } catch (err) {
    console.error("AI Error:", err);
    // ç·šä¸Šæ¨¡å¼å¤±æ•—æ™‚å›é€€åˆ°é›¢ç·šæ¨¡å¼
    try {
      const result = await LocalStorage.getOfflineAIReply(text);
      console.log("ğŸ”„ å›é€€åˆ°é›¢ç·š AI å›æ‡‰");
      return result.response;
    } catch (offlineErr) {
      console.error("Offline AI Error:", offlineErr);
      return "æˆ‘ç¾åœ¨ç„¡æ³•å›æ‡‰ï¼Œè«‹ç¨å¾Œå†è©¦ï¼";
    }
  }
}


renderCharacterCards();
switchView('empty');

// === è¼‰å…¥æ‰€æœ‰å›æ†¶ï¼ˆåœ–è¡¨æ¶æ§‹ï¼šå„ªå…ˆå¾Œç«¯ï¼Œå›é€€æœ¬åœ°ï¼‰===
async function loadMemories() {
  try {
    let memories;
    
    // è§¸ç™¼åŒæ­¥æª¢æŸ¥ï¼ˆèƒŒæ™¯åŸ·è¡Œï¼‰
    if (NetworkManager.isOnline()) {
      NetworkManager.syncPendingData().catch(e => console.warn('èƒŒæ™¯åŒæ­¥å¤±æ•—:', e));
    }
    
    // æª¢æŸ¥ç¶²è·¯å’Œå¾Œç«¯é€£ç·šç‹€æ…‹
    const isOnline = NetworkManager.isOnline();
    const backendAvailable = isOnline ? await NetworkManager.checkBackendConnection() : false;
    
    if (backendAvailable) {
      // ç·šä¸Šæ¨¡å¼ï¼šå¾å¾Œç«¯è¼‰å…¥ (ç¬¦åˆåœ–è¡¨æ¶æ§‹)
      try {
        console.log("ğŸŒ å¾å¾Œç«¯è¼‰å…¥è¨˜æ†¶");
        const res = await fetch(`${BACKEND_URL}/api/memories`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        
        memories = await res.json();
        console.log("â˜ï¸ å¾å¾Œç«¯è¼‰å…¥", memories.length, "ç­†è¨˜æ†¶");
        
        // åŒæ­¥åˆ°æœ¬åœ°ä½œç‚ºå¿«å–
        for (const memory of memories) {
          await LocalStorage.saveMemory(memory);
        }
        
      } catch (backendError) {
        console.warn("å¾Œç«¯è¼‰å…¥å¤±æ•—ï¼Œä½¿ç”¨æœ¬åœ°å¿«å–:", backendError);
        memories = await LocalStorage.loadMemories();
        console.log("ğŸ“± å¾æœ¬åœ°å¿«å–è¼‰å…¥", memories.length, "ç­†è¨˜æ†¶");
      }
    } else {
      // é›¢ç·šæ¨¡å¼ï¼šå¾æœ¬åœ°è¼‰å…¥
      console.log("ğŸ“± é›¢ç·šæ¨¡å¼ï¼šå¾æœ¬åœ°è¼‰å…¥è¨˜æ†¶");
      memories = await LocalStorage.loadMemories();
      console.log("ğŸ“´ å¾æœ¬åœ°è¼‰å…¥", memories.length, "ç­†è¨˜æ†¶");
    }
    
    // cache for global access (used by delegated handlers)
    try { window._memories = memories; } catch (e) { window._memories = memories; }

    const container = document.getElementById("photo-card-container");
    const timeline = document.getElementById("timeline");

    // ç„¡è³‡æ–™è™•ç†ï¼ˆåƒ…åœ¨å¾Œç«¯ç¢ºå¯¦å›ç©ºé™£åˆ—æ™‚æ¸…ç©ºæ™‚é–“è»¸ï¼‰
    if (!memories.length) {
      console.log('å¾Œç«¯å›å‚³ç©ºå›æ†¶é™£åˆ—ï¼Œæ¸…ç©ºæ™‚é–“è»¸');
      container.innerHTML = `<div class="text-gray-500 text-center mt-4">
        ç›®å‰é‚„æ²’æœ‰ä»»ä½•å›æ†¶è¨˜éŒ„ ğŸŒ±
      </div>`;
      timeline.innerHTML = "";
      if (window.memoryMarkers) window.memoryMarkers.forEach(m => map.removeLayer(m));
      if (window.memoryPolyline) map.removeLayer(window.memoryPolyline);
      return;
    }

    // ğŸ”¹ æ¸…é™¤èˆŠåœ–å±¤
    if (window.memoryMarkers) window.memoryMarkers.forEach(m => map.removeLayer(m));
    if (window.memoryPolyline) map.removeLayer(window.memoryPolyline);
    window.memoryMarkers = [];

    const validPoints = [];

    // === 1ï¸âƒ£ åœ¨åœ°åœ–ä¸Šç•« Marker ===
    memories.forEach(m => {
      if (m.lat !== null && m.lng !== null) {
        const marker = L.marker([m.lat, m.lng], { icon: customIcon })
          .addTo(map)
          .bindPopup(`<b>${m.place || "æœªçŸ¥åœ°é»"}</b><br>${m.text}`);
        marker.on("click", () => openMemoryCard({ currentTarget: marker }, m));
        window.memoryMarkers.push(marker);
        validPoints.push([m.lat, m.lng]);
      }
    });

    // === 2ï¸âƒ£ ä¸åœ¨åœ°åœ–ä¸Šç•«æŠ˜ç·šï¼ˆåƒ…åœ¨åº•éƒ¨æ™‚é–“è»¸é¡¯ç¤ºï¼‰ ===
    // åªä½¿ç”¨ markers çš„ç¯„åœä¾†èšç„¦åœ°åœ–ï¼Œä¸åœ¨åœ°åœ–ä¸Šç¹ªè£½æŠ˜ç·š
    if (validPoints.length > 1) {
      try {
        const bounds = L.latLngBounds(validPoints);
        map.fitBounds(bounds);
      } catch (e) {
        console.warn('fitBounds å¤±æ•—ï¼š', e);
      }
      // ä¸åœ¨åœ°åœ–å»ºç«‹ polylineï¼Œä¿ç•™ window.memoryPolyline ç‚º null
      window.memoryPolyline = null;
    } else if (validPoints.length === 1) {
      map.setView(validPoints[0], 10);
    }

    // === 3ï¸âƒ£ ç”Ÿæˆæ™‚é–“è»¸ç¯€é» ===
    timeline.innerHTML = "";
    timeline.style.display = "flex";
    // ä¾ created_at æ’åºï¼Œç¢ºä¿æ™‚é–“è»¸ç‚ºæ™‚é–“é †åºï¼ˆè‹¥æ²’æœ‰ created_at å‰‡ä¿ç•™åŸé †åºï¼‰
    try {
      memories.sort((a,b) => {
        if (!a.created_at || !b.created_at) return 0;
        return new Date(a.created_at) - new Date(b.created_at);
      });
    } catch (e) { /* non-fatal, keep original order */ }

    memories.forEach((m, idx) => {
      const dot = document.createElement("button");
      dot.className = "timeline-dot";
      dot.title = m.place || "æœªå‘½ååœ°é»";
      // å¦‚æœå¾Œç«¯æ²’æœ‰æä¾› idï¼Œä½¿ç”¨ fallback idï¼ˆä¸å¦å¤–è¼¸å‡º debugï¼‰
      dot.dataset.id = (m.id === undefined || m.id === null) ? `missing-${idx}` : m.id;
      dot.onclick = (e) => openMemoryCard(e, m);
      timeline.appendChild(dot);

      // ğŸ”¸ é•·æŒ‰åˆªé™¤åŠŸèƒ½ï¼ˆä½¿ç”¨å…±ç”¨ helperï¼Œæ”¯æ´ touch & mouse & å³éµï¼‰
      attachLongPress(dot, dot.dataset.id);
    });

    // è‹¥æœªç”¢ç”Ÿä»»ä½•ç¯€é»ï¼Œé¡¯ç¤ºç°¡çŸ­æç¤º
    if (timeline.children.length === 0) {
      timeline.innerHTML = `<div class="text-gray-500 text-sm">ï¼ˆå°šæœªæœ‰å¯é¡¯ç¤ºçš„æ™‚é–“è»¸ç¯€é»ï¼‰</div>`;
    }

    // ğŸ”¹ æ›´æ–°æ©«ç·šé•·åº¦
    requestAnimationFrame(() => {
      const dots = timeline.querySelectorAll(".timeline-dot");
      const gap = 80;
      const lineLength = (dots.length - 1) * gap + 200;
      timeline.style.setProperty("--line-width", `${lineLength}px`);
      // debug: log each dot's computed style
      dots.forEach((d, i) => {
        const cs = window.getComputedStyle(d);
        console.log(`timeline dot[${i}] id=${d.dataset.id} display=${cs.display} opacity=${cs.opacity} z-index=${cs.zIndex}`);
      });
    });

  } catch (err) {
    console.error("è¼‰å…¥å›æ†¶å¤±æ•—", err);
    
    // æœ€å¾Œçš„å®‰å…¨ç¶²ï¼šå˜—è©¦å¾æœ¬åœ°è¼‰å…¥
    try {
      console.log('ğŸ”„ å˜—è©¦å®‰å…¨å›é€€ï¼šå¾æœ¬åœ°è¼‰å…¥è¨˜æ†¶');
      const localMemories = await LocalStorage.loadMemories();
      
      if (localMemories && localMemories.length > 0) {
        console.log('âœ… å¾æœ¬åœ°è¼‰å…¥åˆ°', localMemories.length, 'ç­†è¨˜æ†¶');
        window._memories = localMemories;
        
        const container = document.getElementById("photo-card-container");
        const timeline = document.getElementById("timeline");
        
        // æ¸…é™¤èˆŠåœ–å±¤
        if (window.memoryMarkers) window.memoryMarkers.forEach(m => map.removeLayer(m));
        if (window.memoryPolyline) map.removeLayer(window.memoryPolyline);
        window.memoryMarkers = [];
        
        // ç°¡åŒ–é¡¯ç¤ºæœ¬åœ°è¨˜æ†¶
        container.innerHTML = localMemories.map(m => `
          <div class="bg-white rounded-lg shadow-md p-4 mb-4">
            <div class="text-gray-600 text-sm mb-2">${m.created_at ? new Date(m.created_at).toLocaleString() : 'æœªçŸ¥æ™‚é–“'}</div>
            <div class="text-gray-800">${m.text}</div>
            ${m.place ? `<div class="text-blue-600 text-sm mt-2">ğŸ“ ${m.place}</div>` : ''}
            <div class="text-orange-500 text-xs mt-2">ğŸ“± æœ¬åœ°è¨˜æ†¶</div>
          </div>
        `).join('');
        
        timeline.innerHTML = `<div class="text-green-600 text-center p-4">ğŸ“± å¾æœ¬åœ°è¼‰å…¥ ${localMemories.length} ç­†è¨˜æ†¶</div>`;
        
        showToast('ğŸ“± å¾Œç«¯ç„¡æ³•é€£ç·šï¼Œå·²è¼‰å…¥æœ¬åœ°è¨˜æ†¶', { type: 'warning', duration: 4000 });
        return;
      }
    } catch (localError) {
      console.error('æœ¬åœ°è¼‰å…¥ä¹Ÿå¤±æ•—:', localError);
    }
    
    // å®Œå…¨å¤±æ•—æ™‚çš„é¡¯ç¤º
    const container = document.getElementById("photo-card-container");
    const timeline = document.getElementById("timeline");
    
    container.innerHTML = `
      <div class="text-center mt-8 p-6">
        <div class="text-red-600 mb-4">âŒ è¼‰å…¥è¨˜æ†¶å¤±æ•—</div>
        <div class="text-gray-600 text-sm mb-4">
          ${NetworkManager.isOnline() ? 'å¾Œç«¯æœå‹™å¯èƒ½æœªå•Ÿå‹• (127.0.0.1:8010)' : 'ç›®å‰è™•æ–¼é›¢ç·šç‹€æ…‹'}
        </div>
        <div class="text-gray-500 text-xs mb-4">éŒ¯èª¤: ${err.message}</div>
        <button onclick="loadMemories()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mr-2">
          ğŸ”„ é‡æ–°è¼‰å…¥
        </button>
        <button onclick="switchView('chat')" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
          â• æ–°å¢è¨˜æ†¶
        </button>
      </div>
    `;
    
    timeline.innerHTML = "";
    if (window.memoryMarkers) window.memoryMarkers.forEach(m => map.removeLayer(m));
    if (window.memoryPolyline) map.removeLayer(window.memoryPolyline);
    window.memoryMarkers = [];
    window.memoryPolyline = null;
    // ä¸å†ä½¿ç”¨ mock æ¸¬è©¦è³‡æ–™ï¼Œä»¥å…æ··æ·†çœŸå¯¦è³‡æ–™åº«çµæœ
  }
}

let deleteTargetId = null; // ğŸ”¸ æš«å­˜è¦åˆªé™¤çš„ memory id

// === é»æ“Šåœ°åœ–æ¨™è¨˜ï¼šå°æ‡‰ç¯€é»ç™¼å…‰ ===
function highlightTimelineDot(memoryId) {
  const dots = document.querySelectorAll(".timeline-dot");
  dots.forEach(d => {
    d.classList.remove("active");
    if (d.dataset.id == memoryId) d.classList.add("active");
  });
}
// å…±ç”¨ long-press èˆ‡å³éµåˆªé™¤ç¶å®šï¼Œæ”¯æ´ mouse èˆ‡ touch
function attachLongPress(el, memoryId, options = {}) {
  const holdDuration = options.holdDuration || 800;
  let holdTimer = null;

  const start = (e) => {
    // å¿½ç•¥å³éµçš„ mousedown
    if (e.type === 'mousedown' && e.button === 2) return;
    clear();
    holdTimer = setTimeout(() => {
      openDeleteConfirm(memoryId);
      holdTimer = null;
    }, holdDuration);
  };

  const clear = () => { if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; } };

  el.addEventListener('mousedown', start);
  el.addEventListener('mouseup', clear);
  el.addEventListener('mouseleave', clear);

  el.addEventListener('touchstart', start, { passive: true });
  el.addEventListener('touchend', clear);
  el.addEventListener('touchcancel', clear);

  // å³éµä¹Ÿè§¸ç™¼åˆªé™¤ï¼ˆä¸¦é˜»æ­¢ç€è¦½å™¨é¸å–®ï¼‰
  el.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    openDeleteConfirm(memoryId);
  });
}
// === ç•«å‡ºæ¨™è¨˜ä¸¦åŠ é»æ“Šäº‹ä»¶ ===
function renderMarkers(memories) {
  map.eachLayer(layer => {
    if (layer instanceof L.Marker) map.removeLayer(layer);
  });

  memories.forEach(m => {
    if (m.lat && m.lng) {
      const marker = L.marker([m.lat, m.lng], { icon: customIcon }).addTo(map);
      marker.on("click", () => highlightTimelineDot(m.id));
    }
  });
}

// === å·¦å³éµæ§åˆ¶æ™‚é–“è»¸ ===
// ä½¿ç”¨å®‰å…¨æ–¹å¼åœ¨ DOM å­˜åœ¨æ™‚åšæ»¾å‹•æ“ä½œï¼Œä¸¦å®‰å…¨ç¶å®šæŒ‰éˆ•äº‹ä»¶
function scrollTimelineLeft() {
  const tl = document.getElementById("timeline");
  if (tl) tl.scrollBy({ left: -150, behavior: "smooth" });
}

function scrollTimelineRight() {
  const tl = document.getElementById("timeline");
  if (tl) tl.scrollBy({ left: 150, behavior: "smooth" });
}

// å®‰å…¨ç¶å®šå·¦å³æŒ‰éˆ•ï¼ˆmap-view å…§çš„å…©å€‹ç¶ è‰²æŒ‰éˆ•ï¼‰
const _navBtns = document.querySelectorAll('.bg-green-200');
if (_navBtns && _navBtns.length >= 2) {
  _navBtns[0].onclick = scrollTimelineLeft;
  _navBtns[1].onclick = scrollTimelineRight;
}

// === é¡¯ç¤ºå°å¡ ===
function showMemoryCard(m) {
  const container = document.getElementById("photo-card-container");
  // æ”¹ç‚ºéœæ…‹é¡¯ç¤ºï¼ˆç·¨è¼¯å‹•ä½œæ”¹ç”±é›†ä¸­å¼çš„ #editModal è™•ç†ï¼Œç¶­æŒä¸€è‡´çš„è¦–çª—å¤§å°ï¼‰
  container.innerHTML = `
    <div class="bg-white rounded-xl shadow p-3 w-full text-center">
      <div class="font-bold text-[#7a4a22] mb-1">${m.place || "æœªå‘½ååœ°é»"}</div>
      <div class="text-sm text-gray-600 mb-2">${new Date(m.created_at).toLocaleString()}</div>

      <!-- æ–‡å­—é¡¯ç¤ºï¼ˆéå…§åµŒç·¨è¼¯ï¼‰ -->
      <div id="previewText-${m.id}" class="w-full p-2 mb-2 text-gray-800 text-left" style="white-space:pre-wrap;">${m.text}</div>

      <!-- ç…§ç‰‡é è¦½ï¼ˆè‹¥ç„¡å‰‡æç¤ºï¼‰ -->
      ${m.photo_url 
        ? `<img id="previewImg-${m.id}" src="${BACKEND_URL}${m.photo_url}" class="rounded-lg w-full mb-2">`
        : `<div id="previewImg-${m.id}" class="text-gray-400 mb-2">ï¼ˆå°šæœªä¸Šå‚³ç…§ç‰‡ï¼‰</div>`}

      <div class="flex gap-2 justify-center mt-2">
        <button id="openEditBtn-${m.id}" class="px-4 py-2 bg-[#e7c8a3] rounded shadow">âœï¸ ç·¨è¼¯</button>
      </div>
    </div>
  `;

  // ç¶å®šç·¨è¼¯æŒ‰éˆ•ï¼Œé–‹å•Ÿçµ±ä¸€çš„ç·¨è¼¯ modalï¼ˆ#editModalï¼‰ä»¥ç¶­æŒä¸€è‡´å¤§å°èˆ‡è¡Œç‚º
  const editBtn = document.getElementById(`openEditBtn-${m.id}`);
  if (editBtn) editBtn.onclick = () => openEditModal(m);
}


async function goToMap() {
  // âœ… åˆ‡æ›é é¢ä¸¦è¼‰å…¥æ‰€æœ‰å›æ†¶
  switchView("map");
  await loadMemories();
  await renderTimeline();

  // ğŸ’¡ã€å„ªåŒ–ã€‘ç›´æ¥ä½¿ç”¨ loadMemories è¼‰å…¥çš„å¿«å–ï¼Œé¿å…é‡è¤‡ç™¼é€ç¶²è·¯è«‹æ±‚
  const memories = window._memories || [];
  if (!memories.length) {
    document.getElementById("photo-card-container").innerHTML =
      `<div class="text-gray-500 text-center mt-4">
         ç›®å‰é‚„æ²’æœ‰ä»»ä½•å›æ†¶è¨˜éŒ„ï¼Œå¿«ä¾†æ–°å¢ä¸€ç­†å§ ğŸŒ±
       </div>`;
  } else {
    // å¦‚æœæœ‰å›æ†¶ï¼ŒloadMemories å…§éƒ¨æœƒè‡ªå‹•èšç„¦åœ°åœ–ï¼Œé€™è£¡å¯ä»¥é¸æ“‡æ€§åœ°è¨­å®šä¸€å€‹é è¨­è¦–åœ–
    // map.setView([23.9739, 120.9820], 8); // èšç„¦å°ç£
  }

  setTimeout(() => map.invalidateSize(), 200); // âœ… åªéœ€é€™è¡Œç¢ºä¿ Leaflet é‡ç¹ª
}
let currentOpenId = null; // âœ… ç”¨ä¾†è¨˜éŒ„ç›®å‰é–‹å•Ÿçš„å°å¡ ID

// === ç”Ÿæˆæ™‚é–“è»¸ç¯€é»ï¼ˆå®‰å…¨ wrapperï¼‰ ===
async function renderTimeline() {
  try {
    // ä½¿ç”¨ loadMemories ä½œç‚ºå–®ä¸€ä¾†æºï¼ˆloadMemories å«éŒ¯èª¤ fallback èˆ‡ mockï¼‰
    await loadMemories();
  } catch (err) {
    console.error('renderTimeline æ•ç²éŒ¯èª¤ï¼š', err);
    // loadMemories å·²è™•ç† mock fallbackï¼Œé€™è£¡ä¸å†æ¸…ç©º timeline
  }
}
// åˆæ¬¡å‘¼å«ï¼Œè®“é é¢å˜—è©¦è¼‰å…¥ï¼ˆè‹¥å¾Œç«¯å¤±æ•—ï¼Œæœƒä½¿ç”¨ mockï¼‰
renderTimeline();
// === é–‹å•Ÿåˆªé™¤ç¢ºèªè¦–çª— ===
function openDeleteConfirm(memoryId) {
  deleteTargetId = memoryId;
  document.getElementById("deleteConfirm").style.display = "flex";
}

// === é—œé–‰åˆªé™¤ç¢ºèªè¦–çª— ===
function closeDeleteConfirm() {
  deleteTargetId = null;
  document.getElementById("deleteConfirm").style.display = "none";
}

// === ç¢ºèªåˆªé™¤ ===
async function confirmDelete() {
  if (!deleteTargetId) return;

  try {
    const res = await fetch(`${BACKEND_URL}/api/memories/${deleteTargetId}`, { method: "DELETE" });
    if (res.ok) {
      showToast('ğŸ—‘ å·²åˆªé™¤å›æ†¶', { type: 'success' });
      await loadMemories();
      await renderTimeline();
    } else {
      showToast('âŒ åˆªé™¤å¤±æ•—', { type: 'error' });
    }
  } catch (err) {
    console.error(err);
    showToast('âš ï¸ ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦', { type: 'error' });
  } finally {
    closeDeleteConfirm();
  }
}

// === é»æ“Šç¯€é»é–‹å°å¡ ===
function openMemoryCard(e, memory) {
  const container = document.getElementById("photo-card-container");

  // âœ… å¦‚æœå†æ¬¡é»åŒä¸€å€‹ç¯€é» â†’ é—œé–‰å°å¡
  if (currentOpenId === memory.id) {
    container.innerHTML = ""; // æ¸…ç©ºå°å¡
    currentOpenId = null;
    document.querySelectorAll(".timeline-dot").forEach(d => d.classList.remove("active"));
    return;
  }

  // âœ… æ›´æ–°ç›®å‰é–‹å•Ÿçš„ ID
  currentOpenId = memory.id;

  // === é¡¯ç¤ºå°å¡å…§å®¹ ===
  container.innerHTML = `
    <div class="photo-card card-popup">
      ${
        memory.photo_url
          ? `<img src="${BACKEND_URL}${memory.photo_url}" alt="ç…§ç‰‡" />`
          : `<div class="text-gray-400 italic flex items-center justify-center w-[90px] h-[90px] bg-gray-100 rounded-lg">
               (ç„¡ç…§ç‰‡)
             </div>`
      }
      <!-- å³å´æ–‡å­— -->
      <div class="info">
        <div class="title">${memory.place || "æœªå‘½ååœ°é»"}</div>
        <div class="date">${new Date(memory.created_at).toLocaleString()}</div>
        <div>${memory.text}</div>
        <div class="text-amber-600 text-xs mt-1">
          <button id="openEditBtn-card-${memory.id}" class="text-amber-600 text-xs">âœï¸ ç·¨è¼¯</button>
        </div>
      </div>

    </div>
`;

  //ç¯€é»é«˜äº®
  document.querySelectorAll(".timeline-dot").forEach(d => d.classList.remove("active"));
  // æ”¯æ´å…©ç¨®æƒ…æ³ï¼š
  // 1) é»æ“Šæ™‚é–“è»¸ä¸Šçš„ DOM buttonï¼ˆe.currentTarget ç‚ºè©² elementï¼‰
  // 2) å¾ Leaflet marker è§¸ç™¼ï¼ˆå‚³å…¥çš„ e.currentTarget ä¸æ˜¯ DOM elementï¼‰ï¼Œç”¨ memory.id æ‰¾å°æ‡‰çš„ .timeline-dot
  let targetEl = null;
  try {
    if (e && e.currentTarget && e.currentTarget.classList) {
      targetEl = e.currentTarget;
    }
  } catch (err) {
    // ignore
  }
  if (!targetEl) {
    targetEl = document.querySelector(`.timeline-dot[data-id="${memory.id}"]`);
  }
  if (targetEl && targetEl.classList) {
    targetEl.classList.add("active");
    // è‹¥ç¯€é»ä½æ–¼ä¸å¯è¦‹å€ï¼Œå¹³æ»‘æ»¾å‹•åˆ°å¯è¦–ç¯„åœ
    try { targetEl.scrollIntoView({ behavior: 'smooth', inline: 'center' }); } catch (e) {}
  }
  // ç¶å®šå¡ç‰‡å…§çš„ç·¨è¼¯æŒ‰éˆ•
  const cardEditBtn = document.getElementById(`openEditBtn-card-${memory.id}`);
  if (cardEditBtn) cardEditBtn.onclick = () => openEditModal(memory);
}

// ğŸŒŸ é–‹å•Ÿç·¨è¼¯ç•«é¢
function openEditModal(memory) {
  const modal = document.getElementById("editModal");
  const textArea = document.getElementById("editTextArea");
  const preview = document.getElementById("editPreview");

  modal.classList.remove("hidden");
  try { modal.style.display = 'flex'; modal.style.position = 'fixed'; modal.style.zIndex = '10050'; } catch (e) {}
  textArea.value = memory.text || "";
  
  if (memory.photo_url) {
    preview.src = `${BACKEND_URL}${memory.photo_url}`;
    preview.classList.remove("hidden");
  } else {
    preview.classList.add("hidden");
  }

  // ç¶å®šä¸Šå‚³äº‹ä»¶ï¼ˆguard å¯¦é«”å­˜åœ¨ï¼‰
  const upload = document.getElementById("editUpload");
  if (upload) {
    upload.onchange = async (e) => {
    try { if (e && e.preventDefault) e.preventDefault(); } catch(e) {}
    try { if (e && e.stopPropagation) e.stopPropagation(); } catch(e) {}
    const statusEl = document.getElementById('editUploadStatus');
    try {
      const file = e.target.files[0];
      if (!file) return;

      // é¡¯ç¤ºä¸Šå‚³ä¸­
      statusEl.classList.remove('hidden');
      statusEl.classList.remove('text-red-600');
      statusEl.classList.add('text-gray-600');
      statusEl.textContent = 'ä¸Šå‚³ä¸­...';

      const formData = new FormData();
      formData.append("file", file);

      const res = await fetch(`${BACKEND_URL}/api/memories/photo/${memory.id}`, {
        method: "POST",
        body: formData
      });

      if (!res.ok) {
        const txt = await res.text();
        throw new Error(txt || 'ä¸Šå‚³å¤±æ•—');
      }

      const data = await res.json();
      if (data.photo_url) {
        preview.src = `${BACKEND_URL}${data.photo_url}`;
        preview.classList.remove("hidden");
        statusEl.classList.remove('text-gray-600');
        statusEl.classList.add('text-green-600');
        statusEl.textContent = 'âœ… ç…§ç‰‡å·²ä¸Šå‚³';
      } else {
        throw new Error('ä¼ºæœå™¨æœªå›å‚³ photo_url');
      }
    } catch (err) {
      console.error('upload error', err);
      statusEl.classList.remove('text-gray-600','text-green-600');
      statusEl.classList.add('text-red-600');
      statusEl.textContent = 'âŒ ä¸Šå‚³å¤±æ•—';
    } finally {
      // ç¢ºä¿ modal ä¸æœƒåœ¨ä¸Šå‚³å¾Œæ„å¤–é—œé–‰æˆ–å°è‡´è¦–åœ–å›åˆ°é¦–é 
      try { document.getElementById('editModal').classList.remove('hidden'); } catch (e) {}
    }
    };
  } else {
    console.warn('openEditModal: editUpload element not found');
  }

  // å„²å­˜ä¿®æ”¹
  const btnSaveEl = document.getElementById("btnSaveEdit");
  if (btnSaveEl) {
    btnSaveEl.onclick = async () => {
    const newText = textArea.value.trim();
    const res = await fetch(`${BACKEND_URL}/api/memories/${memory.id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: newText })
    });

    if (res.ok) {
        showToast('âœ… å·²å„²å­˜ä¿®æ”¹ï¼', { type: 'success' });
      closeEditModal();
      await loadMemories();
    } else {
        showToast('âŒ å„²å­˜å¤±æ•—', { type: 'error' });
    }
    };
  } else {
    console.warn('openEditModal: btnSaveEdit element not found');
  }

  // è¿”å›ï¼å–æ¶ˆ
  const btnBackEl = document.getElementById("btnBackEdit");
  if (btnBackEl) btnBackEl.onclick = closeEditModal;
  const btnCancelEl = document.getElementById("btnCancelEdit");
  if (btnCancelEl) btnCancelEl.onclick = closeEditModal;
}

// ğŸŒŸ é—œé–‰ç·¨è¼¯ç•«é¢
function closeEditModal() {
  const em = document.getElementById("editModal");
  if (em) {
    em.classList.add("hidden");
    try { em.style.display = 'none'; } catch (e) {}
  }
}



renderCharacterCards();
switchView('empty');
// åˆå§‹åŒ–å…©å€‹éŒ„éŸ³æŒ‰éˆ•
setupRecorder("recordBtn", "charPrompt");   // è§’è‰²é éŒ„éŸ³
setupRecorder("recordBtnChat", "chatInput"); // èŠå¤©é éŒ„éŸ³ âœ…

// === å®‰å…¨è§¸ç™¼ï¼šç¢ºä¿åœ°åœ–èˆ‡ç¯€é»è¼‰å…¥ ===
document.addEventListener("DOMContentLoaded", () => {
  console.log("ğŸŒ DOM Loadedï¼Œåˆå§‹åŒ–æ‡‰ç”¨ç¨‹å¼");
  
  // åˆå§‹åŒ–ç¶²è·¯ç®¡ç†å™¨
  NetworkManager.setupNetworkListeners();
  console.log("ğŸŒ ç¶²è·¯ç›£è½å™¨å·²å•Ÿå‹•");
  
  // åˆå§‹åŒ–åœ°åœ–
  if (map) {
    setTimeout(() => {
      map.invalidateSize();
      loadMemories();
    }, 500);
  } else {
    console.error("âŒ map æœªåˆå§‹åŒ–");
  }
  
  // æª¢æŸ¥ä¸¦è™•ç†å¾…ä¸Šå‚³éŸ³é »
  setTimeout(async () => {
    if (NetworkManager.isOnline()) {
      await processPendingAudio();
    }
  }, 2000);
});


// === ç¶å®šç¬¬ä¸€é é€å‡ºæŒ‰éˆ• (#charSend0) åˆ°ä»˜è²» modalï¼ˆè²éŸ³â†’åœ–éœ€ä»˜è²»ï¼‰ ===
try {
  const charSendBtn = document.getElementById('charSend0');
  const payModal = document.getElementById('payModal');
  const payPreview = document.getElementById('payPreview');
  const btnConfirmPay = document.getElementById('btnConfirmPay');
  const btnCancelPay = document.getElementById('btnCancelPay');
  const charPromptEl = document.getElementById('charPrompt');

  if (charSendBtn) {
    charSendBtn.addEventListener('click', (e) => {
      console.log('charSend0 clicked');
      // æŠŠç•¶å‰çš„è¼¸å…¥æˆ–éŒ„éŸ³æ–‡å­—æ”¾åˆ°ä»˜è²»é è¦½å€
      try { payPreview.textContent = (charPromptEl && charPromptEl.value) ? charPromptEl.value : ''; } catch (err) { console.warn('payPreview set failed', err); }
      if (payModal) {
        // å¼·åˆ¶æˆå›ºå®šå®šä½ä¸¦æé«˜å±¤ç´šï¼Œé¿å…è¢«å…¶ä»–å…ƒç´ è¦†è“‹
        payModal.style.display = 'flex';
        payModal.style.position = 'fixed';
        payModal.style.zIndex = '9999';
        console.log('Opening payModal');
      } else {
        console.warn('payModal element not found');
      }
    });
  } else {
    console.warn('#charSend0 not found when binding pay modal');
  }

  if (btnCancelPay) {
    btnCancelPay.addEventListener('click', () => {
      if (payModal) payModal.style.display = 'none';
    });
  }

  if (btnConfirmPay) {
    btnConfirmPay.addEventListener('click', async () => {
      // ä»˜è²»æˆåŠŸçš„ç¤ºæ„è™•ç†ï¼šé—œé–‰ modal ä¸¦è§¸ç™¼å¯¦éš›é€å‡ºæµç¨‹
      showToast('ğŸ”“ å·²å®Œæˆä»˜è²»ï¼Œæ­£åœ¨å•Ÿç”¨åŠŸèƒ½...', { type: 'success' });
      if (payModal) payModal.style.display = 'none';

      // å˜—è©¦å¾è§’è‰²é çš„è¼¸å…¥æ¬„å–æ–‡å­—ä¸¦é€å‡ºï¼ˆè‹¥æœ‰ performChatSend å‡½å¼å‰‡å‘¼å«ï¼‰
      try {
        const txt = (charPromptEl && charPromptEl.value) ? charPromptEl.value : '';
        if (typeof performChatSend === 'function') {
          await performChatSend(txt);
        } else {
          // fallback: å»ºç«‹è¨˜æ†¶ï¼ˆä½¿ç”¨æœ¬åœ°å„²å­˜ï¼‰
          if (txt && txt.trim()) {
            // å˜—è©¦ç²å–ä½ç½®
            let currentPosition = null;
            try {
              if (navigator.geolocation) {
                const position = await new Promise((resolve, reject) => {
                  navigator.geolocation.getCurrentPosition(resolve, reject, {
                    timeout: 3000,
                    enableHighAccuracy: false
                  });
                });
                currentPosition = {
                  lat: position.coords.latitude,
                  lng: position.coords.longitude
                };
              }
            } catch (geoError) {
              console.log("ç„¡æ³•ç²å–ä½ç½®:", geoError);
            }
            
            const memoryData = {
              text: txt,
              type: 'text',
              lat: currentPosition?.lat || null,
              lng: currentPosition?.lng || null,
              place: currentPosition ? "ç•¶å‰ä½ç½®" : null
            };
            
            const saveResult = await LocalStorage.saveMemory(memoryData);
            if (saveResult && saveResult.success) {
              appendMessage('user', txt);
              const aiReply = await getAIReply(txt);
              appendMessage('ai', aiReply);
              
              showToast('âœ… å·²å°‡é€™æ®µæ–‡å­—å„²å­˜åˆ°ç”Ÿå‘½åœ°åœ–ï¼', { type: 'success' });
              await loadMemories();
              await renderTimeline();
            } else {
              showToast('âŒ å„²å­˜å¤±æ•—ï¼Œè«‹é‡è©¦', { type: 'error' });
            }
          }
        }
      } catch (err) {
        console.error('Confirm pay action failed', err);
        showToast('âŒ ä»˜è²»è™•ç†å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦', { type: 'error' });
      }
    });
  }
} catch (err) {
  console.error('bind charSend0 -> payModal failed', err);
}


// Debug helper: æª¢æŸ¥ #charSend0 æ˜¯å¦è¢«é®è“‹ï¼Œä¸¦å˜—è©¦å°‡å®ƒå¸¶åˆ°æœ€ä¸Šå±¤ä»¥æ¢å¾©å¯é»æ“Šæ€§
setTimeout(() => {
  try {
    const btn = document.getElementById('charSend0');
    if (!btn) return console.warn('#charSend0 not found in DOM during clickable-check');
    const rect = btn.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    const topEl = document.elementFromPoint(cx, cy);
    console.log('clickable-check: element at charSend0 center ->', topEl, topEl && topEl.id, topEl && topEl.className);

    // è‹¥æŒ‰éˆ•ä¸Šæ–¹çš„å…ƒç´ ä¸æ˜¯æŒ‰éˆ•æœ¬èº«æˆ–å…¶å­å­«ï¼Œè¦–ç‚ºè¢«é®è“‹
    if (topEl && topEl !== btn && !btn.contains(topEl)) {
      console.warn('charSend0 appears to be covered by:', topEl);
      // å¼·åˆ¶æå‡æŒ‰éˆ•å±¤ç´šèˆ‡å•Ÿç”¨ pointer events
      try { btn.style.position = 'relative'; } catch (e) {}
      try { btn.style.zIndex = '10001'; } catch (e) {}
      try { btn.style.pointerEvents = 'auto'; } catch (e) {}
      // ä¹Ÿæå‡çˆ¶å®¹å™¨å±¤ç´š
      try { if (btn.parentElement) btn.parentElement.style.zIndex = '10001'; } catch (e) {}
      console.log('charSend0 z-index/pointer-events adjusted to attempt to restore clickability');
    }
  } catch (err) {
    console.error('clickable-check failed', err);
  }
}, 300);

// æŠŠé—œéµ modal ç§»åˆ° body æœ«ç«¯ï¼Œé¿å…è¢«çˆ¶å®¹å™¨çš„ stacking context æˆ– overflow æ“‹ä½
try {
  ['payModal','editModal','deleteConfirm','shareModal'].forEach(id => {
    const el = document.getElementById(id);
    if (el && el.parentElement && el.parentElement !== document.body) {
      try {
        document.body.appendChild(el);
        console.log(`moved ${id} to document.body`);
        // ensure hidden modals use display:none when hidden
        if (el.classList.contains('hidden')) el.style.display = 'none';
      } catch (e) {
        console.warn('failed to move', id, e);
      }
    }
  });
} catch (err) {
  console.warn('move modals to body failed', err);
}

// Document-level click forwarder: è‹¥é»æ“Šè¢«è¦†è“‹ä½†è½åœ¨ charSend0 çš„ç¯„åœå…§ï¼Œæ›¿æŒ‰éˆ•è§¸ç™¼ click
try {
  const tryForwardClick = (e) => {
    const btn = document.getElementById('charSend0');
    if (!btn) return;
    // å¦‚æœé»æ“Šç›®æ¨™å°±æ˜¯æŒ‰éˆ•ï¼ˆæˆ–æŒ‰éˆ•å…§ï¼‰ï¼Œä¸è™•ç†
    if (e.target && (e.target === btn || btn.contains(e.target))) return;
    const rect = btn.getBoundingClientRect();
    const x = e.clientX, y = e.clientY;
    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
      console.log('document click forwarder: forwarding click to #charSend0');
      try {
        // dispatch a synthetic click on the button
        btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
      } catch (err) {
        console.error('forward click failed', err);
      }
    }
  };
  // use capture to run early
  document.addEventListener('click', tryForwardClick, true);
} catch (err) {
  console.error('add document click forwarder failed', err);
}

// Delegated handler for dynamically generated edit buttons (openEditBtn-<id>)
document.addEventListener('click', function (e) {
  try {
    const btn = e.target.closest && e.target.closest('[id^="openEditBtn-"]');
    if (!btn) return;
    const idMatch = btn.id.match(/^openEditBtn-(.+)$/);
    if (!idMatch) return;
    const midRaw = idMatch[1];
    // find memory from cache
    const mems = window._memories || [];
    let m = null;
    // support fallback ids like 'missing-<index>' produced elsewhere
    const missingMatch = String(midRaw).match(/^missing-(\d+)$/);
    if (missingMatch) {
      const idx = parseInt(missingMatch[1]);
      if (!isNaN(idx) && idx >= 0 && idx < mems.length) m = mems[idx];
    }
    if (!m) {
      m = mems.find(x => String(x.id) === String(midRaw));
    }
    if (!m) {
      // as a last resort, try numeric conversion
      const maybeNum = Number(midRaw);
      if (!isNaN(maybeNum)) m = mems.find(x => Number(x.id) === maybeNum);
    }
    if (m) {
      openEditModal(m);
    } else {
      console.warn('edit button clicked but memory not found for id', midRaw, 'memories_count=', mems.length);
    }
  } catch (err) {
    console.error('delegated edit button handler error', err);
  }
});
document.addEventListener("DOMContentLoaded", () => {
  // åˆå§‹åŒ–ç¶²è·¯ç›£è½å™¨
  console.log('ğŸŒ åˆå§‹åŒ–ç¶²è·¯ç‹€æ…‹ç›£è½å™¨');
  NetworkManager.setupNetworkListeners();
  
  // æª¢æŸ¥åˆå§‹ç¶²è·¯ç‹€æ…‹
  if (NetworkManager.isOnline()) {
    console.log('ğŸŒ ç›®å‰ç¶²è·¯ç‹€æ…‹ï¼šç·šä¸Š');
    // èƒŒæ™¯æª¢æŸ¥å¾Œç«¯é€£ç·š
    NetworkManager.checkBackendConnection().then(available => {
      console.log('ğŸ”— å¾Œç«¯é€£ç·šç‹€æ…‹:', available ? 'âœ… å¯ç”¨' : 'âŒ ä¸å¯ç”¨');
    });
  } else {
    console.log('ğŸ“± ç›®å‰ç¶²è·¯ç‹€æ…‹ï¼šé›¢ç·š');
  }
  
  const share = document.getElementById('shareModal');
  if (share && share.parentElement !== document.body) {
    document.body.appendChild(share);
    console.log("âœ… shareModal å·²ç§»å‡ºæ‰‹æ©Ÿæ¡†æ¶");
  }
  const style = document.createElement("style");
  style.textContent = `
    #shareModal { position: fixed !important; z-index: 99999 !important; }
    #shareModal > div { z-index: 100000 !important; }
  `;
  document.head.appendChild(style);
  
  // å¼·åŒ–åˆ†äº«æŒ‰éˆ•ç¶å®šï¼ˆå¤šé‡ä¿éšªï¼‰
  const shareButtons = document.querySelectorAll('button[onclick*="openShareModal"], button:contains("åˆ†äº«")');
  shareButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      console.log('Share button clicked via delegated listener');
      e.preventDefault();
      e.stopPropagation();
      openShareModal();
    });
  });
  
  // ä¹Ÿå¯ä»¥é€šéæ–‡å­—å…§å®¹æ‰¾åˆ†äº«æŒ‰éˆ•
  document.querySelectorAll('button').forEach(btn => {
    if (btn.textContent && btn.textContent.includes('åˆ†äº«')) {
      btn.addEventListener('click', (e) => {
        console.log('Share button found by text content, opening modal');
        e.preventDefault();
        e.stopPropagation();
        openShareModal();
      });
    }
  });
});

// === éŒ„éŸ³ç®¡ç†åŠŸèƒ½ ===
async function openAudioManager() {
  const modal = document.getElementById('audioManagerModal');
  modal.classList.remove('hidden');
  modal.classList.add('flex');
  
  // è¼‰å…¥çµ±è¨ˆè³‡è¨Š
  const stats = await AudioDB.getStorageStats();
  document.getElementById('audioStats').innerHTML = `
    ğŸ“Š å…± ${stats.count} å€‹éŒ„éŸ³ | ğŸ“¦ ${stats.totalSizeMB} MB | ğŸ”„ ${stats.unsyncedCount} å€‹å¾…åŒæ­¥
  `;
  
  // è¼‰å…¥éŒ„éŸ³åˆ—è¡¨
  const recordings = await AudioDB.loadAllRecordings();
  const audioList = document.getElementById('audioList');
  
  if (recordings.length === 0) {
    audioList.innerHTML = `
      <div class="text-center text-gray-500 py-8">
        ğŸ¤ é‚„æ²’æœ‰ä»»ä½•éŒ„éŸ³è¨˜éŒ„
      </div>
    `;
    return;
  }
  
  audioList.innerHTML = recordings.map(recording => `
    <div class="bg-gray-50 rounded-lg p-4 mb-3 border">
      <div class="flex justify-between items-start mb-2">
        <div class="flex-1">
          <div class="text-sm font-medium text-gray-800">
            éŒ„éŸ³ #${recording.id}
          </div>
          <div class="text-xs text-gray-500">
            ğŸ“… ${new Date(recording.date).toLocaleString()}
          </div>
          <div class="text-xs text-gray-500">
            ğŸ“Š ${(recording.size / 1024).toFixed(1)} KB | ${recording.type}
          </div>
          ${recording.transcription ? `<div class="text-sm text-blue-600 mt-1">ğŸ’¬ ${recording.transcription}</div>` : ''}
        </div>
        <div class="flex gap-2">
          <button onclick="playAudioRecord(${recording.id})" 
                  class="bg-green-500 text-white px-3 py-1 rounded text-xs hover:bg-green-600">
            â–¶ï¸ æ’­æ”¾
          </button>
          <button onclick="deleteAudioRecord(${recording.id})" 
                  class="bg-red-500 text-white px-3 py-1 rounded text-xs hover:bg-red-600">
            ğŸ—‘ï¸
          </button>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <span class="text-xs px-2 py-1 rounded ${recording.synced ? 'bg-green-100 text-green-600' : 'bg-yellow-100 text-yellow-600'}">
          ${recording.synced ? 'âœ… å·²åŒæ­¥' : 'â³ å¾…åŒæ­¥'}
        </span>
        ${recording.source ? `<span class="text-xs px-2 py-1 bg-blue-100 text-blue-600 rounded">ğŸ“ ${recording.source}</span>` : ''}
      </div>
    </div>
  `).join('');
}

function closeAudioManager() {
  const modal = document.getElementById('audioManagerModal');
  modal.classList.add('hidden');
  modal.classList.remove('flex');
}

async function playAudioRecord(recordingId) {
  try {
    showToast('ğŸ”Š æ’­æ”¾éŒ„éŸ³...', { type: 'info', duration: 1000 });
    await AudioDB.playRecording(recordingId);
  } catch (error) {
    console.error('æ’­æ”¾å¤±æ•—:', error);
    showToast('âŒ æ’­æ”¾å¤±æ•—', { type: 'error' });
  }
}

async function deleteAudioRecord(recordingId) {
  if (confirm('ç¢ºå®šè¦åˆªé™¤é€™å€‹éŒ„éŸ³å—ï¼Ÿ')) {
    try {
      await AudioDB.deleteRecording(recordingId);
      showToast('ğŸ—‘ï¸ éŒ„éŸ³å·²åˆªé™¤', { type: 'success' });
      openAudioManager(); // é‡æ–°è¼‰å…¥åˆ—è¡¨
    } catch (error) {
      console.error('åˆªé™¤å¤±æ•—:', error);
      showToast('âŒ åˆªé™¤å¤±æ•—', { type: 'error' });
    }
  }
}

async function clearAllAudio() {
  if (confirm('âš ï¸ ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰éŒ„éŸ³å—ï¼Ÿé€™å€‹æ“ä½œç„¡æ³•å¾©åŸï¼')) {
    try {
      const recordings = await AudioDB.loadAllRecordings();
      for (const recording of recordings) {
        await AudioDB.deleteRecording(recording.id);
      }
      showToast('ğŸ—‘ï¸ æ‰€æœ‰éŒ„éŸ³å·²æ¸…ç©º', { type: 'success' });
      openAudioManager(); // é‡æ–°è¼‰å…¥åˆ—è¡¨
    } catch (error) {
      console.error('æ¸…ç©ºå¤±æ•—:', error);
      showToast('âŒ æ¸…ç©ºå¤±æ•—', { type: 'error' });
    }
  }
}

// åœ¨é é¢è¼‰å…¥æ™‚åˆå§‹åŒ– IndexedDB ä¸¦åŸ·è¡Œè¨ºæ–·
document.addEventListener('DOMContentLoaded', async () => {
  console.log('ğŸš€ é é¢è¼‰å…¥å®Œæˆï¼Œé–‹å§‹åˆå§‹åŒ–...');
  
  try {
    await AudioDB.init();
    console.log('âœ… IndexedDB éŸ³é »ç®¡ç†å·²åˆå§‹åŒ–');
    
    // è¼‰å…¥æ‰€æœ‰éŒ„éŸ³æ¨™è¨˜åˆ°åœ°åœ–
    setTimeout(async () => {
      await loadAudioMarkersToMap();
    }, 1000);
    
    // å»¶é²åŸ·è¡Œè¨ºæ–·ï¼Œè®“é é¢å®Œå…¨è¼‰å…¥
    setTimeout(async () => {
      console.log('ğŸ¥ é–‹å§‹éŒ„éŸ³ç³»çµ±å®Œæ•´è¨ºæ–·...');
      await runRecordingDiagnostic();
    }, 2000);
    
  } catch (error) {
    console.error('âŒ IndexedDB åˆå§‹åŒ–å¤±æ•—:', error);
    showToast(`âŒ éŸ³é »è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—: ${error.message}`, { type: 'error', duration: 5000 });
  }
});

</script>

<!-- ğŸµ éŒ„éŸ³ç®¡ç† Modal -->
<div id="audioManagerModal" class="fixed inset-0 bg-black bg-opacity-50 z-[9999] hidden items-center justify-center">
  <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden">
    <div class="p-6 border-b">
      <div class="flex justify-between items-center">
        <h2 class="text-xl font-bold text-gray-800">ğŸµ éŒ„éŸ³ç®¡ç†</h2>
        <button onclick="closeAudioManager()" class="text-gray-500 hover:text-gray-700">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
      <div id="audioStats" class="text-sm text-gray-600 mt-2">è¼‰å…¥ä¸­...</div>
    </div>
    
    <div class="p-6 overflow-y-auto max-h-96">
      <div id="audioList">è¼‰å…¥éŒ„éŸ³ä¸­...</div>
    </div>
    
    <div class="p-4 border-t bg-gray-50">
      <button onclick="clearAllAudio()" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 text-sm">
        ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰éŒ„éŸ³
      </button>
    </div>
  </div>
</div>

</body>
</html>