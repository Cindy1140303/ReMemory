<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Re Memoryï½œAIè§’è‰²ãƒ»èŠå¤©ãƒ»ç”Ÿå‘½åœ°åœ–</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Capacitor æ ¸å¿ƒå’Œæ’ä»¶ -->
  <script type="module" src="https://unpkg.com/@capacitor/core@latest/dist/capacitor.js"></script>
  <script type="module" src="https://unpkg.com/@capacitor/camera@latest/dist/plugin.js"></script>
  <script type="module" src="https://unpkg.com/@capacitor/filesystem@latest/dist/plugin.js"></script>
  <script type="module" src="https://unpkg.com/@capacitor/preferences@latest/dist/plugin.js"></script>

  <style>
  body{background:#eaeff4;font-family:"Inter","Microsoft JhengHei",system-ui;overflow:hidden}
  .screen{position:absolute;inset:0;display:flex;flex-direction:column}
    .hidden{display:none}
  /* å¼·åˆ¶æ‰‹æ©Ÿå°ºå¯¸ï¼ˆæ¡Œé¢ç‰ˆåªé¡¯ç¤ºæ‰‹æ©Ÿè¦–çª—ï¼‰ */
  .h-app{width:360px;height:640px;background:#fff;border-radius:1.5rem;overflow:hidden;box-shadow:0 25px 50px -12px rgba(0,0,0,.25);position:relative}
  /* å¯é¸çš„å¤–æ¡†æ¨£å¼ï¼Œè®“åœ¨æ¡Œé¢ä¸Šæ›´åƒæ‰‹æ©Ÿè£ç½® */
  .device-frame { padding: 18px; display:flex; align-items:center; justify-content:center; height:100vh; box-sizing:border-box }
  
  /* çœŸå¯¦æ‰‹æ©Ÿç’°å¢ƒä¸‹å¡«æ»¿æ•´å€‹è¢å¹• */
  @media (max-width: 480px) and (pointer: coarse) {
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
    }
    .device-frame { 
      padding: 0; 
      margin: 0;
      height: 100vh;
      width: 100vw;
    }
    .h-app { 
      width: 100vw; 
      height: 100vh; 
      border-radius: 0 !important; 
      box-shadow: none; 
      max-width: none;
      max-height: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    #main-header {
      border-radius: 0 !important;
      border-top-left-radius: 0 !important;
      border-top-right-radius: 0 !important;
    }
    /* ä¿æŒæŒ‰éˆ•åœ“è§’ */
    button {
      border-radius: 0.5rem !important;
    }
    .rounded-xl {
      border-radius: 0.75rem !important;
    }
    .card {
      border-radius: 1rem !important;
    }
  }
    #map{width:100%;height:30vh;border-radius:0.5rem}
    .timeline{display:flex;align-items:center;justify-content:center;gap:48px;padding:12px 0;border-top:3px solid #a6622e;background:#fff}
    .timeline-dot{width:20px;height:20px;border-radius:50%;background:#a6622e}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:16px;box-shadow:0 2px 8px rgba(0,0,0,.06);padding:8px;cursor:pointer;transition:transform .12s ease, box-shadow .12s ease}
    .card:hover{transform:translateY(-2px);box-shadow:0 6px 14px rgba(0,0,0,.12)}
    .card img {
      width: 100%;
      height: auto;            /* ä¸å›ºå®šé«˜åº¦ï¼Œä¿æŒåŸæ¯”ä¾‹ */
      image-rendering: crisp-edges;  /* ğŸ§¡è®“åƒç´ éŠ³åˆ© */
      image-rendering: -webkit-optimize-contrast;
      border-radius: 12px;
    }
    /* ğŸ”§ ä¿®æ­£åœ°åœ–å±¤ç´šï¼Œç¢ºä¿å½ˆçª—æµ®åœ¨æœ€ä¸Šå±¤ */
    #map {
      z-index: 10 !important;
    }
    #map-view button {
      position: relative;
      z-index: 400; /* âœ… è®“æŒ‰éˆ•æµ®åœ¨åœ°åœ–ä¸Š */
      pointer-events: auto;
    }

    #chat-view .flex.flex-col.items-center.gap-4.p-4.overflow-y-auto.flex-1.mt-\[56px\] {
      flex: 0 0 auto !important;
      min-height: 260px !important;
      align-items: center !important;
      justify-content: flex-start !important;
      overflow: visible !important;
    }

    .character-container {
      width: 180px !important;
      height: 180px !important;
      min-width: 180px !important;
      min-height: 180px !important;
      flex-shrink: 0 !important;
      flex-grow: 0 !important;
      display: flex !important;
      align-items: center;
      justify-content: center;
    }

    .character-container img {
      width: 100% !important;
      height: 100% !important;
      object-fit: cover !important;
      object-position: center top !important;
      border-radius: 50% !important;
    }

    #chat-box {
      flex-grow: 1 !important;
      min-height: 220px !important;
      overflow-y: auto !important;
    }


    /* === åº•éƒ¨æ™‚é–“è»¸ === */
  .timeline-bottom {
      position: relative;
      bottom: 40px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 40px;
  /* ä¿æŒåœ¨å°å¡ä¹‹ä¸Šä½†ä¸å‡Œé§•æ–¼ modal */
      z-index: 6000;
      align-items: flex-start; /* âœ… è®“åœ“é»é ä¸Šå°é½Šç·šæ¢ */
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.0); /* âœ… å®Œå…¨é€æ˜ */
      height: auto;        /* âœ… å–æ¶ˆå›ºå®šé«˜åº¦ï¼Œé¿å…æ“ å£“ */
      padding: 6px 40px;
      overflow-x: auto;              /* âœ… å…è¨±æ©«å‘æ»¾å‹• */
      scroll-behavior: smooth;       /* âœ… å¹³æ»‘æ»¾å‹• */
      scrollbar-width: none;         /* âœ… éš±è—å·è»¸ï¼ˆFirefoxï¼‰ */
    }
    .timeline-bottom::-webkit-scrollbar {
      display: none; /* âœ… éš±è—å·è»¸ï¼ˆChromeï¼‰ */
    }


    /* === ç¯€é»æ¨£å¼ === */
  .timeline-dot {
      flex: none;           /* âœ… ä¸è¢« flex æ‹‰ä¼¸ */
      /* è®“ z-index ç”Ÿæ•ˆä¸¦å¯æµ®åœ¨æ©«ç·šä¸Šæ–¹ */
      position: relative;
      width: 40px;          /* âœ… å›ºå®šå¯¬åº¦ */
      height: 40px;         /* âœ… å›ºå®šé«˜åº¦ */
      border-radius: 50%;   /* âœ… è®Šåœ“å½¢ */
      background: radial-gradient(circle at 30% 30%, #d9b37c, #8b5e34);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      cursor: pointer;
      transition: all 0.25s ease;
      display: inline-flex;       /* âœ… è®“æŒ‰éˆ•å…§éƒ¨ä¸è¢«æ’é–‹ */
      align-items: center;
      justify-content: center;
      padding: 0 0px 0 0px;
      margin: 0 10px 0 10px;
      line-height: 0;
      /* ç¢ºä¿åœ“é»åœ¨æ©«ç·šä¹‹ä¸Šï¼Œä½†ä½æ–¼ modal */
      z-index: 7000;
    }

    /* hover ç«‹é«”æµ®èµ·æ•ˆæœ */
    .timeline-dot:hover {
      transform: translateY(-3px) scale(1.1);
      background: radial-gradient(circle at 30% 30%, #e8c58f, #a56f3c);
      box-shadow: 0 6px 3px rgba(0, 0, 0, 0.35);
      border-radius: 20px;
    }

    /* active ç‹€æ…‹ */
    .timeline-dot.active {
      transform: scale(1.3);
      background: radial-gradient(circle at 30% 30%, #ffde9b, #b36b2c);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
      border-radius: 20px;
    }
    /* === å’–å•¡è‰²æ©«ç·š === */
    .timeline-bottom::before {
      content: "";
      position: absolute; /* âœ… å½å…ƒç´ å¿…é ˆçµ•å°å®šä½ */
      top: 50%;                      /* âœ… å°é½Šç¯€é»ä¸­é–“ */
            /* âœ… ç·šåœ¨åœ“é»ä¸‹æ–¹ */
      left: 0;
      right: 0;
      height: 5px;
      width: var(--line-width, 100%);       /* âœ… è·Ÿå…§å®¹ä¸€æ¨£é•· */
      background: #a6622e;     /* â˜• å’–å•¡è‰²ä¸»é¡Œ */
      border-radius: 20px;
      opacity: 0.7;
      /* æŠŠæ©«ç·šæ”¾åˆ°è¼ƒä½å±¤ï¼Œä¸¦ä¸æ””æˆªåœ“é»äº’å‹• */
      z-index: 0;
      pointer-events: none;
      margin: 0 5px 0 5px;
    }
      /* === Leaflet marker hover æ•ˆæœ === */
    .leaflet-marker-icon {
      border-radius: 12px; /* âœ… åœ“è§’ï¼ˆå¯ä¾åœ–å½¢æ¯”ä¾‹èª¿æ•´ï¼‰ */
      overflow: hidden;    /* âœ… é˜²æ­¢é™°å½±å¤–æº¢ */
      transition: transform 0.25s ease, filter 0.25s ease, box-shadow 0.25s ease;
      transform-origin: center bottom;
    }

    .leaflet-marker-icon:hover {
      transform: scale(1.2); /* æ”¾å¤§ä¸€é» */
      filter: brightness(1.15); /* æäº® */
      box-shadow: 0 0 12px rgba(255, 190, 120, 0.8); /* å…‰æšˆæ•ˆæœ */
      z-index: 100 !important; /* ç¢ºä¿æµ®åœ¨æœ€ä¸Šå±¤ */
    }
    #editModal {
      animation: fadeIn 0.3s ease;
      /* ç¢ºä¿ç·¨è¼¯ modal æ°¸é åœ¨æœ€ä¸Šå±¤ï¼ˆé«˜æ–¼æ™‚é–“è»¸èˆ‡ç¯€é»ï¼‰ */
      z-index: 200000 !important;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }

    #editModal textarea {
      font-size: 15px;
      line-height: 1.5;
    }
    /* === ç”Ÿå‘½åœ°åœ–ä¸‹æ–¹çš„å°å¡å€å¡Š === */
    /* === å›ºå®šå°ºå¯¸ + éŸ¿æ‡‰å¼å®‰å…¨ç¯„åœçš„å°å¡ === */
    .photo-card {
      display: flex;
      flex-direction: row;       /* âœ… æ˜ç¢ºæŒ‡å®šæ©«å‘æ’åˆ— */
      align-items: center;
      justify-content: flex-start;
      background: #fff;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      gap: 12px;
      width: 90%;
      max-width: min(340px, 95vw);  /* âœ… æœ€å¤§ä¸è¶…éè¢å¹•å¯¬åº¦ */
      height: clamp(90px, 22vw, 100px);  /* âœ… æ ¹æ“šè¢å¹•è‡ªå‹•ç¸®æ”¾ */
      max-height: 100px;            /* âœ… æœ€å¤§é«˜åº¦é™åˆ¶ */
      margin: 0 auto;
      overflow: hidden;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .photo-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
    }

    /* å·¦å´åœ–ç‰‡ */
    .photo-card img {
      width: clamp(50px, 24vw, 60px);   /* âœ… åœ¨å°è¢å¹•ä¸‹è‡ªå‹•ç¸®å° */
      height: clamp(50px, 24vw, 60px);
      max-height: 60px;
      border-radius: 10px;
      object-fit: contain;          /* âœ… ç­‰æ¯”ä¾‹ç¸®å°é¡¯ç¤ºå®Œæ•´ */
      object-position: left;
      flex-shrink: 0;
      background: #ffff;
      border: 1px solid #d1d1d1;
    }

    /* å³å´æ–‡å­—å€å¡Š */
    .photo-card .info {
      display: flex;
      flex-direction: column;
      justify-content: center;   /* âœ… å‚ç›´ç½®ä¸­ */
      text-align: left;          /* âœ… æ–‡å­—é å·¦ */
      flex: 1;
      overflow: hidden;
    }

    .photo-card .info .title {
      font-weight: bold;
      color: #7a4a22;
      margin-bottom: 4px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      font-size: clamp(13px, 3.5vw, 15px); /* âœ… éŸ¿æ‡‰å¼å­—é«” */
    }

    .photo-card .info .date {
      font-size: 12px;
      color: #666;
      margin-bottom: 2px;
    }

    .photo-card .info div:last-child {
      font-size: 14px;
      color: #444;
      line-height: 1.4;
      max-height: 3.5em;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* === éŸ¿æ‡‰å¼ï¼ˆæ‰‹æ©Ÿè¢å¹• < 400pxï¼‰ === */
    @media (max-width: 400px) {
      .photo-card {
        height: 90px;
        max-width: 300px;
        gap: 8px;
        padding: 8px 10px;
      }
      .photo-card img {
        width: 70px;
        height: 70px;
      }
      .photo-card .info .title {
        font-size: 13px;
      }
      .photo-card .info div:last-child {
        font-size: 12px;
      }
    }
    #photo-card-container {
      position: relative;
      margin-top: -50px;   /* â¬†ï¸ è®“å°å¡å¾€ä¸Šé è¿‘åœ°åœ–ï¼Œä¾ä½ è¦çš„è·é›¢å¯èª¿æ•´ */
      z-index: 10;       /* âœ… æµ®åœ¨åœ°åœ–ä¸Šå±¤ */
      pointer-events: auto;
      transition: margin-top 0.3s ease;
    }

    /* å°å¡æœ¬é«”æ¨£å¼ */
    #photo-card-container .card {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 16px;
      box-shadow: 0 2px 10px #ffde9b;
      padding: 10px;
      text-align: center;
      width: 90%;
      margin: 0 auto;
      position: relative;
      z-index: 5001;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    /* hover æ•ˆæœï¼ˆå¾®æµ®èµ·ï¼‰ */
    #photo-card-container .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 18px #ffde9b;
    }


    /* å°å¡ä¸Šæµ®é¡¯ç¤º */
    .card-popup {
      animation: popup 0.4s ease forwards;
    }

    @keyframes popup {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    /* === ç¯€é»ç™¼å…‰å‹•ç•« === */
    .timeline-dot.active {
      transform: scale(1.3);
      background: radial-gradient(circle at 30% 30%, #ffde9b, #b36b2c);
      box-shadow: 
        0 0 3px rgba(255, 200, 100, 0.9);   /* ç™¼äº®æ ¸å¿ƒ */
      border-radius: 100%; /* âœ… ç¢ºä¿ä»æ˜¯åœ“å½¢ */
      transition: all 0.25s ease;
    }

    /* === åˆªé™¤æç¤ºå°è¦–çª— === */
    #deleteConfirm {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 500;
    }
    #deleteConfirm .box {
      background: #fff;
      border-radius: 1rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
      width: 90%;                 /* âœ… æ”¹ç‚ºç™¾åˆ†æ¯”ï¼Œé©é…è¢å¹• */
      max-width: 320px;           /* âœ… æœ€å¤§å¯¬åº¦é™åˆ¶ï¼Œé¿å…å¤ªå¯¬ */
      padding: 16px;
      text-align: center;
      animation: fadeIn 0.3s ease;
      box-sizing: border-box;      /* âœ… ç¢ºä¿ padding ä¸é€ æˆè¶…å¯¬ */
      word-wrap: break-word;       /* âœ… é•·å­—ä¸æ’å‡ºè¢å¹• */
    }

    /* ğŸ”¹ åœ¨æ¥µå°è¢å¹•ï¼ˆä¾‹å¦‚ iPhone SEï¼‰è‡ªå‹•ç¸®å°å­—é«”èˆ‡é–“è· */
    @media (max-width: 400px) {
      #deleteConfirm .box {
        padding: 14px;
        max-width: 90%;
      }
      #deleteConfirm .box p {
        font-size: 14px;
      }
      #deleteConfirm button {
        font-size: 14px;
        padding: 6px 12px;
      }
    }

    #deleteConfirm button {
      margin: 8px;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 600;
    }
    #deleteConfirm .confirm {
      background: #e57373;
      color: #fff;
    }
    #deleteConfirm .cancel {
      background: #ddd;
      color: #444;
    }

    .spinner{width:64px;height:64px;border-radius:50%;border:6px solid #e7e1db;border-top-color:#8b5e34;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .is-recording{animation:pulse 1s infinite;border:3px solid #ef4444}
    @keyframes pulse{0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,.7)}70%{box-shadow:0 0 0 10px rgba(239,68,68,0)}}
    /* hero-textï¼šç½®ä¸­ä¸”é è¿‘ headerï¼Œä¸‹æ–¹ç•™ç™½èˆ‡å­—é«”å¾®èª¿ä»¥åŒ¹é… UI æˆªåœ– */
    #char-empty .hero-text {
      position: absolute;
      left: 1rem;
      right: 1rem;
      top: 30rem; /* å¯å†å¾®èª¿ï¼šæ•¸å­—è¶Šå°è¶Šé ä¸Š */
      text-align: center;
      margin: 0;
      color: #7a4a22;
      font-size: 1.15rem;
      line-height: 1.6;
      font-weight: 700;
      padding: 0.4rem 0;
      pointer-events: none; /* é¿å…è“‹åˆ°ä¸‹æ–¹æŒ‰éˆ•çš„é»æ“Š */
    }
    @media (max-width: 420px) {
      #char-empty .hero-text {
        top: 2.8rem;
        font-size: 1.05rem;
      }
    }
    /* è«è˜­è¿ªç¶ è‰²æ¼¸å±¤ï¼ˆä½é£½å’Œã€ç°åŒ–ã€æŸ”å’Œï¼‰ */
    .btn-map-gradient {
      /* Morandi-inspired muted greens */
      background:#4A7056;
      color: #fdfdfd; /* ç¨å¾®åæš–çš„æ·ºè‰²æ–‡å­—ï¼Œèˆ‡è«è˜­è¿ªè‰²ç³»å”èª¿ */
      padding: 0.5rem 0.75rem;
      border-radius: 0.75rem;
      transition: transform .12s ease, box-shadow .12s ease, filter .12s ease;
      /* æ›´æŸ”å’Œçš„é™°å½±ï¼Œå¸¶ä¸€é»ç°èª¿ */
      box-shadow: 0 2px 6px rgba(60, 72, 64, 0.08);
      border: 1px solid rgba(120,130,118,0.08);
    }
    .btn-map-gradient:hover {
      transform: translateY(-1px);
      /* hover è¼•å¾®åŠ æ·±é¡è‰²è€Œä¸æ˜¯è®Šäº®ï¼Œç¬¦åˆè«è˜­è¿ªæ²‰ç©©ç‰¹æ€§ */
      filter: brightness(0.96);
      box-shadow: 0 6px 10px rgba(60,72,64,0.10);
    }
  </style>
</head>

<body class="flex items-center justify-center h-screen">
  <div class="device-frame">
    <div class="h-app">
    <!-- Headerï¼šå…¨é å…±ç”¨ -->
    <header id="main-header" 
      class="flex items-center justify-between bg-[#4a6fa5] text-white py-3 px-3 
            absolute top-0 left-0 right-0 shadow-md"
      style="z-index:8000 !important; border-radius: 0 !important;">
      <!-- è¿”å›æŒ‰éˆ• -->
      <button id="backBtn" onclick="handleBack()" class="text-sm opacity-90">â† è¿”å›</button>

      <!-- æ¨™é¡Œ -->
  <h1 id="pageTitle" class="text-lg font-semibold text-right px-12 flex-grow text-white select-none">AIè§’è‰²é¸æ“‡</h1>

      <!-- ä¸‰é»é¸å–® (åƒ…èŠå¤©ç•«é¢é¡¯ç¤º) -->
      <div id="chatMenu" class="relative">
        <button onclick="toggleDropdown('chat-dropdown')" 
          class="text-xl opacity-80 hover:bg-[#39587e] rounded-full px-2 mr-8 transition">â‹®</button>

        <!-- ä¸‹æ‹‰é¸å–® -->
        <div id="chat-dropdown" 
          class="absolute right-0 mt-3 w-28 bg-white rounded-lg shadow-xl py-1 z-20 hidden">
          <button onclick="showModal('åŠŸèƒ½æœªå¯¦ä½œï¼šèªè¨€')" 
            class="flex items-center px-4 py-2 text-sm text-gray-700 w-full text-left hover:bg-gray-100">ğŸŒ èªè¨€</button>
          <button onclick="openShareModal()" 
            class="flex items-center px-4 py-2 text-sm text-gray-700 w-full text-left hover:bg-gray-100">ğŸ”— åˆ†äº«</button>
          <button onclick="showModal('åŠŸèƒ½æœªå¯¦ä½œï¼šè¨­å®š')" 
            class="flex items-center px-4 py-2 text-sm text-gray-700 w-full text-left hover:bg-gray-100">âš™ï¸ è¨­å®š</button>
        </div>
      </div>

      <!-- é—œé–‰æŒ‰éˆ• -->
      <button class="text-lg opacity-80 ml-2" onclick="handleClose()">âœ–</button>
    </header>

  <!-- å…¨åŸŸ toastï¼ˆé¡¯ç¤ºåœ¨æ‰‹æ©Ÿæ¡†å…§ï¼‰ -->
  <div id="toast-container" class="fixed top-4 left-1/2 transform -translate-x-1/2 z-4000 hidden" style="width:88%"></div>

  <!-- ğŸŒŸ åˆ†äº«è¦–çª—ï¼ˆæ”¾åœ¨ body ä¸­ï¼Œç¢ºä¿èƒ½è¢«ä»»ä½•é é¢å‘¼å«ï¼‰ -->
  <div id="shareModal" 
    class="fixed inset-0 bg-black/40 flex items-center justify-center hidden transition" style="z-index:200100;">
    <div class="bg-white rounded-2xl w-11/12 max-w-sm p-6 shadow-2xl text-center relative mx-4">
      <h2 class="text-lg font-bold text-gray-800 mb-4">åˆ†äº«é€™å€‹é é¢</h2>
      
      <div class="flex flex-col gap-3">
        <button onclick="shareToFacebook()" 
          class="flex items-center justify-center gap-2 bg-[#1877F2] text-white font-semibold py-3 px-4 rounded-xl hover:from-purple-500 hover:to-pink-500 transition">
          <img src="https://www.svgrepo.com/show/452196/facebook-1.svg" class="w-5 h-5" alt=""> Facebook
        </button>
        <button onclick="shareToLine()" 
          class="flex items-center justify-center gap-2 bg-[#06C755] text-white font-semibold py-3 px-4 rounded-xl hover:from-purple-500 hover:to-pink-500 transition">
          <img src="https://www.line.me/static/img/icon-line_1.png" class="w-5 h-5" alt=""> LINE
        </button>
        <button onclick="copyLink()" 
          class="flex items-center justify-center gap-2 bg-gray-200 text-gray-800 font-semibold py-3 px-4 rounded-xl hover:bg-gray-300 transition">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 17l4 4 4-4m0-10l-4-4-4 4m4 14V3"/></svg>
          è¤‡è£½é€£çµ
        </button>
      </div>

      <!-- é—œé–‰æŒ‰éˆ• -->
      <button onclick="closeShareModal()" 
        class="absolute top-2 right-3 text-gray-500 hover:text-gray-800 text-lg font-bold">âœ•</button>
    </div>
  </div>



    <!-- A. åˆå§‹ç•«é¢ -->
    <section id="char-empty" class="screen">
      <div class="px-4 py-5 text-center flex-1 mt-[56px]"> <!-- é ç•™ header é«˜åº¦ -->
        <p class="text-2xl font-bold text-[#7a4a22] leading-relaxed mt-8">
          ç›®å‰ç„¡è§’è‰²<br/>å¯ä»¥åˆ©ç”¨æŒ‰éˆ•ç”Ÿæˆè§’è‰²ï½
        </p>
        <div class="mt-8">
          <textarea id="charPrompt" rows="3"
            class="w-full rounded-2xl border border-gray-300 bg-gray-100 text-gray-600 text-center p-4"
            placeholder="éŒ„éŸ³æ–‡å­—é¡¯ç¤ºå€ï½œæ­¤å€æ–‡å­—å¯ç›´æ¥ä¿®æ”¹"></textarea>
        </div>
        <div class="mt-8 flex items-center justify-center gap-10">
          <button id="recordBtn" class="px-8 py-2 rounded-xl bg-[#c08955] text-white shadow">ğŸ¤  éŒ„éŸ³</button>
          <button id="charSend0" class="px-8 py-2 rounded-xl bg-[#c08955] text-white shadow">â–¶  é€å‡º</button>
        </div>
        <div class="mt-5">
          <button id="charAuto" class="w-full py-3 rounded-xl bg-[#e7c8a3] text-[#6d492b] font-bold shadow">
            âœ¨ è‡ª å‹• ç”Ÿ æˆ
          </button>
        </div>
      </div>
    </section>

    <!-- B. è¼‰å…¥ä¸­ -->
    <section id="char-loading" class="screen hidden">
      <div class="flex flex-col items-center justify-center flex-1 gap-4 mt-[56px]">
        <div class="spinner"></div>
        <div class="text-[#7a4a22] font-semibold text-lg">è¼‰å…¥ä¸­ï¼ŒAI æ­£åœ¨ç¹ªè£½è§’è‰²ä¸­...</div>
      </div>
    </section>

    <!-- C. ä¹å®®æ ¼ -->
    <section id="char-list" class="screen hidden">
      <div class="p-4 text-center flex-1 overflow-y-auto mt-[56px]">
        <p class="text-xl font-bold text-[#7a4a22] leading-relaxed mb-3">
          ğŸ‘‹ é¸æ“‡ä½ çš„AIå¤¥ä¼´è§’è‰²ï½
        </p>
        <div id="cardGrid" class="grid grid-cols-3 gap-3"></div>
        
        <!-- è‡ªå®šç¾©è§’è‰²ä¸Šå‚³æŒ‰éˆ• -->
        <div class="mt-4 pt-4 border-t border-gray-200">
          <button id="btnUploadCustomChar" 
            class="w-full py-3 px-6 bg-gradient-to-r from-purple-400 to-pink-400 text-white font-bold rounded-xl shadow-lg hover:from-purple-500 hover:to-pink-500 transition">
            ğŸ“· ä¸Šå‚³è‡ªå®šç¾©è§’è‰²
          </button>
          <p class="text-xs text-gray-500 mt-2">å¾æ‰‹æ©Ÿç›¸ç°¿é¸æ“‡åœ–ç‰‡ä½œç‚ºä½ çš„ AI è§’è‰²</p>
        </div>
      </div>
    </section>

    <!-- D. èŠå¤© -->
    <section id="chat-view" class="screen hidden">
      <!-- èŠå¤©å…§å®¹å€ -->
      <div class="flex flex-col items-center gap-4 p-4 overflow-y-auto flex-1 mt-[56px]">
        <div class="character-container">
          <img id="chat-avatar" src="https://placehold.co/144x144/f9d853/4a6fa5?text=AI" alt="AIé ­åƒ" />
        </div>
        <div id="chat-box" class="flex flex-col gap-3 text-center text-gray-800 text-lg font-semibold leading-relaxed p-4">
          <div class="text-gray-500 text-sm">ğŸ™ é»æ“Šä¸‹æ–¹éº¥å…‹é¢¨é–‹å§‹å°è©±</div>
        </div>
      </div>

      <div class="mt-auto border-t border-gray-200 bg-white py-4 flex flex-col items-center">
        <!-- è¼¸å…¥æ¬„ï¼ˆé ä¸Šï¼‰ -->
        <textarea id="chatInput" rows="2"
          class="w-11/12 rounded-xl border border-gray-300 bg-gray-50 text-gray-700 p-3 text-sm mb-3"
          placeholder="éŒ„éŸ³æˆ–è¼¸å…¥æƒ³èªªçš„è©±..."></textarea>

        <!-- éº¥å…‹é¢¨èˆ‡é€å‡ºæŒ‰éˆ•ï¼ˆç½®ä¸­ä¸¦æ’ï¼‰ -->
        <div class="flex items-center gap-10 justify-center mb-5">
          <button id="recordBtnChat" class="px-4 py-2 flex items-center justify-center rounded-xl bg-[#d9b37c] text-white shadow">ğŸ¤éŒ„éŸ³</button>
          <button id="chatSend" class="px-4 py-2 rounded-xl bg-[#c08955] text-white shadow">â–¶ é€å‡º</button>
        </div>

        <!-- åˆ°ç”Ÿå‘½åœ°åœ–ï¼ˆåº•éƒ¨ç½®ä¸­ï¼‰ -->
        <div class="w-full flex items-center justify-center">
          <button id="toMapBtn" onclick="goToMap()" class="mb-5 px-10 py-2 btn-map-gradient">åˆ°ç”Ÿå‘½åœ°åœ–</button>
        </div>
      </div>

    </section>

    <!-- E. åœ°åœ– -->
    <section id="map-view" class="screen hidden">
      <div class="p-2 mt-[56px]">
        <div id="map"></div>
        <div class="mt-2 flex gap-2 justify-center">
          <button class="flex-1 bg-green-200 py-2 rounded opacity-80 hover:opacity-100">â—€</button>
          <button onclick="openAudioManager()" class="flex-1 bg-purple-200 py-2 rounded opacity-80 hover:opacity-100 text-sm">ğŸµ éŒ„éŸ³</button>
          <button class="flex-1 bg-green-200 py-2 rounded opacity-80 hover:opacity-100">â–¶</button>
        </div>
      </div>
      <div id="photo-card-container" class="px-3 flex-1 flex items-center justify-center text-gray-600 text-sm">
        é»æ“Šåœ°åœ–ä¸Šçš„ç”Ÿå‘½æ¨¹æ¨™è¨˜ï¼ŒæŸ¥çœ‹å›æ†¶ç…§ç‰‡ã€‚
      </div>
      <!-- ğŸŒŸ é ‚éƒ¨æ™‚é–“è»¸ -->
      <div id="timeline" class="timeline-bottom"></div>

    </section>
  <!-- ğŸŒŸ å°å¡ç·¨è¼¯ç•«é¢ -->
  <!-- æ”¹æˆ absoluteï¼Œè®“å®šä½èˆ‡å¯¬åº¦ç›¸å°æ–¼ .h-appï¼ˆå¯¬åº¦ 360px çš„æ‰‹æ©Ÿæ¡†ï¼‰ -->
  <div id="editModal" class="absolute inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 hidden">
  <div class="bg-white w-[78%] max-w-xs rounded-2xl shadow-2xl p-3 relative flex flex-col box-border">
        <h2 class="text-lg font-bold text-center text-[#7a4a22] mb-3">âœï¸ ç·¨è¼¯å›æ†¶å°å¡</h2>

        <textarea id="editTextArea" 
          class="w-full flex-1 border border-gray-300 rounded-xl p-3 text-gray-800 mb-3 resize-none"
          rows="8" placeholder="é€™è£¡é¡¯ç¤ºå®Œæ•´éŒ„éŸ³æ–‡å­—..."></textarea>

    <!-- ç…§ç‰‡é è¦½èˆ‡ä¸Šå‚³ -->
    <div class="flex flex-col items-center mb-3">
      <img id="editPreview" class="rounded-xl max-h-40 object-cover mb-2 hidden"/>
      <input type="file" id="editUpload" accept="image/*" class="text-sm"/>
      <div id="editUploadStatus" class="text-sm text-green-600 mt-2 hidden"></div>
    </div>

    <!-- æŒ‰éˆ•åˆ— -->
    <div class="flex justify-between mt-3">
      <button id="btnSaveEdit" class="bg-amber-400 text-[#5b3a17] px-4 py-2 rounded-lg font-bold">ğŸ’¾ å„²å­˜</button>
      <button id="btnCancelEdit" class="bg-red-300 text-white px-4 py-2 rounded-lg">å–æ¶ˆ</button>
    </div>
    </div>
  </div>
</div>
  <!-- ğŸŒŸ åˆªé™¤ç¢ºèªè¦–çª— -->
  <div id="deleteConfirm">
    <div class="box">
      <p class="text-lg font-bold text-[#7a4a22] mb-3">ğŸ—‘ ç¢ºå®šè¦åˆªé™¤æ­¤å›æ†¶å—ï¼Ÿ</p>
      <p class="text-sm text-gray-600 mb-4">åˆªé™¤å¾Œå°‡ç„¡æ³•å¾©åŸã€‚</p>
      <div>
        <button class="cancel" onclick="closeDeleteConfirm()">å–æ¶ˆ</button>
        <button class="confirm" onclick="confirmDelete()">åˆªé™¤</button>
      </div>
    </div>

      <!-- ğŸŒŸ ä»˜è²»ç¤ºæ„è¦–çª—ï¼ˆè²éŸ³ç”Ÿæˆåœ–ç‰‡éœ€ä»˜è²»ï¼‰ -->
      <div id="payModal" class="absolute inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-60 hidden">
        <div class="bg-white w-[86%] max-w-xs rounded-xl shadow-2xl p-4 relative flex flex-col box-border text-center">
          <h3 class="text-lg font-bold text-[#7a4a22] mb-2">ğŸ”’ éœ€è¦ä»˜è²»å•Ÿç”¨</h3>
          <p class="text-sm text-gray-600 mb-4">ä½¿ç”¨ã€Œè²éŸ³ç”¢ç”Ÿåœ–ç‰‡ã€åŠŸèƒ½éœ€ä»˜è²»è§£é–ã€‚ç¤ºæ„åƒ¹æ ¼ï¼šNT$30 / æ¬¡ã€‚</p>
          <div id="payPreview" class="text-sm text-gray-800 p-2 mb-4 bg-gray-50 rounded" style="min-height:48px;white-space:pre-wrap;text-align:left;"></div>
          <div class="flex gap-3 justify-center">
            <button id="btnConfirmPay" class="px-4 py-2 bg-[#e7c8a3] rounded-xl shadow">ä»˜è²»å•Ÿç”¨ (NT$30)</button>
            <button id="btnCancelPay" class="px-4 py-2 bg-gray-200 rounded-xl shadow">å–æ¶ˆ</button>
          </div>
        </div>
      </div>
  </div>

</div>
 

<script>    
// === å¤šé‡ API ç«¯é»è¨­å®š ===
const API_ENDPOINTS = {
  // æœ¬åœ°é–‹ç™¼ (MSSQL)
  local: "http://127.0.0.1:8010",
  
  // Vercel éƒ¨ç½² (MongoDB)
  vercel: "https://re-memory-eight.vercel.app",
  
  // ç›´æ¥ä½¿ç”¨ Hugging Face APIï¼ˆæš«æ™‚æ–¹æ¡ˆï¼‰
  huggingface: "https://api-inference.huggingface.co",
  
  // ç•¶å‰ä½¿ç”¨çš„ç«¯é» - é è¨­æ”¹æˆ vercelï¼ˆæœƒç”± NetworkManager å†æª¢æŸ¥ä¸¦å›é€€ï¼‰
  current: "vercel"
};

const BACKEND_URL = API_ENDPOINTS[API_ENDPOINTS.current];
const HF_IMAGE_URL = `${BACKEND_URL}/generate-gpt`;    // ğŸ¨ ç”Ÿåœ–ç«¯é»
const HF_PHOTO_URL = `${BACKEND_URL}/api/photo/upload`; // ğŸ–¼ ç…§ç‰‡ä¸Šå‚³
// ===== Hugging Face API è¨­å®š =====
const HF_ASR_URL = "https://api-inference.huggingface.co/models/openai/whisper-large-v3";
const HF_CHAT_URL =  `${BACKEND_URL}/api/chat`;

// === ç¶²è·¯ç‹€æ…‹ç®¡ç† ===
const NetworkManager = {
  isOnline: () => navigator.onLine,
  
  // æª¢æ¸¬å¾Œç«¯é€£ç·šç‹€æ…‹ï¼ˆæ”¯æ´å¤šå€‹ç«¯é»ï¼‰
  async checkBackendConnection() {
    if (!this.isOnline()) return false;
    
    // å˜—è©¦ä¸åŒçš„ç«¯é»
    const endpointsToTry = [
      { name: 'current', url: BACKEND_URL },
      { name: 'vercel', url: API_ENDPOINTS.vercel },
      { name: 'local', url: API_ENDPOINTS.local }
    ];
    
    for (const endpoint of endpointsToTry) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000);
        
        const response = await fetch(`${endpoint.url}/api/health`, { 
          method: 'GET',
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          console.log(`âœ… å¾Œç«¯é€£ç·šæˆåŠŸ: ${endpoint.name} (${endpoint.url})`);
          
          // å¦‚æœä¸æ˜¯ç•¶å‰ä½¿ç”¨çš„ç«¯é»ï¼Œæ›´æ–°é…ç½®
          if (endpoint.url !== BACKEND_URL) {
            console.log(`ğŸ”„ åˆ‡æ›åˆ°å¯ç”¨ç«¯é»: ${endpoint.name}`);
            // å‹•æ…‹æ›´æ–°ç«¯é»ï¼ˆå¯é¸ï¼‰
          }
          
          return { success: true, endpoint: endpoint.name, url: endpoint.url };
        }
      } catch (error) {
        console.log(`âŒ ${endpoint.name} ç«¯é»é€£ç·šå¤±æ•—:`, error.message);
        continue;
      }
    }
    
    console.log('âŒ æ‰€æœ‰å¾Œç«¯ç«¯é»éƒ½ç„¡æ³•é€£ç·š');
    return { success: false, error: 'æ‰€æœ‰å¾Œç«¯æœå‹™éƒ½ç„¡æ³•é€£ç·š' };
  },
  
  // ç¶²è·¯ç‹€æ…‹ç›£è½
  setupNetworkListeners() {
    window.addEventListener('online', () => {
      console.log('ğŸŒ ç¶²è·¯é€£ç·šæ¢å¾©');
      showToast('ğŸŒ ç¶²è·¯é€£ç·šæ¢å¾©ï¼Œæº–å‚™åŒæ­¥è³‡æ–™', { type: 'success' });
      this.syncPendingData();
    });
    
    window.addEventListener('offline', () => {
      console.log('âŒ ç¶²è·¯é€£ç·šä¸­æ–·');
      showToast('âŒ ç¶²è·¯ä¸­æ–·ï¼Œå°‡æš«å­˜åˆ°æœ¬åœ°', { type: 'info' });
    });
  },
  
  // åŒæ­¥å¾…è™•ç†è³‡æ–™
  async syncPendingData() {
    if (!this.isOnline()) return;
    
    try {
      const pendingData = await LocalStorage.getPendingSync();
      console.log('ğŸ”„ ç™¼ç¾å¾…åŒæ­¥è³‡æ–™:', pendingData.length, 'ç­†');
      
      for (const data of pendingData) {
        try {
          await this.syncToBackend(data);
          await LocalStorage.markAsSynced(data.id);
          console.log('âœ… æˆåŠŸåŒæ­¥:', data.id);
        } catch (syncError) {
          console.error('âŒ åŒæ­¥å¤±æ•—:', data.id, syncError);
        }
      }
      
      if (pendingData.length > 0) {
        showToast(`âœ… æˆåŠŸåŒæ­¥ ${pendingData.length} ç­†è³‡æ–™`, { type: 'success' });
      }
    } catch (error) {
      console.error('åŒæ­¥éç¨‹å‡ºéŒ¯:', error);
    }
  },
  
  // åŒæ­¥è³‡æ–™åˆ°å¾Œç«¯
  async syncToBackend(data) {

  // æ­£ç¢ºå¯¦ä½œ POST /api/memories
  const res = await fetch(`${BACKEND_URL}/api/memories`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
  if (!res.ok) {
    const txt = await res.text().catch(()=>`HTTP ${res.status}`);
    throw new Error(txt || `HTTP ${res.status}`);
  }
  return await res.json();
}
};
// === æœ¬åœ°å„²å­˜ç®¡ç† (for APK) ===
const LocalStorage = {
  // æª¢æŸ¥æ˜¯å¦åœ¨ Capacitor ç’°å¢ƒä¸­
  isCapacitor: () => {
    // ç°¡åŒ–æª¢æ¸¬é‚è¼¯ï¼Œç›´æ¥æª¢æŸ¥æ˜¯å¦åœ¨æ‰‹æ©Ÿç’°å¢ƒ
    return window.Capacitor || 
           (window.screen.width <= 768 && 'ontouchstart' in window) ||
           navigator.userAgent.includes('Mobile');
  },
  
  // å„²å­˜å›æ†¶è¨˜éŒ„
  async saveMemory(memoryData) {
    try {
      console.log('å˜—è©¦å„²å­˜è¨˜æ†¶:', memoryData);
      console.log('æ˜¯å¦ç‚º Capacitor ç’°å¢ƒ:', this.isCapacitor());
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        
        // ç”Ÿæˆå”¯ä¸€ ID
        const id = Date.now().toString();
        memoryData.id = id;
        memoryData.created_at = new Date().toISOString();
        
        // ç²å–ç¾æœ‰å›æ†¶åˆ—è¡¨
        const { value } = await Preferences.get({ key: 'memories' });
        const memories = value ? JSON.parse(value) : [];
        
        // æ·»åŠ æ–°å›æ†¶
        memories.push(memoryData);
        
        // å„²å­˜å›æœ¬åœ°
        await Preferences.set({
          key: 'memories',
          value: JSON.stringify(memories)
        });
        
        console.log('æˆåŠŸå„²å­˜åˆ° Capacitor Preferences');
        return { success: true, id };
      } else {
        // å›é€€åˆ° localStorage
        console.log('ä½¿ç”¨ localStorage å„²å­˜');
        const memories = JSON.parse(localStorage.getItem('memories') || '[]');
        const id = Date.now().toString();
        memoryData.id = id;
        memoryData.created_at = new Date().toISOString();
        memories.push(memoryData);
        localStorage.setItem('memories', JSON.stringify(memories));
        console.log('æˆåŠŸå„²å­˜åˆ° localStorage');
        return { success: true, id };
      }
    } catch (error) {
      console.error('å„²å­˜å›æ†¶å¤±æ•—:', error);
      return { success: false, error: error.message };
    }
  },
  
  // è¼‰å…¥æ‰€æœ‰å›æ†¶è¨˜éŒ„
  async loadMemories() {
    try {
      if (this.isCapacitor()) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'memories' });
        return value ? JSON.parse(value) : [];
      } else {
        return JSON.parse(localStorage.getItem('memories') || '[]');
      }
    } catch (error) {
      console.error('è¼‰å…¥å›æ†¶å¤±æ•—:', error);
      return [];
    }
  },
  
  // å„²å­˜ç…§ç‰‡åˆ°æœ¬åœ°æª”æ¡ˆç³»çµ±
  async savePhoto(photoBlob, filename) {
    try {
      if (this.isCapacitor()) {
        const { Filesystem } = window.Capacitor.Plugins;
        
        // å°‡ Blob è½‰æ›ç‚º base64
        const base64Data = await this.blobToBase64(photoBlob);
        
        // å„²å­˜åˆ° APP å…§éƒ¨ç›®éŒ„
        const savedFile = await Filesystem.writeFile({
          path: filename,
          data: base64Data,
          directory: 'data'
        });
        
        return savedFile.uri;
      } else {
        // æ¡Œé¢ç‰ˆæš«æ™‚è¿”å› Object URL
        return URL.createObjectURL(photoBlob);
      }
    } catch (error) {
      console.error('å„²å­˜ç…§ç‰‡å¤±æ•—:', error);
      return null;
    }
  },
  
  // Blob è½‰ base64 è¼”åŠ©å‡½æ•¸
  blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(',')[1]);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  },
  
  // æ¨¡æ“¬ AI èŠå¤©å›æ‡‰ (é›¢ç·šç‰ˆ)
  async getOfflineAIReply(text) {
    // ç°¡å–®çš„å›æ‡‰æ¨¡å¼åŒ¹é…
    const responses = {
      greeting: ["ä½ å¥½ï¼å¾ˆé«˜èˆˆå’Œä½ èŠå¤©ï¼", "å—¨ï¼ä»Šå¤©éå¾—æ€éº¼æ¨£ï¼Ÿ", "å“ˆå›‰ï¼æœ‰ä»€éº¼æƒ³èŠçš„å—ï¼Ÿ"],
      mood: ["è½èµ·ä¾†ä½ çš„å¿ƒæƒ…ä¸éŒ¯å‘¢ï¼", "æˆ‘èƒ½æ„Ÿå—åˆ°ä½ çš„æƒ…æ„Ÿï¼Œæƒ³å¤šèªªä¸€äº›å—ï¼Ÿ", "è¬è¬ä½ å’Œæˆ‘åˆ†äº«ä½ çš„æ„Ÿå—ï¼"],
      memory: ["é€™æ˜¯å¾ˆçè²´çš„å›æ†¶å‘¢ï¼", "è½èµ·ä¾†æ˜¯å€‹å¾ˆç‰¹åˆ¥çš„æ™‚åˆ»ï¼", "è¬è¬ä½ åˆ†äº«é€™å€‹ç¾å¥½çš„è¨˜æ†¶ï¼"],
      question: ["é€™æ˜¯å€‹å¾ˆæœ‰è¶£çš„å•é¡Œï¼", "è®“æˆ‘æƒ³æƒ³...", "ä½ è¦ºå¾—å‘¢ï¼Ÿæˆ‘å¾ˆæƒ³è½è½ä½ çš„æƒ³æ³•ï¼"],
      default: ["æˆ‘åœ¨ä»”ç´°è½ä½ èªªè©±ï¼", "ç¹¼çºŒå‘Šè¨´æˆ‘å§ï¼", "å—¯å—¯ï¼Œç„¶å¾Œå‘¢ï¼Ÿ", "æˆ‘æ˜ç™½ä½ çš„æ„æ€ï¼", "é€™å¾ˆæœ‰æ„æ€ï¼"]
    };
    
    // ç°¡å–®çš„é—œéµå­—åŒ¹é…
    const lowerText = text.toLowerCase();
    
    let responseType = 'default';
    if (lowerText.includes('ä½ å¥½') || lowerText.includes('å—¨') || lowerText.includes('å“ˆå›‰')) {
      responseType = 'greeting';
    } else if (lowerText.includes('å¿ƒæƒ…') || lowerText.includes('æ„Ÿè¦º') || lowerText.includes('é–‹å¿ƒ') || lowerText.includes('é›£é')) {
      responseType = 'mood';
    } else if (lowerText.includes('è¨˜å¾—') || lowerText.includes('ä»¥å‰') || lowerText.includes('é‚£æ™‚')) {
      responseType = 'memory';
    } else if (lowerText.includes('ï¼Ÿ') || lowerText.includes('?') || lowerText.includes('ç‚ºä»€éº¼') || lowerText.includes('æ€éº¼')) {
      responseType = 'question';
    }
    
    const responseList = responses[responseType];
    const randomResponse = responseList[Math.floor(Math.random() * responseList.length)];
    
    return {
      response: randomResponse,
      timestamp: new Date().toISOString()
    };
  },
  
  // === åŒæ­¥ç›¸é—œæ–¹æ³• ===
  
  // å„²å­˜å¾…åŒæ­¥è³‡æ–™
  async savePendingSync(data) {
    try {
      data.pendingSync = true;
      data.syncAttempts = 0;
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingSync' });
        const pending = value ? JSON.parse(value) : [];
        pending.push(data);
        await Preferences.set({ key: 'pendingSync', value: JSON.stringify(pending) });
      } else {
        const pending = JSON.parse(localStorage.getItem('pendingSync') || '[]');
        pending.push(data);
        localStorage.setItem('pendingSync', JSON.stringify(pending));
      }
      
      console.log('ğŸ“¤ è³‡æ–™æ¨™è¨˜ç‚ºå¾…åŒæ­¥:', data.id);
    } catch (error) {
      console.error('å„²å­˜å¾…åŒæ­¥è³‡æ–™å¤±æ•—:', error);
    }
  },
  
  // ç²å–å¾…åŒæ­¥è³‡æ–™
  async getPendingSync() {
    try {
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingSync' });
        return value ? JSON.parse(value) : [];
      } else {
        return JSON.parse(localStorage.getItem('pendingSync') || '[]');
      }
    } catch (error) {
      console.error('è¼‰å…¥å¾…åŒæ­¥è³‡æ–™å¤±æ•—:', error);
      return [];
    }
  },
  
  // æ¨™è¨˜è³‡æ–™ç‚ºå·²åŒæ­¥
  async markAsSynced(dataId) {
    try {
      const pending = await this.getPendingSync();
      const filtered = pending.filter(item => item.id !== dataId);
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        await Preferences.set({ key: 'pendingSync', value: JSON.stringify(filtered) });
      } else {
        localStorage.setItem('pendingSync', JSON.stringify(filtered));
      }
      
      console.log('âœ… è³‡æ–™æ¨™è¨˜ç‚ºå·²åŒæ­¥:', dataId);
    } catch (error) {
      console.error('æ¨™è¨˜åŒæ­¥ç‹€æ…‹å¤±æ•—:', error);
    }
  },
  
  // å„²å­˜éŸ³é »åˆ°æœ¬åœ°ï¼ˆå¾…ä¸Šå‚³ï¼‰
  async saveAudioForUpload(audioBlob, metadata) {
    try {
      const id = Date.now().toString();
      const audioData = {
        id: id,
        blob: await this.blobToBase64(audioBlob),
        metadata: metadata,
        type: 'audio',
        created_at: new Date().toISOString(),
        pendingUpload: true
      };
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingAudio' });
        const pending = value ? JSON.parse(value) : [];
        pending.push(audioData);
        await Preferences.set({ key: 'pendingAudio', value: JSON.stringify(pending) });
      } else {
        const pending = JSON.parse(localStorage.getItem('pendingAudio') || '[]');
        pending.push(audioData);
        localStorage.setItem('pendingAudio', JSON.stringify(pending));
      }
      
      console.log('ğŸ¤ éŸ³é »å·²æš«å­˜ï¼Œç­‰å¾…ä¸Šå‚³:', id);
      return { success: true, id: id };
    } catch (error) {
      console.error('å„²å­˜éŸ³é »å¤±æ•—:', error);
      return { success: false, error: error.message };
    }
  },
  
  // ç²å–å¾…ä¸Šå‚³éŸ³é »
  async getPendingAudio() {
    try {
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'pendingAudio' });
        return value ? JSON.parse(value) : [];
      } else {
        return JSON.parse(localStorage.getItem('pendingAudio') || '[]');
      }
    } catch (error) {
      console.error('è¼‰å…¥å¾…ä¸Šå‚³éŸ³é »å¤±æ•—:', error);
      return [];
    }
  },
  
  // ç§»é™¤å·²è™•ç†çš„éŸ³é »
  async removeProcessedAudio(audioId) {
    try {
      const pending = await this.getPendingAudio();
      const filtered = pending.filter(item => item.id !== audioId);
      
      if (this.isCapacitor() && window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        await Preferences.set({ key: 'pendingAudio', value: JSON.stringify(filtered) });
      } else {
        localStorage.setItem('pendingAudio', JSON.stringify(filtered));
      }
      
      console.log('ğŸ—‘ï¸ å·²è™•ç†éŸ³é »å·²ç§»é™¤:', audioId);
    } catch (error) {
      console.error('ç§»é™¤éŸ³é »å¤±æ•—:', error);
    }
  }
};


// === IndexedDB éŸ³é »å„²å­˜ç®¡ç† ===
const AudioDB = {
  dbName: 'LifeMapAudioDB',
  version: 1,
  
  // æª¢æŸ¥ IndexedDB æ”¯æ´
  checkSupport() {
    const supported = !!window.indexedDB;
    console.log('ğŸ” IndexedDB æ”¯æ´ç‹€æ…‹:', supported);
    console.log('ğŸ” ç€è¦½å™¨è³‡è¨Š:', navigator.userAgent);
    
    if (!supported) {
      showToast('âŒ æ­¤ç€è¦½å™¨ä¸æ”¯æ´ IndexedDB', { type: 'error', duration: 5000 });
      return false;
    }
    return true;
  },
  
  // åˆå§‹åŒ– IndexedDB
  async init() {
    console.log('ğŸµ å˜—è©¦åˆå§‹åŒ– IndexedDB...');
    
    if (!this.checkSupport()) {
      throw new Error('IndexedDB ä¸æ”¯æ´');
    }
    
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = (event) => {
        console.error('âŒ IndexedDB åˆå§‹åŒ–å¤±æ•—:', event.target.error);
        showToast('âŒ éŸ³é »è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—', { type: 'error', duration: 5000 });
        reject(request.error);
      };
      
      request.onsuccess = (event) => {
        console.log('âœ… IndexedDB é€£ç·šæˆåŠŸ');
        resolve(request.result);
      };
      
      request.onupgradeneeded = (event) => {
        console.log('ğŸ”„ å‡ç´š IndexedDB çµæ§‹...');
        const db = event.target.result;
        
        try {
          // å‰µå»ºéŒ„éŸ³å„²å­˜è¡¨
          if (!db.objectStoreNames.contains('recordings')) {
            const store = db.createObjectStore('recordings', { 
              keyPath: 'id', 
              autoIncrement: true 
            });
            store.createIndex('timestamp', 'timestamp', { unique: false });
            store.createIndex('type', 'type', { unique: false });
            console.log('âœ… éŒ„éŸ³è³‡æ–™è¡¨å·²å»ºç«‹');
          }
          
          console.log('âœ… IndexedDB éŸ³é »è³‡æ–™åº«å‡ç´šå®Œæˆ');
          showToast('âœ… éŸ³é »è³‡æ–™åº«å·²æº–å‚™å°±ç·’', { type: 'success', duration: 2000 });
        } catch (upgradeError) {
          console.error('âŒ è³‡æ–™åº«å‡ç´šå¤±æ•—:', upgradeError);
          showToast('âŒ è³‡æ–™åº«å‡ç´šå¤±æ•—', { type: 'error', duration: 5000 });
        }
      };
    });
  },
  
  // å„²å­˜éŒ„éŸ³åˆ° IndexedDB
  async saveRecording(audioBlob, metadata = {}) {
    console.log('ğŸ¤ é–‹å§‹å„²å­˜éŒ„éŸ³åˆ° IndexedDB...');
    console.log('ğŸ“Š éŸ³é » Blob è³‡è¨Š:', {
      size: audioBlob.size,
      type: audioBlob.type,
      isBlob: audioBlob instanceof Blob
    });
    
    try {
      const db = await this.init();
      console.log('âœ… è³‡æ–™åº«é€£ç·šæˆåŠŸ');
      
      const transaction = db.transaction(['recordings'], 'readwrite');
      const store = transaction.objectStore('recordings');
      
      const recordingData = {
        timestamp: Date.now(),
        date: new Date().toISOString(),
        audio: audioBlob, // ç›´æ¥å„²å­˜ Blob
        type: audioBlob.type || 'audio/webm',
        size: audioBlob.size,
        duration: metadata.duration || null,
        transcription: metadata.transcription || null,
        location: metadata.location || null,
        latitude: metadata.latitude || null,
        longitude: metadata.longitude || null,
        place_name: metadata.place_name || null,
        memory_id: metadata.memory_id || null,
        source: metadata.source || 'unknown',
        synced: false
      };
      
      console.log('ğŸ“ æº–å‚™å„²å­˜çš„è³‡æ–™:', {
        ...recordingData,
        audio: `[Blob ${audioBlob.size} bytes]`
      });
      
      const request = store.add(recordingData);
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          const recordId = request.result;
          console.log('âœ… éŒ„éŸ³å·²å„²å­˜åˆ° IndexedDB, ID:', recordId);
          showToast(`âœ… éŒ„éŸ³å·²å„²å­˜ (ID: ${recordId})`, { type: 'success', duration: 2000 });
          
          // ğŸ—ºï¸ å¦‚æœæœ‰åœ°ç†ä½ç½®ï¼ŒåŠ åˆ°åœ°åœ–ä¸Š
          if (metadata.latitude && metadata.longitude) {
            addAudioMarkerToMap(recordId, metadata.latitude, metadata.longitude, metadata.place_name);
          }
          
          resolve({ success: true, id: recordId, data: recordingData });
        };
        
        request.onerror = (event) => {
          console.error('âŒ IndexedDB å„²å­˜è«‹æ±‚å¤±æ•—:', event.target.error);
          showToast('âŒ éŒ„éŸ³å„²å­˜å¤±æ•—', { type: 'error', duration: 3000 });
          reject(request.error);
        };
      });
      
    } catch (error) {
      console.error('âŒ IndexedDB å„²å­˜éç¨‹å¤±æ•—:', error);
      showToast(`âŒ å„²å­˜å¤±æ•—: ${error.message}`, { type: 'error', duration: 5000 });
      return { success: false, error: error.message };
    }
  },
  
  // è¼‰å…¥æ‰€æœ‰éŒ„éŸ³
  async loadAllRecordings() {
    try {
      const db = await this.init();
      const transaction = db.transaction(['recordings'], 'readonly');
      const store = transaction.objectStore('recordings');
      const request = store.getAll();
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          console.log('ğŸµ è¼‰å…¥', request.result.length, 'å€‹éŒ„éŸ³');
          resolve(request.result);
        };
        request.onerror = () => reject(request.error);
      });
      
    } catch (error) {
      console.error('è¼‰å…¥éŒ„éŸ³å¤±æ•—:', error);
      return [];
    }
  },
  
  // æ’­æ”¾éŒ„éŸ³
  async playRecording(recordingId) {
    try {
      const db = await this.init();
      const transaction = db.transaction(['recordings'], 'readonly');
      const store = transaction.objectStore('recordings');
      const request = store.get(recordingId);
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          if (request.result) {
            const audioBlob = request.result.audio;
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            audio.onended = () => URL.revokeObjectURL(audioUrl);
            audio.play().then(() => {
              console.log('ğŸ”Š æ’­æ”¾éŒ„éŸ³ ID:', recordingId);
              resolve(audio);
            }).catch(reject);
            
          } else {
            reject(new Error('éŒ„éŸ³ä¸å­˜åœ¨'));
          }
        };
        request.onerror = () => reject(request.error);
      });
      
    } catch (error) {
      console.error('æ’­æ”¾éŒ„éŸ³å¤±æ•—:', error);
      throw error;
    }
  },
  
  // åˆªé™¤éŒ„éŸ³
  async deleteRecording(recordingId) {
    try {
      const db = await this.init();
      const transaction = db.transaction(['recordings'], 'readwrite');
      const store = transaction.objectStore('recordings');
      const request = store.delete(recordingId);
      
      return new Promise((resolve, reject) => {
        request.onsuccess = () => {
          console.log('ğŸ—‘ï¸ éŒ„éŸ³å·²åˆªé™¤ ID:', recordingId);
          resolve(true);
        };
        request.onerror = () => reject(request.error);
      });
      
    } catch (error) {
      console.error('åˆªé™¤éŒ„éŸ³å¤±æ•—:', error);
      return false;
    }
  },
  
  // ç²å–å„²å­˜çµ±è¨ˆ
  async getStorageStats() {
    try {
      const recordings = await this.loadAllRecordings();
      const totalSize = recordings.reduce((sum, r) => sum + (r.size || 0), 0);
      const totalCount = recordings.length;
      
      return {
        count: totalCount,
        totalSize: totalSize,
        totalSizeMB: (totalSize / 1024 / 1024).toFixed(2),
        unsyncedCount: recordings.filter(r => !r.synced).length
      };
      
    } catch (error) {
      console.error('ç²å–çµ±è¨ˆå¤±æ•—:', error);
      return { count: 0, totalSize: 0, totalSizeMB: '0', unsyncedCount: 0 };
    }
  }
};

// === éŒ„éŸ³åŠŸèƒ½ï¼šæ¸¬è©¦ç”¨ï¼ˆå¯åˆªé™¤ï¼‰===
async function testAudioDB() {
  try {
    console.log('ğŸµ æ¸¬è©¦ AudioDB åŠŸèƒ½');
    
    // æ¸…ç©ºæ¸¬è©¦è³‡æ–™
    const allRecordings = await AudioDB.loadAllRecordings();
    for (const rec of allRecordings) {
      await AudioDB.deleteRecording(rec.id);
    }
    console.log('âœ… æ¸…ç©ºèˆŠçš„æ¸¬è©¦è³‡æ–™');
    
    // æ–°å¢æ¸¬è©¦éŒ„éŸ³
    const testBlob = new Blob([new Uint8Array([/* ...some dummy audio data... */])], { type: 'audio/webm' });
    const testMeta = {
      timestamp: Date.now(),
      date: new Date().toISOString(),
      audio: testBlob,
      type: 'audio/webm',
      size: testBlob.size,
      duration: 5,
      transcription: 'é€™æ˜¯ä¸€æ®µæ¸¬è©¦éŒ„éŸ³',
      location: 'æ¸¬è©¦ä½ç½®',
      latitude: 25.0478,
      longitude: 121.5319,
      place_name: 'å°åŒ—å¸‚',
      memory_id: 'test-memory-id',
      source: 'test',
      synced: false
    };
    
    const saveResult = await AudioDB.saveRecording(testBlob, testMeta);
    console.log('âœ… æ–°å¢æ¸¬è©¦éŒ„éŸ³ï¼ŒID:', saveResult.id);
    
    // æ’­æ”¾æ¸¬è©¦éŒ„éŸ³
    setTimeout(() => {
      AudioDB.playRecording(saveResult.id).catch(console.error);
    }, 1000);
    
    // è¼‰å…¥ä¸¦é¡¯ç¤ºæ‰€æœ‰éŒ„éŸ³
    const allResults = await AudioDB.loadAllRecordings();
    console.log('ğŸ“‹ ç•¶å‰æ‰€æœ‰éŒ„éŸ³:', allResults);
    
  } catch (error) {
    console.error('âŒ æ¸¬è©¦ AudioDB ç™¼ç”ŸéŒ¯èª¤:', error);
  }
}
// testAudioDB(); // å¯ç”¨æ–¼æ¸¬è©¦ï¼Œå®Œæˆå¾Œå¯è¨»è§£æˆ–åˆªé™¤

// === åœ°åœ– ===
// ä½¿ç”¨ä¿è­·å¼åˆå§‹åŒ–ï¼Œé¿å…åœ¨é–‹ç™¼æˆ–ç†±é‡è¼‰æœŸé–“é‡è¤‡å»ºç«‹ Leaflet åœ°åœ–
let map;
if (window.__lifeMap && window.__lifeMap instanceof L.Map) {
  console.log('é‡ç”¨å·²å­˜åœ¨çš„ Leaflet map instance');
  map = window.__lifeMap;
} else {
  map = L.map('map', { attributionControl: false }).setView([23.9739, 120.9820], 8);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
  // æš«å­˜æ–¼ window ä»¥ä¾¿æœªä¾†é‡ç”¨ï¼ˆä¾‹å¦‚ç†±é‡è¼‰æˆ–è…³æœ¬è¢«å¤šæ¬¡åŸ·è¡Œï¼‰
  window.__lifeMap = map;
}

// ğŸŒŸ è‡ªè¨‚ marker åœ–ç¤ºï¼ˆå¿…é ˆæ”¾åœ¨æœ€å‰é¢ï¼ï¼‰
const customIcon = L.icon({
  iconUrl: "assets/marker.png",
  iconSize: [30, 30],
  iconAnchor: [22, 44],
  popupAnchor: [0, -40]
});


// === é é¢åˆ‡æ› ===
const views = {
  empty: document.getElementById('char-empty'),
  loading: document.getElementById('char-loading'),
  list: document.getElementById('char-list'),
  chat: document.getElementById('chat-view'),
  map: document.getElementById('map-view')
};
const pageTitle = document.getElementById('pageTitle');
const chatMenu = document.getElementById('chatMenu');

let currentView = "empty";

// åˆ‡æ›ç•«é¢ä¸¦æ›´æ–°æ¨™é¡Œ + ä¸‰é»é¸å–®é¡¯ç¤ºç‹€æ…‹
function switchView(name) {
  currentView = name;
  for (const key in views) {
    views[key].classList.add("hidden");
  }
  views[name].classList.remove("hidden");

  // å‹•æ…‹æ›´æ–°æ¨™é¡Œï¼ˆä¿ç•™ chatMenu åœ¨æ‰€æœ‰é é¢å¯è¦‹ï¼‰
  switch (name) {
    case "empty":
    case "loading":
    case "list":
      pageTitle.textContent = "AIè§’è‰²é¸æ“‡";
      break;
    case "chat":
      pageTitle.textContent = "èŠå¤©å¹³å°";
      break;
    case "map":
      pageTitle.textContent = "ç”Ÿå‘½åœ°åœ–";
      break;
  }

  // åœ°åœ–é‡ç¹ª
  if (name === "map") {
    setTimeout(() => map.invalidateSize(), 200);
    loadMemories();      // âœ… æ¯æ¬¡åˆ‡æ›åœ°åœ–æ™‚è¼‰å…¥å›æ†¶
    renderTimeline();    // âœ… åŒæ­¥ç”Ÿæˆåº•éƒ¨ç¯€é»
  }

  // ç¢ºä¿ä¸‰é»é¸å–®ï¼ˆ#chatMenuï¼‰åœ¨æ‰€æœ‰é é¢éƒ½å¯è¦‹
  try { if (chatMenu) chatMenu.classList.remove('hidden'); } catch (e) {}
}

// è¿”å›é‚è¼¯
function handleBack() {
  if (currentView === "map") {
    switchView("chat");
  } else if (currentView === "chat") {
    // å›åˆ°è§’è‰²åˆ—è¡¨é ï¼ˆè€Œä¸æ˜¯ characterï¼‰
    switchView("list");
  } else if (currentView === "list" || currentView === "loading") {
    switchView("empty");
  } else {
    showToast('ç›®å‰å·²åœ¨æœ€å‰é ', { duration: 1800 });
  }
}

  // === ä¸‰é»é¸å–®é¡¯ç¤º / éš±è— ===
function toggleDropdown(id) {
  const dropdown = document.getElementById(id);
  // å…ˆé—œæ‰å…¶ä»– dropdownï¼ˆé¿å…é‡ç–Šï¼‰
  document.querySelectorAll('.dropdown, [id$="-dropdown"]').forEach(el => {
    if (el !== dropdown) el.classList.add('hidden');
  });
  // åˆ‡æ›ç•¶å‰ dropdown é¡¯ç¤º
  dropdown.classList.toggle('hidden');
}
// é–‹é—œåˆ†äº«è¦–çª— - å¼·ç¡¬åŒ–ç‰ˆæœ¬
function openShareModal() {
  try {
    console.log('openShareModal: attempting to show share modal');
    const el = document.getElementById("shareModal");
    if (!el) {
      console.error('openShareModal: shareModal element not found in DOM');
      return;
    }

    // å¼·åˆ¶ç§»å‹•åˆ° body æœ€å¾Œï¼ˆç¢ºä¿ä¸è¢«å…¶ä»–å®¹å™¨é™åˆ¶ï¼‰
    if (el.parentElement !== document.body) {
      document.body.appendChild(el);
      console.log('openShareModal: moved shareModal to document.body');
    }

    // å¼·ç¡¬è¨­å®šæ‰€æœ‰å¿…è¦å±¬æ€§
    el.classList.remove("hidden");
    el.style.display = 'flex';
    el.style.position = 'fixed';
    el.style.top = '0';
    el.style.left = '0';
    el.style.width = '100%';
    el.style.height = '100%';
    el.style.zIndex = '2147483647'; // æœ€é«˜ z-index
    el.style.pointerEvents = 'auto';
    el.style.opacity = '1';
    el.style.visibility = 'visible';
    el.style.background = 'rgba(0, 0, 0, 0.4)';
    el.style.alignItems = 'center';
    el.style.justifyContent = 'center';

    // ç¢ºä¿å…§éƒ¨ modal å…§å®¹åœ¨æ‰‹æ©Ÿä¸Šå¯è¦‹
    const modalContent = el.querySelector('div');
    if (modalContent) {
      modalContent.style.maxWidth = '90vw';
      modalContent.style.maxHeight = '90vh';
      modalContent.style.overflow = 'auto';
      modalContent.style.margin = '0 16px';
    }

    // æš«æ™‚ç¦ç”¨å…¶ä»–é«˜å±¤ç´šå…ƒç´ çš„äº’å‹•ï¼ˆé˜²æ­¢è¢«é®æ“‹ï¼‰
    const highZElements = document.querySelectorAll('[style*="z-index"]');
    highZElements.forEach(elem => {
      if (elem !== el && elem.style.zIndex && parseInt(elem.style.zIndex) > 10000) {
        elem.setAttribute('data-temp-pointer-events', elem.style.pointerEvents || 'auto');
        elem.style.pointerEvents = 'none';
      }
    });

    console.log('openShareModal: modal should now be visible with highest z-index and responsive design');
  } catch (e) { 
    console.error('openShareModal failed', e); 
  }
}

function closeShareModal() {
  try {
    const el = document.getElementById("shareModal");
    if (!el) return;
    
    el.classList.add("hidden");
    el.style.display = 'none';
    
    // æ¢å¾©å…¶ä»–å…ƒç´ çš„ pointer-events
    const tempElements = document.querySelectorAll('[data-temp-pointer-events]');
    tempElements.forEach(elem => {
      elem.style.pointerEvents = elem.getAttribute('data-temp-pointer-events');
      elem.removeAttribute('data-temp-pointer-events');
    });
    
    console.log('closeShareModal: modal hidden and restored other elements');
  } catch (e) { 
    console.error('closeShareModal failed', e); 
  }
}

// åˆ†äº«åŠŸèƒ½
function shareToFacebook() {
  const url = encodeURIComponent(window.location.href);
  const fbURL = `https://www.facebook.com/sharer/sharer.php?u=${url}`;
  window.open(fbURL, "_blank", "width=600,height=500");
}

function shareToLine() {
  const url = encodeURIComponent(window.location.href);
  const text = encodeURIComponent("å’Œæˆ‘ä¸€èµ·é«”é©—é€™å€‹ AI äº’å‹•å§ï¼");
  const lineURL = `https://social-plugins.line.me/lineit/share?url=${url}&text=${text}`;
  window.open(lineURL, "_blank", "width=600,height=500");
}

function copyLink() {
  const url = window.location.href;
  navigator.clipboard.writeText(url).then(() => {
    showToast('âœ”ï¸ å·²è¤‡è£½é€£çµåˆ°å‰ªè²¼ç°¿ï¼', { type: 'success' });
  }).catch(err => {
    showToast('âŒ è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½ã€‚', { type: 'error' });
    console.error(err);
  });
}

// é€šç”¨çš„ç°¡å–®æç¤º modalï¼ˆå ä½ï¼‰
function showModal(message) {
  // è‹¥æœªå®šç¾©è©³ç´° modalï¼Œä½¿ç”¨ alert ä½œç‚ºå›é€€
  try {
    // è‹¥æœªä¾†è¦åšæ›´æ¼‚äº®çš„ modalï¼Œå¯åœ¨æ‰‹æ©Ÿæ¡†å…§é¡¯ç¤º toast
    showToast(message, { duration: 2500 });
  } catch (e) {
    console.log('showModal:', message);
  }
}


// è‹¥é»æ“Šå¤–éƒ¨å€åŸŸï¼Œå‰‡è‡ªå‹•é—œé–‰ä¸‹æ‹‰é¸å–®
window.addEventListener('click', function (e) {
  const menuBtn = e.target.closest('button[onclick^="toggleDropdown"]');
  const dropdown = e.target.closest('.dropdown, [id$="-dropdown"]');
  if (!menuBtn && !dropdown) {
    document.querySelectorAll('.dropdown, [id$="-dropdown"]').forEach(el => el.classList.add('hidden'));
  }
});

// ======= Toast (åœ¨æ‰‹æ©Ÿæ¡†å…§é¡¯ç¤ºéé˜»å¡æç¤º) =======
function showToast(message, opts = {}) {
  const container = document.getElementById('toast-container');
  if (!container) return;
  const id = `toast-${Date.now()}`;
  const type = opts.type || 'info';
  const duration = opts.duration || 3000;

  const el = document.createElement('div');
  el.id = id;
  el.className = 'px-4 py-2 rounded-lg text-sm shadow-md mb-2 text-white';
  el.style.transition = 'opacity 200ms ease, transform 200ms ease';
  el.style.opacity = '0';
  el.style.transform = 'translateY(-6px)';

  if ( type === 'success') el.style.background = '#16a34a';
  else if (type === 'error') el.style.background = '#dc2626';
  else el.style.background = '#374151';

  el.innerText = message;
  container.appendChild(el);
  container.classList.remove('hidden');

  // animate in
  requestAnimationFrame(() => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });

  setTimeout(() => {
    // animate out
    el.style.opacity = '0'; el.style.transform = 'translateY(-6px)';
    setTimeout(() => { try { container.removeChild(el); } catch (e) {} }, 250);
  }, duration);
}


  // é—œé–‰æŒ‰éˆ•
  function handleClose() {
    if (confirm("ç¢ºå®šè¦é—œé–‰å—ï¼Ÿ")) window.close();
  }

    // === æ¨¡æ“¬è§’è‰²ç”Ÿæˆ ===
    const charAuto=document.getElementById('charAuto');
    const cardGrid=document.getElementById('cardGrid');
    charAuto.onclick=()=>{switchView('loading');setTimeout(()=>{renderCharacterCards();switchView('list');},2000);};

    const demoCharacters=[
      {name:"é˜¿é’",img:"assets/char1.png"},
      {name:"é˜¿ç¦",img:"assets/char2.png"},
      {name:"å°å…‰",img:"assets/char3.png"},
      {name:"å°ç¶ ",img:"assets/char4.png"},
      {name:"å…ƒæ°£å›",img:"assets/char5.png"},
      {name:"æš–æš–",img:"assets/char6.png"},
      {name:"é˜¿å“²",img:"assets/char7.png"},
      {name:"å°å¤",img:"assets/char8.png"},
      {name:"é˜¿å‹‡",img:"assets/char9.png"}
    ];

    function renderCharacterCards(){
      cardGrid.innerHTML='';
      demoCharacters.forEach(c=>{
        const el=document.createElement('div');
        el.className='card';
        el.innerHTML=`<img src="${c.img}" alt="${c.name}">
                      <div class="pt-1 text-center font-bold text-sm">${c.name}</div>`;
        el.onclick=()=>selectCharacter(c);
        cardGrid.appendChild(el);
      });
    }
  function selectCharacter(c) {
    const chatAvatar = document.getElementById("chat-avatar");
    const chatBox = document.getElementById("chat-box");

    // æ›´æ–°é ­åƒèˆ‡å°è©±æ–‡å­—
    chatAvatar.src = c.img;
    chatBox.innerHTML = `
      <div class="text-gray-800 font-semibold text-lg">
        å—¨ï¼æˆ‘æ˜¯ ${c.name} ï½ ä¸€èµ·èŠèŠå§ï¼
      </div>
    `;

    // åˆ‡æ›åˆ°èŠå¤©é 
    switchView("chat");
  }

  // === è‡ªå®šç¾©è§’è‰²ä¸Šå‚³åŠŸèƒ½ ===
  const btnUploadCustomChar = document.getElementById('btnUploadCustomChar');
  
  // å„²å­˜è‡ªå®šç¾©è§’è‰²åˆ°æœ¬åœ°
  async function saveCustomCharacter(imagePath, characterName) {
    try {
      if (window.Capacitor && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        
        // ç²å–ç¾æœ‰è‡ªå®šç¾©è§’è‰²åˆ—è¡¨
        const { value } = await Preferences.get({ key: 'customCharacters' });
        const customChars = value ? JSON.parse(value) : [];
        
        // æ·»åŠ æ–°è§’è‰²
        const newChar = {
          name: characterName,
          img: imagePath,
          isCustom: true
        };
        customChars.push(newChar);
        
        // å„²å­˜å›æœ¬åœ°
        await Preferences.set({
          key: 'customCharacters',
          value: JSON.stringify(customChars)
        });
        
        return newChar;
      }
    } catch (error) {
      console.error('å„²å­˜è‡ªå®šç¾©è§’è‰²å¤±æ•—:', error);
    }
    return null;
  }
  
  // è¼‰å…¥è‡ªå®šç¾©è§’è‰²
  async function loadCustomCharacters() {
    try {
      if (window.Capacitor && window.Capacitor.Plugins.Preferences) {
        const { Preferences } = window.Capacitor.Plugins;
        const { value } = await Preferences.get({ key: 'customCharacters' });
        return value ? JSON.parse(value) : [];
      }
    } catch (error) {
      console.error('è¼‰å…¥è‡ªå®šç¾©è§’è‰²å¤±æ•—:', error);
    }
    return [];
  }
  
  // ä¸Šå‚³è‡ªå®šç¾©è§’è‰²
  async function handleCustomCharacterUpload() {
    try {
      if (!window.Capacitor || !window.Capacitor.Plugins.Camera) {
        alert('æ­¤åŠŸèƒ½éœ€è¦åœ¨æ‰‹æ©Ÿ APP ä¸­ä½¿ç”¨');
        return;
      }
      
      const { Camera } = window.Capacitor.Plugins;
      const { Filesystem } = window.Capacitor.Plugins;
      
      // é¡¯ç¤ºé¸æ“‡ä¾†æºçš„å°è©±æ¡†
      const source = await new Promise((resolve) => {
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:10000;display:flex;align-items:center;justify-content:center;';
        modal.innerHTML = `
          <div style="background:white;padding:20px;border-radius:10px;text-align:center;max-width:300px;margin:20px;">
            <h3 style="margin-bottom:20px;color:#333;">é¸æ“‡åœ–ç‰‡ä¾†æº</h3>
            <button id="cameraBtn" style="width:100%;padding:12px;margin:5px 0;background:#007AFF;color:white;border:none;border-radius:8px;font-size:16px;">ğŸ“· æ‹ç…§</button>
            <button id="galleryBtn" style="width:100%;padding:12px;margin:5px 0;background:#34C759;color:white;border:none;border-radius:8px;font-size:16px;">ğŸ–¼ï¸ ç›¸ç°¿</button>
            <button id="cancelBtn" style="width:100%;padding:12px;margin:5px 0;background:#FF3B30;color:white;border:none;border-radius:8px;font-size:16px;">âŒ å–æ¶ˆ</button>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        modal.querySelector('#cameraBtn').onclick = () => {
          document.body.removeChild(modal);
          resolve('camera');
        };
        modal.querySelector('#galleryBtn').onclick = () => {
          document.body.removeChild(modal);
          resolve('gallery');
        };
        modal.querySelector('#cancelBtn').onclick = () => {
          document.body.removeChild(modal);
          resolve(null);
        };
      });
      
      if (!source) return;
      
      // æ‹ç…§æˆ–å¾ç›¸ç°¿é¸æ“‡
      const image = await Camera.getPhoto({
        quality: 80,
        allowEditing: true,
        resultType: 'uri',
        source: source === 'camera' ? 'camera' : 'photos'
      });
      
      // è©¢å•è§’è‰²åç¨±
      const characterName = prompt('è«‹è¼¸å…¥è§’è‰²åç¨±:', 'æˆ‘çš„è§’è‰²') || 'æˆ‘çš„è§’è‰²';
      
      // å„²å­˜åœ–ç‰‡åˆ° APP å…§éƒ¨ç›®éŒ„
      const fileName = `custom_char_${Date.now()}.jpg`;
      const savedFile = await Filesystem.copy({
        from: image.webPath,
        to: fileName,
        directory: 'data'
      });
      
      // å„²å­˜è§’è‰²è³‡è¨Š
      const customChar = await saveCustomCharacter(savedFile.uri, characterName);
      
      if (customChar) {
        // é‡æ–°æ¸²æŸ“è§’è‰²å¡ç‰‡ï¼ˆåŒ…å«è‡ªå®šç¾©è§’è‰²ï¼‰
        await renderAllCharacterCards();
        alert(`æˆåŠŸæ·»åŠ è‡ªå®šç¾©è§’è‰²: ${characterName}`);
      }
      
    } catch (error) {
      console.error('ä¸Šå‚³è‡ªå®šç¾©è§’è‰²å¤±æ•—:', error);
      alert('ä¸Šå‚³å¤±æ•—ï¼Œè«‹é‡è©¦');
    }
  }
  
  // ä¿®æ”¹è§’è‰²å¡ç‰‡æ¸²æŸ“å‡½æ•¸ï¼ŒåŒ…å«è‡ªå®šç¾©è§’è‰²
  async function renderAllCharacterCards() {
    cardGrid.innerHTML = '';
    
    // æ¸²æŸ“é è¨­è§’è‰²
    demoCharacters.forEach(c => {
      const el = document.createElement('div');
      el.className = 'card';
      el.innerHTML = `<img src="${c.img}" alt="${c.name}">
                      <div class="pt-1 text-center font-bold text-sm">${c.name}</div>`;
      el.onclick = () => selectCharacter(c);
      cardGrid.appendChild(el);
    });
    
    // æ¸²æŸ“è‡ªå®šç¾©è§’è‰²
    const customChars = await loadCustomCharacters();
    customChars.forEach(c => {
      const el = document.createElement('div');
      el.className = 'card relative';
      el.innerHTML = `<img src="${c.img}" alt="${c.name}">
                      <div class="pt-1 text-center font-bold text-sm">${c.name}</div>
                      <div class="absolute top-1 right-1 bg-purple-500 text-white text-xs px-1 rounded">è‡ªå®šç¾©</div>`;
      el.onclick = () => selectCharacter(c);
      cardGrid.appendChild(el);
    });
  }
  
  // ç¶å®šä¸Šå‚³æŒ‰éˆ•äº‹ä»¶
  if (btnUploadCustomChar) {
    btnUploadCustomChar.onclick = handleCustomCharacterUpload;
  }
  
  // ä¿®æ”¹åŸæœ¬çš„ renderCharacterCards å‡½æ•¸
  function renderCharacterCards() {
    renderAllCharacterCards();
  }



// === éŒ„éŸ³åŠŸèƒ½ï¼šçµæœå¡«å…¥è¼¸å…¥æ¡† ===

const recordBtn = document.getElementById("recordBtn");
const charPrompt = document.getElementById("charPrompt");

let mediaRecorder, audioChunks = [], isRecording = false;

// éŒ„éŸ³èª¿è©¦åŠŸèƒ½
function logRecordingEnvironment() {
  console.log('ğŸ” éŒ„éŸ³ç’°å¢ƒæª¢æ¸¬:');
  console.log('- User Agent:', navigator.userAgent);
  console.log('- Platform:', navigator.platform);
  console.log('- MediaDevices æ”¯æ´:', !!navigator.mediaDevices);
  console.log('- getUserMedia æ”¯æ´:', !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia));
  console.log('- MediaRecorder æ”¯æ´:', typeof MediaRecorder !== 'undefined');
  console.log('- æ˜¯å¦ç‚º HTTPS:', location.protocol === 'https:');
  console.log('- æ˜¯å¦ç‚º localhost:', location.hostname === 'localhost' || location.hostname === '127.0.0.1');
  console.log('- ç•¶å‰ URL:', location.href);
  console.log('- ç€è¦½å™¨èªè¨€:', navigator.language);
  console.log('- æ˜¯å¦ç‚ºç§»å‹•è¨­å‚™:', /Mobi|Android/i.test(navigator.userAgent));
  
  // æª¢æŸ¥æ˜¯å¦åœ¨ Capacitor ç’°å¢ƒä¸­
  console.log('- Capacitor ç’°å¢ƒ:', typeof window.Capacitor !== 'undefined');
  if (typeof window.Capacitor !== 'undefined') {
    console.log('- Capacitor å¹³å°:', window.Capacitor.getPlatform());
    console.log('- Capacitor æ˜¯å¦ç‚ºåŸç”Ÿ:', window.Capacitor.isNativePlatform());
  }
  
  if (typeof MediaRecorder !== 'undefined') {
    console.log('- æ”¯æ´çš„éŸ³é »æ ¼å¼:', {
      webm: MediaRecorder.isTypeSupported('audio/webm'),
      'webm;codecs=opus': MediaRecorder.isTypeSupported('audio/webm;codecs=opus'),
      mp4: MediaRecorder.isTypeSupported('audio/mp4'),
      'mp4;codecs=mp4a.40.2': MediaRecorder.isTypeSupported('audio/mp4;codecs=mp4a.40.2'),
      ogg: MediaRecorder.isTypeSupported('audio/ogg'),
      wav: MediaRecorder.isTypeSupported('audio/wav')
    });
  }
  
  // æª¢æŸ¥åª’é«”è¨­å‚™ç‹€æ…‹
  if (navigator.mediaDevices) {
    navigator.mediaDevices.enumerateDevices()
      .then(devices => {
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        console.log('- å¯ç”¨éŸ³é »è¼¸å…¥è¨­å‚™æ•¸é‡:', audioInputs.length);
        audioInputs.forEach((device, index) => {
          console.log(`  è¨­å‚™ ${index + 1}:`, {
            deviceId: device.deviceId,
            label: device.label || 'æœªçŸ¥è¨­å‚™',
            groupId: device.groupId
          });
        });
      })
      .catch(err => {
        console.log('- ç„¡æ³•æšèˆ‰åª’é«”è¨­å‚™:', err.message);
      });
  }
}

// éŒ„éŸ³è¨ºæ–·åŠŸèƒ½
async function runRecordingDiagnostic() {
  console.log('ğŸ¥ é–‹å§‹éŒ„éŸ³ç³»çµ±è¨ºæ–·...');
  
  const results = {
    environment: 'unknown',
    microphone: 'unknown',
    recorder: 'unknown',
    database: 'unknown',
    permissions: 'unknown'
  };
  
  try {
    // 1. ç’°å¢ƒæª¢æ¸¬
    logRecordingEnvironment();
    results.environment = 'ok';
    
    // 2. éº¥å…‹é¢¨æ¬Šé™æª¢æ¸¬
    console.log('ğŸ¤ æª¢æ¸¬éº¥å…‹é¢¨æ¬Šé™...');
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      console.log('âœ… éº¥å…‹é¢¨æ¬Šé™ç²å¾—æˆåŠŸ');
      results.microphone = 'ok';
      results.permissions = 'granted';
      
      // 3. MediaRecorder æª¢æ¸¬
      console.log('ğŸ›ï¸ æª¢æ¸¬ MediaRecorder...');
      if (typeof MediaRecorder !== 'undefined') {
        const recorder = new MediaRecorder(stream);
        console.log('âœ… MediaRecorder å»ºç«‹æˆåŠŸ, ç‹€æ…‹:', recorder.state);
        results.recorder = 'ok';
        
        // æ¸¬è©¦éŒ„éŸ³
        let testChunks = [];
        recorder.ondataavailable = e => testChunks.push(e.data);
        recorder.onstop = () => {
          const testBlob = new Blob(testChunks, { type: 'audio/webm' });
          console.log('ğŸ§ª æ¸¬è©¦éŒ„éŸ³å®Œæˆ, å¤§å°:', testBlob.size, 'bytes');
          
          if (testBlob.size > 0) {
            console.log('âœ… éŒ„éŸ³åŠŸèƒ½æ­£å¸¸');
          } else {
            console.log('âŒ éŒ„éŸ³æ²’æœ‰æ•¸æ“š');
          }
        };
        
        recorder.start();
        setTimeout(() => {
          recorder.stop();
        }, 1000);
        
      } else {
        console.log('âŒ MediaRecorder ä¸æ”¯æ´');
        results.recorder = 'not_supported';
      }
      
      // é‡‹æ”¾æ¸¬è©¦æµ
      stream.getTracks().forEach(track => {
        console.log('ğŸ›‘ åœæ­¢éŸ³è»Œ:', track.label);
        track.stop();
      });
      
    } catch (micError) {
      console.log('âŒ éº¥å…‹é¢¨æ¬Šé™å¤±æ•—:', micError);
      results.microphone = 'failed';
      results.permissions = micError.name || 'denied';
    }
    
    // 4. IndexedDB æª¢æ¸¬
    console.log('ğŸ’¾ æª¢æ¸¬ IndexedDB...');
    try {
      await AudioDB.init();
      console.log('âœ… IndexedDB é€£ç·šæˆåŠŸ');
      results.database = 'ok';
    } catch (dbError) {
      console.log('âŒ IndexedDB é€£ç·šå¤±æ•—:', dbError);
      results.database = 'failed';
    }
    
  } catch (error) {
    console.error('âŒ è¨ºæ–·éç¨‹ç™¼ç”ŸéŒ¯èª¤:', error);
  }
  
  console.log('ğŸ¥ è¨ºæ–·çµæœ:', results);
  
  // é¡¯ç¤ºè¨ºæ–·çµæœ
  const statusText = `
    ğŸ” éŒ„éŸ³ç³»çµ±è¨ºæ–·å ±å‘Š:
    - ç’°å¢ƒ: ${results.environment}
    - éº¥å…‹é¢¨: ${results.microphone}
    - éŒ„éŸ³å™¨: ${results.recorder}
    - è³‡æ–™åº«: ${results.database}
    - æ¬Šé™: ${results.permissions}
  `;
  
  showToast(statusText, { type: 'info', duration: 8000 });
  
  return results;
}

recordBtn.onclick = async () => {
  if (!isRecording) {
    console.log('ğŸ¤ é–‹å§‹éŒ„éŸ³æµç¨‹...');
    logRecordingEnvironment();
    
    try {
      console.log('ğŸ“± è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...');
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true
        }
      });
      
      console.log('âœ… éº¥å…‹é¢¨æ¬Šé™å·²ç²å¾—, éŸ³è»Œæ•¸é‡:', stream.getAudioTracks().length);
      console.log('ğŸµ éŸ³è»Œè³‡è¨Š:', stream.getAudioTracks().map(track => ({
        label: track.label,
        enabled: track.enabled,
        muted: track.muted,
        readyState: track.readyState,
        settings: track.getSettings()
      })));
      
      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];
      console.log('ğŸ¤ MediaRecorder å·²å»ºç«‹, ç‹€æ…‹:', mediaRecorder.state);

      mediaRecorder.ondataavailable = (e) => {
        console.log('ğŸ“Š æ”¶åˆ°éŸ³é »æ•¸æ“š:', e.data.size, 'bytes');
        audioChunks.push(e.data);
      };
      
      // ã€è®Šæ›´1ã€‘ main recordBtn.onstopï¼šå„²å­˜æœ€å¾ŒéŒ„éŸ³ blob èˆ‡ä½ç½®åˆ°å…¨åŸŸè®Šæ•¸
      mediaRecorder.onstop = async () => {
        console.log('ğŸ›‘ éŒ„éŸ³åœæ­¢, ç¸½æ•¸æ“šå¡Š:', audioChunks.length);
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        console.log('ğŸµ éŸ³é » Blob å·²å»ºç«‹:', audioBlob.size, 'bytes');

        // å„²å­˜åˆ°å…¨åŸŸä»¥ä¾¿ç¨å¾Œä¸Šå‚³
        window.lastRecordedAudioBlob = audioBlob;

        // ğŸ“ å˜—è©¦ç²å–ç•¶å‰ä½ç½®
        let locationData = {};
        try {
          console.log('ğŸ“ å˜—è©¦ç²å–åœ°ç†ä½ç½®...');
          const position = await getCurrentLocation();
          locationData = {
            latitude: position.latitude,
            longitude: position.longitude,
            accuracy: position.accuracy,
            place_name: `å°è©±ä½ç½® (${position.latitude.toFixed(6)}, ${position.longitude.toFixed(6)})`
          };
          console.log('âœ… ç²å¾—åœ°ç†ä½ç½®:', locationData);
        } catch (locationError) {
          console.warn('âš ï¸ ç„¡æ³•ç²å–åœ°ç†ä½ç½®:', locationError.message);
          locationData = {
            latitude: null,
            longitude: null,
            place_name: 'æœªçŸ¥ä½ç½®'
          };
        }

        // å°‡æœ€è¿‘ä½ç½®ä¹Ÿä¿åˆ°å…¨åŸŸï¼Œè®“ saveMemory å¯ä»¥ä½¿ç”¨
        window.lastLocation = locationData;

        // ğŸ“¤ å˜—è©¦ä¸Šå‚³åˆ°å¾Œç«¯
        try {
          console.log('â˜ï¸ å˜—è©¦ä¸Šå‚³éŒ„éŸ³åˆ°å¾Œç«¯...');
          const formData = new FormData();
          formData.append("audio", new File([audioBlob], `recording_${Date.now()}.webm`, { type: audioBlob.type }));
          formData.append("text", charPrompt.value || '');
          formData.append("place", locationData.place_name || '');
          formData.append("lat", locationData.latitude || '');
          formData.append("lng", locationData.longitude || '');
          
          // ç…§ç‰‡æ¬„ä½ (edit modal)
          const photoInput = document.getElementById('editUpload');
          if (photoInput && photoInput.files && photoInput.files[0]) {
            formData.append('photo', photoInput.files[0]);
          }

          const resp = await fetch(`${BACKEND_URL}/api/save_memory`, {
            method: 'POST',
            body: formData
          });

          const data = await resp.json().catch(()=>({}));

          if (resp.ok) {
            showToast('âœ… å›æ†¶å·²ä¸Šå‚³ä¸¦å„²å­˜', { type: 'success' });
            // è‹¥å¾Œç«¯å›å‚³çµæœï¼Œå¯æ ¹æ“šéœ€è¦æ›´æ–°æœ¬åœ° UI æˆ–é‡æ–°è¼‰å…¥åœ°åœ–
            // é—œé–‰ç·¨è¼¯ modalï¼ˆå¦‚æœé–‹å•Ÿï¼‰
            const editModal = document.getElementById('editModal');
            if (editModal) { editModal.classList.add('hidden'); }
          } else {
            // ä¸Šå‚³å¤±æ•— -> æš«å­˜å¾…åŒæ­¥
            showToast('âŒ ä¸Šå‚³å¤±æ•—ï¼Œå·²æš«å­˜å¾…åŒæ­¥', { type: 'error' });
            const pending = {
              id: Date.now().toString(),
              text: charPrompt.value || '',
              place: locationData.place_name || '',
              lat: locationData.latitude || '',
              lng: locationData.longitude || '',
              pendingAt: new Date().toISOString()
            };
            await LocalStorage.savePendingSync(pending);
          }
        } catch (uploadError) {
          console.error('ä¸Šå‚³éŒ„éŸ³åˆ°å¾Œç«¯å¤±æ•—:', uploadError);
          showToast('âŒ ä¸Šå‚³éŒ„éŸ³å¤±æ•—', { type: 'error' });
        }
        
        // é‡‹æ”¾åª’é«”æµ
        console.log('ğŸ”’ é‡‹æ”¾åª’é«”æµ...');
        const tracks = stream.getTracks();
        tracks.forEach(track => {
          console.log('ğŸ›‘ åœæ­¢éŸ³è»Œ:', track.label);
          track.stop();
        });
      };

      mediaRecorder.onerror = (event) => {
        console.error('âŒ MediaRecorder éŒ¯èª¤:', event.error);
        showToast(`âŒ éŒ„éŸ³å™¨éŒ¯èª¤: ${event.error}`, { type: 'error', duration: 5000 });
      };

      mediaRecorder.start();
      console.log('ğŸŸ¢ é–‹å§‹éŒ„éŸ³, MediaRecorder ç‹€æ…‹:', mediaRecorder.state);
      recordBtn.classList.add("is-recording");
      recordBtn.textContent = "ğŸŸ¥ åœæ­¢";
      isRecording = true;
      
      showToast('ğŸ¤ é–‹å§‹éŒ„éŸ³...', { type: 'info', duration: 1000 });
      
    } catch (err) {
      console.error('âŒ éº¥å…‹é¢¨å­˜å–éŒ¯èª¤:', err);
      
      let errorMessage = 'âŒ ç„¡æ³•å•Ÿç”¨éº¥å…‹é¢¨';
      let detailedError = '';
      
      console.log('ğŸ” éŒ¯èª¤è©³æƒ…:', {
        name: err.name,
        message: err.message,
        stack: err.stack
      });

      if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
        // é¡¯ç¤ºå¯ç”¨è¼¸å…¥è¨­å‚™åˆ—è¡¨å¹«åŠ©è¨ºæ–·
        navigator.mediaDevices?.enumerateDevices().then(devices=>{
          const audioInputs = devices.filter(d=>d.kind==='audioinput');
          const list = audioInputs.map(d=>d.label || d.deviceId).join(', ') || 'ç„¡å¯ç”¨éŸ³è¨Šè¼¸å…¥è£ç½®';
          showToast(`âŒ æ‰¾ä¸åˆ°éº¥å…‹é¢¨ã€‚å¯ç”¨è£ç½®: ${list}`, { type:'error', duration: 8000 });
        }).catch(()=> {
          showToast('âŒ æ‰¾ä¸åˆ°éº¥å…‹é¢¨ï¼Œè«‹ç¢ºèªè¨­å‚™å·²é€£æ¥æˆ–åœ¨ç³»çµ±è¨­å®šå…è¨±éŒ„éŸ³', { type:'error', duration: 8000 });
        });
      } else if (err.name === 'NotAllowedError') {
        errorMessage = 'âŒ éº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•ï¼Œè«‹åœ¨ç€è¦½å™¨è¨­å®šä¸­å…è¨±';
        detailedError = 'æ‚¨éœ€è¦å…è¨±ç¶²ç«™å­˜å–éº¥å…‹é¢¨æ‰èƒ½ä½¿ç”¨éŒ„éŸ³åŠŸèƒ½ã€‚';
      } else if (err.name === 'NotSupportedError') {
        errorMessage = 'âŒ ç€è¦½å™¨ä¸æ”¯æ´éŒ„éŸ³åŠŸèƒ½';
        detailedError = 'æ‚¨çš„ç€è¦½å™¨ç‰ˆæœ¬éèˆŠæˆ–ä¸æ”¯æ´æ­¤åŠŸèƒ½ã€‚';
      } else if (err.name === 'NotReadableError') {
        errorMessage = 'âŒ éº¥å…‹é¢¨è¢«å…¶ä»–æ‡‰ç”¨ç¨‹å¼ä½”ç”¨';
        detailedError = 'è«‹é—œé–‰å…¶ä»–å¯èƒ½æ­£åœ¨ä½¿ç”¨éº¥å…‹é¢¨çš„æ‡‰ç”¨ç¨‹å¼å¾Œå†è©¦ã€‚';
      } else {
        detailedError = err.message || 'æœªçŸ¥éŒ¯èª¤';
      }
      
      // é¡¯ç¤ºæ›´è©³ç´°çš„éŒ¯èª¤è¨Šæ¯
      showToast(`${errorMessage} (${detailedError})`, { type: 'error', duration: 6000 });
    }
  } else {
    mediaRecorder.stop();
    recordBtn.classList.remove("is-recording");
    recordBtn.textContent = "ğŸ¤  éŒ„éŸ³";
    isRecording = false;
  }
};
// === å…±ç”¨éŒ„éŸ³åŠŸèƒ½ ===
function setupRecorder(buttonId, targetTextareaId) {
  const btn = document.getElementById(buttonId);
  const target = document.getElementById(targetTextareaId);
  let mediaRecorder, audioChunks = [], isRecording = false;

  btn.onclick = async () => {
    if (!isRecording) {
      console.log('ğŸ¤ [å…±ç”¨éŒ„éŸ³] é–‹å§‹éŒ„éŸ³æµç¨‹...', buttonId);
      logRecordingEnvironment();
      
      try {
        console.log('ğŸ“± [å…±ç”¨éŒ„éŸ³] è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...');
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        console.log('âœ… [å…±ç”¨éŒ„éŸ³] éº¥å…‹é¢¨æ¬Šé™å·²ç²å¾—, éŸ³è»Œæ•¸é‡:', stream.getAudioTracks().length);
        console.log('ğŸµ [å…±ç”¨éŒ„éŸ³] éŸ³è»Œè³‡è¨Š:', stream.getAudioTracks().map(track => ({
          label: track.label,
          enabled: track.enabled,
          muted: track.muted,
          readyState: track.readyState,
          settings: track.getSettings()
        })));
        
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        console.log('ğŸ¤ [å…±ç”¨éŒ„éŸ³] MediaRecorder å·²å»ºç«‹, ç‹€æ…‹:', mediaRecorder.state);

        mediaRecorder.ondataavailable = (e) => {
          console.log('ğŸ“Š [å…±ç”¨éŒ„éŸ³] æ”¶åˆ°éŸ³é »æ•¸æ“š:', e.data.size, 'bytes');
          audioChunks.push(e.data);
        };
        
        // ã€è®Šæ›´2ã€‘ setupRecorder çš„ onstopï¼šåŒæ¨£å„²å­˜æœ€å¾ŒéŒ„éŸ³ blob èˆ‡ä½ç½®åˆ°å…¨åŸŸ
        mediaRecorder.onstop = async () => {
          console.log('ğŸ›‘ [å…±ç”¨éŒ„éŸ³] éŒ„éŸ³åœæ­¢, ç¸½æ•¸æ“šå¡Š:', audioChunks.length);
          target.value = "ï¼ˆèªéŸ³è¾¨è­˜ä¸­...ï¼‰";
          const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
          console.log('ğŸµ [å…±ç”¨éŒ„éŸ³] éŸ³é » Blob å·²å»ºç«‹:', audioBlob.size, 'bytes');

          // å„²å­˜åˆ°å…¨åŸŸä»¥ä¾¿ç¨å¾Œä¸Šå‚³
          window.lastRecordedAudioBlob = audioBlob;

          // ğŸ“ å˜—è©¦ç²å–ç•¶å‰ä½ç½®
          let locationData = {};
          try {
            console.log('ğŸ“ [å…±ç”¨éŒ„éŸ³] å˜—è©¦ç²å–åœ°ç†ä½ç½®...');
            const position = await getCurrentLocation();
            locationData = {
              latitude: position.latitude,
              longitude: position.longitude,
              accuracy: position.accuracy,
              place_name: `ä½ç½® (${position.latitude.toFixed(6)}, ${position.longitude.toFixed(6)})`
            };
            console.log('âœ… [å…±ç”¨éŒ„éŸ³] ç²å¾—åœ°ç†ä½ç½®:', locationData);
          } catch (locationError) {
            console.warn('âš ï¸ [å…±ç”¨éŒ„éŸ³] ç„¡æ³•ç²å–åœ°ç†ä½ç½®:', locationError.message);
            locationData = {
              latitude: null,
              longitude: null,
              place_name: 'æœªçŸ¥ä½ç½®'
            };
          }

          // å°‡æœ€è¿‘ä½ç½®ä¹Ÿä¿åˆ°å…¨åŸŸï¼Œè®“ saveMemory å¯ä»¥ä½¿ç”¨
          window.lastLocation = locationData;

          // ...existing code continues...
        };

        mediaRecorder.onerror = (event) => {
          console.error('âŒ [å…±ç”¨éŒ„éŸ³] MediaRecorder éŒ¯èª¤:', event.error);
          showToast(`âŒ éŒ„éŸ³å™¨éŒ¯èª¤: ${event.error}`, { type: 'error', duration: 5000 });
        };

        mediaRecorder.start();
        console.log('ğŸŸ¢ [å…±ç”¨éŒ„éŸ³] é–‹å§‹éŒ„éŸ³, MediaRecorder ç‹€æ…‹:', mediaRecorder.state);
        btn.classList.add("is-recording");
        btn.textContent = "ğŸŸ¥ åœæ­¢";
        isRecording = true;
        
        showToast('ğŸ¤ é–‹å§‹éŒ„éŸ³...', { type: 'info', duration: 1000 });
      } catch (err) {
        console.error('âŒ [å…±ç”¨éŒ„éŸ³] éº¥å…‹é¢¨å­˜å–éŒ¯èª¤:', err);
        
        let errorMessage = 'âŒ ç„¡æ³•å•Ÿç”¨éº¥å…‹é¢¨';
        
        if (err.name === 'NotAllowedError') {
          errorMessage = 'âŒ éº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•ï¼Œè«‹åœ¨ç€è¦½å™¨è¨­å®šä¸­å…è¨±';
        } else if (err.name === 'NotFoundError') {
          errorMessage = 'âŒ æ‰¾ä¸åˆ°éº¥å…‹é¢¨è¨­å‚™ï¼Œè«‹æª¢æŸ¥æ˜¯å¦å·²é€£æ¥ã€‚';
        } else if (err.name === 'NotSupportedError') {
          errorMessage = 'âŒ ç€è¦½å™¨ä¸æ”¯æ´éŒ„éŸ³åŠŸèƒ½';
        } else if (err.name === 'NotReadableError') {
          errorMessage = 'âŒ éº¥å…‹é¢¨è¢«å…¶ä»–æ‡‰ç”¨ç¨‹å¼ä½”ç”¨';
        }
        
        console.log('ğŸ” [å…±ç”¨éŒ„éŸ³] éŒ¯èª¤è©³æƒ…:', {
          name: err.name,
          message: err.message,
          stack: err.stack,
          buttonId: buttonId,
          targetId: targetTextareaId
        });
        
        showToast(errorMessage, { type: 'error', duration: 6000 });
        target.value = "éº¥å…‹é¢¨ç„¡æ³•ä½¿ç”¨ï¼Œè«‹æ‰‹å‹•è¼¸å…¥";
      }
    } else {
      mediaRecorder.stop();
      btn.classList.remove("is-recording");
      btn.textContent = "ğŸ¤  éŒ„éŸ³";
      isRecording = false;
    }
  };
}


function appendMessage(sender, text) {
  const chatBox = document.getElementById("chat-box");
  const msg = document.createElement("div");
  msg.className = sender === "user" ? "text-right text-blue-700" : "text-left text-brown-700";
  msg.textContent = sender === "user" ? `ğŸ§‘â€ğŸ’¬ ${text}` : `ğŸ¤– å°å…‰ï¼š${text}`;
  chatBox.appendChild(msg);
  chatBox.scrollTop = chatBox.scrollHeight;
}

// ğŸ§ èªéŸ³ â†’ æ–‡å­—ï¼ˆåœ–è¡¨æ¶æ§‹ï¼šçµ±ä¸€ä¸Šå‚³å¾Œç«¯è™•ç†ï¼‰
async function transcribeAudio(audioBlob) {
  try {
    console.log("ğŸ™ï¸ é–‹å§‹èªéŸ³è½‰æ–‡å­—ï¼ŒéŸ³é »å¤§å°:", audioBlob.size, "å­—ç¯€");
    
    // æª¢æŸ¥éŸ³é »å¤§å°
    if (audioBlob.size < 1000) {
      console.warn("éŸ³é »æ–‡ä»¶å¤ªå°ï¼Œå¯èƒ½éŒ„éŸ³å¤±æ•—");
      return "éŒ„éŸ³æ™‚é–“å¤ªçŸ­ï¼Œè«‹é‡æ–°éŒ„éŸ³";
    }

    // æª¢æŸ¥ç¶²è·¯ç‹€æ…‹
    const isOnline = NetworkManager.isOnline();
    
    if (isOnline) {
      // ç·šä¸Šæ¨¡å¼ï¼šå„ªå…ˆé †åº 1) å¾Œç«¯ Whisper 2) Hugging Face Whisper 3) åŸç”Ÿè­˜åˆ¥
      console.log("ğŸŒ ç·šä¸Šæ¨¡å¼ï¼šå˜—è©¦èªéŸ³è­˜åˆ¥");
      
      // æ–¹æ³•1: å˜—è©¦å¾Œç«¯ Whisper
      const backendAvailable = await NetworkManager.checkBackendConnection();
      if (backendAvailable.success) {
        try {
          console.log("ï¿½ ä½¿ç”¨å¾Œç«¯ Whisper API");
          const formData = new FormData();
          formData.append("audio", audioBlob, "recording.wav");
          
          const response = await fetch(`${BACKEND_URL}/api/transcribe`, {
            method: "POST",
            body: formData,
          });

          if (response.ok) {
            const result = await response.json();
            console.log("âœ… å¾Œç«¯ Whisper çµæœï¼š", result);
            
            if (result.text && result.text.trim()) {
              showToast('âœ… èªéŸ³è­˜åˆ¥æˆåŠŸ (å¾Œç«¯)', { type: 'success', duration: 2000 });
              return result.text.trim();
            }
          }
        } catch (backendError) {
          console.warn("å¾Œç«¯ Whisper å¤±æ•—ï¼Œå˜—è©¦å…¶å®ƒæ–¹æ³•:", backendError);
        }
      }
      
      // æ–¹æ³•2: ä½¿ç”¨ Hugging Face Whisper APIï¼ˆæ‰‹æ©Ÿç‰ˆå„ªåŒ–ï¼‰
      try {
        console.log("ğŸ¤— ä½¿ç”¨ Hugging Face Whisper API");
        const hfResult = await transcribeWithHuggingFaceMobile(audioBlob);
        if (hfResult && hfResult.trim()) {
          showToast('âœ… èªéŸ³è­˜åˆ¥æˆåŠŸ (Whisper)', { type: 'success', duration: 2000 });
          return hfResult.trim();
        }
      } catch (hfError) {
        console.warn("Hugging Face Whisper å¤±æ•—:", hfError);
        showToast('âš ï¸ Whisper API å¤±æ•—ï¼Œå˜—è©¦åŸç”Ÿè­˜åˆ¥', { type: 'warning', duration: 2000 });
      }
      
      // æ–¹æ³•3: ä½¿ç”¨åŸç”ŸèªéŸ³è­˜åˆ¥
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        try {
          console.log("ğŸ¤ ä½¿ç”¨åŸç”ŸèªéŸ³è­˜åˆ¥");
          const nativeResult = await useNativeSpeechRecognition();
          if (nativeResult && nativeResult.trim()) {
            showToast('âœ… èªéŸ³è­˜åˆ¥æˆåŠŸ (åŸç”Ÿ)', { type: 'success', duration: 2000 });
            return nativeResult.trim();
          }
        } catch (nativeError) {
          console.warn("åŸç”ŸèªéŸ³è­˜åˆ¥å¤±æ•—:", nativeError);
        }
      }
      
      // æ‰€æœ‰æ–¹æ³•éƒ½å¤±æ•—
      showToast('âš ï¸ èªéŸ³è­˜åˆ¥å¤±æ•—ï¼ŒéŸ³é »å·²æš«å­˜', { type: 'warning' });
      await LocalStorage.saveAudioForUpload(audioBlob, {
        timestamp: new Date().toISOString(),
        purpose: 'transcription'
      });
      return "èªéŸ³å·²æš«å­˜ï¼Œè«‹æ‰‹å‹•è¼¸å…¥å…§å®¹";
      
    } else {
      // é›¢ç·šæ¨¡å¼ï¼šæš«å­˜éŸ³é »
      console.log("ğŸ“± é›¢ç·šæ¨¡å¼ï¼šæš«å­˜éŸ³é »ç­‰å¾…åŒæ­¥");
      
      await LocalStorage.saveAudioForUpload(audioBlob, {
        timestamp: new Date().toISOString(),
        purpose: 'transcription'
      });
      
      showToast('ğŸ’¾ éŸ³é »å·²æš«å­˜ï¼Œå°‡åœ¨é€£ç·šå¾Œè™•ç†', { type: 'info', duration: 3000 });
      
      // å˜—è©¦ä½¿ç”¨åŸç”ŸèªéŸ³è­˜åˆ¥ä½œç‚ºæš«æ™‚æ–¹æ¡ˆï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        try {
          console.log("ğŸ”„ å˜—è©¦åŸç”ŸèªéŸ³è­˜åˆ¥ä½œç‚ºæš«æ™‚æ–¹æ¡ˆ");
          const nativeResult = await useNativeSpeechRecognition();
          console.log("åŸç”ŸèªéŸ³è­˜åˆ¥æš«æ™‚çµæœ:", nativeResult);
          return nativeResult + " (é›¢ç·šæš«å­˜)";
        } catch (nativeError) {
          console.warn("åŸç”ŸèªéŸ³è­˜åˆ¥ä¹Ÿå¤±æ•—:", nativeError);
        }
      }
      
      return "éŸ³é »å·²æš«å­˜ï¼Œè«‹æ‰‹å‹•è¼¸å…¥å…§å®¹æˆ–ç­‰å¾…ç¶²è·¯æ¢å¾©";
    }

  } catch (e) {
    console.error("èªéŸ³è½‰æ–‡å­—éŒ¯èª¤:", e);
    showToast('ğŸ’¡ èªéŸ³è½‰æ–‡å­—å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¼¸å…¥', { type: 'info', duration: 3000 });
    return "è«‹æ‰‹å‹•è¼¸å…¥æ‚¨å‰›æ‰èªªçš„å…§å®¹";
  }
}

// åŸç”ŸèªéŸ³è­˜åˆ¥åŠŸèƒ½ï¼ˆæ‰‹æ©Ÿç‰ˆå°ˆç”¨ï¼‰
async function useNativeSpeechRecognition() {
  return new Promise((resolve, reject) => {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    
    if (!SpeechRecognition) {
      reject(new Error("ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è­˜åˆ¥"));
      return;
    }
    
    const recognition = new SpeechRecognition();
    
    // è¨­å®šèªéŸ³è­˜åˆ¥åƒæ•¸
    recognition.lang = 'zh-TW'; // ç¹é«”ä¸­æ–‡
    recognition.continuous = false; // å–®æ¬¡è­˜åˆ¥
    recognition.interimResults = false; // ä¸è¦ä¸­é–“çµæœ
    recognition.maxAlternatives = 1; // åªè¦æœ€ä½³çµæœ
    
    let timeout;
    
    recognition.onstart = () => {
      console.log("åŸç”ŸèªéŸ³è­˜åˆ¥é–‹å§‹...");
      showToast('ğŸ¤ è«‹é–‹å§‹èªªè©±', { type: 'info', duration: 2000 });
      
      // è¨­å®šè¶…æ™‚
      timeout = setTimeout(() => {
        recognition.stop();
        reject(new Error("èªéŸ³è­˜åˆ¥è¶…æ™‚"));
      }, 8000); // 8ç§’è¶…æ™‚
    };
    
    recognition.onresult = (event) => {
      clearTimeout(timeout);
      const result = event.results[0][0].transcript;
      console.log("åŸç”ŸèªéŸ³è­˜åˆ¥çµæœ:", result);
      showToast('âœ… è­˜åˆ¥æˆåŠŸï¼', { type: 'success', duration: 1000 });
      resolve(result);
    };
    
    recognition.onerror = (event) => {
      clearTimeout(timeout);
      console.error("åŸç”ŸèªéŸ³è­˜åˆ¥éŒ¯èª¤:", event.error);
      
      let errorMsg = "èªéŸ³è­˜åˆ¥å¤±æ•—";
      switch(event.error) {
        case 'no-speech':
          errorMsg = "æ²’æœ‰æª¢æ¸¬åˆ°èªéŸ³ï¼Œè«‹é‡æ–°éŒ„éŸ³";
          break;
        case 'audio-capture':
          errorMsg = "ç„¡æ³•å­˜å–éº¥å…‹é¢¨";
          break;
        case 'not-allowed':
          errorMsg = "éº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•";
          break;
        case 'network':
          errorMsg = "ç¶²è·¯é€£ç·šå•é¡Œ";
          break;
      }
      
      reject(new Error(errorMsg));
    };
    
    recognition.onend = () => {
      clearTimeout(timeout);
      console.log("åŸç”ŸèªéŸ³è­˜åˆ¥çµæŸ");
    };
    
    // é–‹å§‹è­˜åˆ¥
    try {
      recognition.start();
    } catch (startError) {
      clearTimeout(timeout);
      reject(new Error("ç„¡æ³•å•Ÿå‹•èªéŸ³è­˜åˆ¥: " + startError.message));
    }
  });
}

// === åœ°ç†ä½ç½®å’ŒéŒ„éŸ³åœ°åœ–åŠŸèƒ½ ===

// ç²å–ç•¶å‰åœ°ç†ä½ç½®
async function getCurrentLocation() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('æ­¤è£ç½®ä¸æ”¯æ´åœ°ç†ä½ç½®'));
      return;
    }
    
    const options = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 60000
    };
    
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log('ğŸ“ ç²å¾—åœ°ç†ä½ç½®:', position.coords);
        resolve({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy
        });
      },
      (error) => {
        console.warn('âŒ åœ°ç†ä½ç½®ç²å–å¤±æ•—:', error);
        let errorMsg = 'ç„¡æ³•ç²å–ä½ç½®';
        switch(error.code) {
          case error.PERMISSION_DENIED:
            errorMsg = 'ä½ç½®æ¬Šé™è¢«æ‹’çµ•';
            break;
          case error.POSITION_UNAVAILABLE:
            errorMsg = 'ä½ç½®è³‡è¨Šç„¡æ³•ä½¿ç”¨';
            break;
          case error.TIMEOUT:
            errorMsg = 'ä½ç½®è«‹æ±‚è¶…æ™‚';
            break;
        }
        reject(new Error(errorMsg));
      },
      options
    );
  });
}

// å°‡éŒ„éŸ³æ¨™è¨˜æ·»åŠ åˆ°åœ°åœ–
function addAudioMarkerToMap(recordingId, lat, lng, placeName = null) {
  try {
    // å‰µå»ºéŸ³é »åœ–æ¨™
    const audioIcon = L.icon({
      iconUrl: 'data:image/svg+xml;base64,' + btoa(`
        <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
          <circle cx="20" cy="20" r="18" fill="#ff6b6b" stroke="#fff" stroke-width="2"/>
          <path d="M15 12h10v16h-10z" fill="#fff"/>
          <circle cx="20" cy="30" r="3" fill="#fff"/>
        </svg>
      `),
      iconSize: [40, 40],
      iconAnchor: [20, 40],
      popupAnchor: [0, -40]
    });
    
    const marker = L.marker([lat, lng], { icon: audioIcon }).addTo(map);
    
    // å‰µå»º popup å…§å®¹
    const popupContent = `
      <div class="audio-popup" style="min-width: 200px;">
        <h3 style="margin: 0 0 10px 0; color: #333;">ğŸ¤ éŒ„éŸ³è¨˜æ†¶</h3>
        ${placeName ? `<p style="margin: 5px 0; color: #666;">ğŸ“ ${placeName}</p>` : ''}
        <div style="margin-top: 10px;">
          <button onclick="playRecordingFromMap('${recordingId}')" 
                  style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 5px;">
            â–¶ï¸ æ’­æ”¾
          </button>
          <button onclick="deleteRecordingFromMap('${recordingId}', this)" 
                  style="background: #f44336; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
            ğŸ—‘ï¸ åˆªé™¤
          </button>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #888;">
          éŒ„éŸ³ ID: ${recordingId}
        </div>
      </div>
    `;
    
    marker.bindPopup(popupContent);
    
    // å„²å­˜æ¨™è¨˜åƒè€ƒï¼Œæ–¹ä¾¿ä¹‹å¾Œç®¡ç†
    if (!window.audioMarkers) window.audioMarkers = new Map();
    window.audioMarkers.set(recordingId, marker);
    
    console.log('ğŸ—ºï¸ éŒ„éŸ³æ¨™è¨˜å·²æ·»åŠ åˆ°åœ°åœ–:', recordingId, lat, lng);
    
  } catch (error) {
    console.error('âŒ æ·»åŠ éŒ„éŸ³æ¨™è¨˜å¤±æ•—:', error);
  }
}

// å¾åœ°åœ–æ’­æ”¾éŒ„éŸ³
async function playRecordingFromMap(recordingId) {
  try {
    const result = await AudioDB.playRecording(recordingId);
    if (result.success) {
      showToast('ğŸµ é–‹å§‹æ’­æ”¾éŒ„éŸ³', { type: 'success', duration: 2000 });
    } else {
      showToast('âŒ æ’­æ”¾å¤±æ•—', { type: 'error', duration: 3000 });
    }
  } catch (error) {
    console.error('æ’­æ”¾éŒ„éŸ³å¤±æ•—:', error);
    showToast('âŒ æ’­æ”¾éŒ¯èª¤: ' + error.message, { type: 'error', duration: 3000 });
  }
}

// å¾åœ°åœ–åˆªé™¤éŒ„éŸ³
async function deleteRecordingFromMap(recordingId, buttonElement) {
  if (confirm('ç¢ºå®šè¦åˆªé™¤é€™å€‹éŒ„éŸ³å—ï¼Ÿ')) {
    try {
      const result = await AudioDB.deleteRecording(recordingId);
      if (result.success) {
        // ç§»é™¤åœ°åœ–æ¨™è¨˜
        if (window.audioMarkers && window.audioMarkers.has(recordingId)) {
          const marker = window.audioMarkers.get(recordingId);
          map.removeLayer(marker);
          window.audioMarkers.delete(recordingId);
        }
        
        // é—œé–‰ popup
        map.closePopup();
        
        showToast('âœ… éŒ„éŸ³å·²åˆªé™¤', { type: 'success', duration: 2000 });
      } else {
        showToast('âŒ åˆªé™¤å¤±æ•—', { type: 'error', duration: 3000 });
      }
    } catch (error) {
      console.error('åˆªé™¤éŒ„éŸ³å¤±æ•—:', error);
      showToast('âŒ åˆªé™¤éŒ¯èª¤: ' + error.message, { type: 'error', duration: 3000 });
    }
  }
}

async function clearAllAudio() {
  if (confirm('âš ï¸ ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰éŒ„éŸ³å—ï¼Ÿé€™å€‹æ“ä½œç„¡æ³•å¾©åŸï¼')) {
    try {
      const recordings = await AudioDB.loadAllRecordings();
      for (const recording of recordings) {
        await AudioDB.deleteRecording(recording.id);
      }
      showToast('ğŸ—‘ï¸ æ‰€æœ‰éŒ„éŸ³å·²æ¸…ç©º', { type: 'success' });
      openAudioManager(); // é‡æ–°è¼‰å…¥åˆ—è¡¨
    } catch (error) {
      console.error('æ¸…ç©ºå¤±æ•—:', error);
      showToast('âŒ æ¸…ç©ºå¤±æ•—', { type: 'error' });
    }
  }
}

// åœ¨é é¢è¼‰å…¥æ™‚åˆå§‹åŒ– IndexedDB ä¸¦åŸ·è¡Œè¨ºæ–·
document.addEventListener('DOMContentLoaded', async () => {
  console.log('ğŸš€ é é¢è¼‰å…¥å®Œæˆï¼Œé–‹å§‹åˆå§‹åŒ–...');
  
  try {
    await AudioDB.init();
    console.log('âœ… IndexedDB éŸ³é »ç®¡ç†å·²åˆå§‹åŒ–');
    
    // è¼‰å…¥æ‰€æœ‰éŒ„éŸ³æ¨™è¨˜åˆ°åœ°åœ–
    setTimeout(async () => {
      await loadAudioMarkersToMap();
    }, 1000);
    
    // å»¶é²åŸ·è¡Œè¨ºæ–·ï¼Œè®“é é¢å®Œå…¨è¼‰å…¥
    setTimeout(async () => {
      console.log('ğŸ¥ é–‹å§‹éŒ„éŸ³ç³»çµ±å®Œæ•´è¨ºæ–·...');
      await runRecordingDiagnostic();
    }, 2000);
    
  } catch (error) {
    console.error('âŒ IndexedDB åˆå§‹åŒ–å¤±æ•—:', error);
    showToast(`âŒ éŸ³é »è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—: ${error.message}`, { type: 'error', duration: 5000 });
  }
});

// --- åœ¨ LocalStorage å€æ®µçµæŸå¾Œï¼Œæ–°å¢ getAIReply å¯¦ä½œ ---
  // LocalStorage.getOfflineAIReply å·²å­˜åœ¨æ–¼ä¸Šæ–¹
  async function getAIReply(text) {
    try {
      // è‹¥é›¢ç·šæˆ–å¾Œç«¯ä¸å¯ç”¨ï¼Œå›é€€åˆ°æœ¬åœ°é›¢ç·šå›è¦†
      if (!NetworkManager.isOnline()) {
        const offline = await LocalStorage.getOfflineAIReply(text);
        return offline.response;
      }

      // å„ªå…ˆå‘¼å«å¾Œç«¯ chat API
      try {
        const res = await fetch(HF_CHAT_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text })
        });
        if (res.ok) {
          const data = await res.json();
          // æ”¯æ´é™£åˆ—æˆ–ç‰©ä»¶å›å‚³æ ¼å¼
          return Array.isArray(data) ? (data[0]?.generated_text || data[0]?.text || "æˆ‘æ²’è½æ‡‚") : (data.generated_text || data.text || "æˆ‘æ²’è½æ‡‚");
        }
      } catch (err) {
        console.warn("getAIReply: å¾Œç«¯ chat è«‹æ±‚å¤±æ•—ï¼Œå›é€€åˆ°é›¢ç·šå›æ‡‰", err);
      }

      // æœ€å¾Œå›é€€åˆ°æœ¬åœ°é›¢ç·šå›æ‡‰
      const offline = await LocalStorage.getOfflineAIReply(text);
      return offline.response;
    } catch (e) {
      console.error("getAIReply error:", e);
      try { const offline = await LocalStorage.getOfflineAIReply(text); return offline.response; } catch (_) { return "æˆ‘ç¾åœ¨ç„¡æ³•å›æ‡‰ï¼Œè«‹ç¨å¾Œå†è©¦"; }
    }
  }

  // === éŒ„éŸ³ç®¡ç†åŠŸèƒ½ ===
  async function openAudioManager() {
    const modal = document.getElementById('audioManagerModal');
    modal.classList.remove('hidden');
    modal.classList.add('flex');

    // è¼‰å…¥çµ±è¨ˆè³‡è¨Š
    const stats = await AudioDB.getStorageStats();
    document.getElementById('audioStats').innerHTML = `
      ğŸ“Š å…± ${stats.count} å€‹éŒ„éŸ³ | ğŸ“¦ ${stats.totalSizeMB} MB | ğŸ”„ ${stats.unsyncedCount} å€‹å¾…åŒæ­¥
    `;
    
    // è¼‰å…¥éŒ„éŸ³åˆ—è¡¨
    const recordings = await AudioDB.loadAllRecordings();
    const audioList = document.getElementById('audioList');
    
    if (recordings.length === 0) {
      audioList.innerHTML = `
        <div class="text-center text-gray-500 py-8">
          ğŸ¤ é‚„æ²’æœ‰ä»»ä½•éŒ„éŸ³è¨˜éŒ„
        </div>
      `;
      return;
    }
    
    audioList.innerHTML = recordings.map(recording => `
      <div class="bg-gray-50 rounded-lg p-4 mb-3 border">
        <div class="flex justify-between items-start mb-2">
          <div class="flex-1">
            <div class="text-sm font-medium text-gray-800">
              éŒ„éŸ³ #${recording.id}
            </div>
            <div class="text-xs text-gray-500">
              ğŸ“… ${new Date(recording.date).toLocaleString()}
            </div>
            <div class="text-xs text-gray-500">
              ğŸ“Š ${(recording.size / 1024).toFixed(1)} KB | ${recording.type}
            </div>
            ${recording.transcription ? `<div class="text-sm text-blue-600 mt-1">ğŸ’¬ ${recording.transcription}</div>` : ''}
          </div>
          <div class="flex gap-2">
            <button onclick="playAudioRecord(${recording.id})" 
                    class="bg-green-500 text-white px-3 py-1 rounded text-xs hover:bg-green-600">
              â–¶ï¸ æ’­æ”¾
            </button>
            <button onclick="deleteAudioRecord(${recording.id})" 
                    class="bg-red-500 text-white px-3 py-1 rounded text-xs hover:bg-red-600">
              ğŸ—‘ï¸
            </button>
          </div>
        </div>
        <div class="flex items-center gap-2">
          <span class="text-xs px-2 py-1 rounded ${recording.synced ? 'bg-green-100 text-green-600' : 'bg-yellow-100 text-yellow-600'}">
            ${recording.synced ? 'âœ… å·²åŒæ­¥' : 'â³ å¾…åŒæ­¥'}
          </span>
          ${recording.source ? `<span class="text-xs px-2 py-1 bg-blue-100 text-blue-600 rounded">ğŸ“ ${recording.source}</span>` : ''}
        </div>
      </div>
    `).join('');
  }

  // ...existing code...
</script>
<!-- ...existing code... -->